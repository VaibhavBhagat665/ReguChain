"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.15.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFpRSxHQUNqRTs7Q0FFQyxHQUNNLE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/NmUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBEbyBOT1QgbW9kaWZ5IHRoaXMgZmlsZTsgc2VlIC9zcmMudHMvX2FkbWluL3VwZGF0ZS12ZXJzaW9uLnRzICovXG4vKipcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjYuMTUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/boolean.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/string.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/tuple.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_3__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(param.components.map((c)=>this.#getCoder(c)), param.name);\n        }\n        switch(param.baseType){\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_5__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_7__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n} //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG1FQUFtRTtBQUNLO0FBQ1o7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUNNO0FBQ2dCO0FBQ2pFLG1FQUFtRTtBQUNuRSxNQUFNa0IsZUFBZSxJQUFJQztBQUN6QkQsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkIsTUFBTUMsaUJBQWlCLElBQUlDLE9BQU87QUFDbEMsTUFBTUMsa0JBQWtCLElBQUlELE9BQU87QUFDbkMsSUFBSUUsZUFBZTtBQUNuQixJQUFJQyxzQkFBc0I7QUFDMUIsU0FBU0Msd0JBQXdCQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ3ZELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsYUFBYTtJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUwsTUFBTTtRQUNORSxVQUFVO1FBQ1YsTUFBTUksUUFBUXBCLHlEQUFRQSxDQUFDYztRQUN2QkEsT0FBT2Isd0RBQU9BLENBQUNhO1FBQ2YsSUFBSU0sTUFBTUMsTUFBTSxLQUFLLEdBQUc7WUFDcEJMLFdBQVc7WUFDWEMsU0FBUztRQUNiLE9BQ0ssSUFBSUcsTUFBTUMsTUFBTSxHQUFHLE9BQU8sR0FBRztZQUM5QkwsV0FBVztRQUNmLE9BQ0ssSUFBSWYsd0RBQU9BLENBQUNtQixNQUFNRSxLQUFLLENBQUMsR0FBRyxRQUFRLGNBQWM7WUFDbEQsZ0JBQWdCO1lBQ2hCLElBQUk7Z0JBQ0FMLFNBQVNGLFNBQVNRLE1BQU0sQ0FBQztvQkFBQztpQkFBUyxFQUFFSCxNQUFNRSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3ZESCxTQUFTO29CQUNMSyxXQUFXO29CQUNYQyxNQUFNO29CQUNOQyxNQUFNO3dCQUFDVDtxQkFBTztnQkFDbEI7Z0JBQ0FELFdBQVcsQ0FBQyxFQUFFLEVBQUVXLEtBQUtDLFNBQVMsQ0FBQ1gsUUFBUSxDQUFDO1lBQzVDLEVBQ0EsT0FBT1ksT0FBTztnQkFDVmIsV0FBVztZQUNmO1FBQ0osT0FDSyxJQUFJZix3REFBT0EsQ0FBQ21CLE1BQU1FLEtBQUssQ0FBQyxHQUFHLFFBQVEsY0FBYztZQUNsRCxpQkFBaUI7WUFDakIsSUFBSTtnQkFDQSxNQUFNUSxPQUFPQyxPQUFPaEIsU0FBU1EsTUFBTSxDQUFDO29CQUFDO2lCQUFVLEVBQUVILE1BQU1FLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDbkVILFNBQVM7b0JBQ0xLLFdBQVc7b0JBQ1hDLE1BQU07b0JBQ05DLE1BQU07d0JBQUNJO3FCQUFLO2dCQUNoQjtnQkFDQWIsU0FBUyxDQUFDLGFBQWEsRUFBRWQsYUFBYTZCLEdBQUcsQ0FBQ0YsU0FBUyxVQUFVLENBQUMsRUFBRUEsS0FBSyxDQUFDLENBQUM7Z0JBQ3ZFZCxXQUFXLENBQUMsRUFBRSxFQUFFQyxPQUFPLENBQUM7WUFDNUIsRUFDQSxPQUFPWSxPQUFPO2dCQUNWYixXQUFXO1lBQ2Y7UUFDSixPQUNLO1lBQ0RBLFdBQVc7UUFDZjtJQUNKO0lBQ0EsTUFBTWlCLGNBQWM7UUFDaEJDLElBQUtyQixHQUFHcUIsRUFBRSxHQUFHbkMsNkRBQVVBLENBQUNjLEdBQUdxQixFQUFFLElBQUk7UUFDakNwQixNQUFPRCxHQUFHQyxJQUFJLElBQUk7SUFDdEI7SUFDQSxJQUFJRCxHQUFHc0IsSUFBSSxFQUFFO1FBQ1RGLFlBQVlFLElBQUksR0FBR3BDLDZEQUFVQSxDQUFDYyxHQUFHc0IsSUFBSTtJQUN6QztJQUNBLE9BQU9qQywwREFBU0EsQ0FBQ2MsU0FBUyxrQkFBa0I7UUFDeENKO1FBQVFFO1FBQU1HO1FBQVFnQjtRQUFhZjtRQUFZQztJQUNuRDtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTWlCO0lBQ1QsQ0FBQ0MsUUFBUSxDQUFDQyxLQUFLO1FBQ1gsSUFBSUEsTUFBTUMsT0FBTyxJQUFJO1lBQ2pCLE9BQU8sSUFBSWpELHdEQUFVQSxDQUFDLElBQUksQ0FBQyxDQUFDK0MsUUFBUSxDQUFDQyxNQUFNRSxhQUFhLEdBQUdGLE1BQU1HLFdBQVcsRUFBRUgsTUFBTWIsSUFBSTtRQUM1RjtRQUNBLElBQUlhLE1BQU1JLE9BQU8sSUFBSTtZQUNqQixPQUFPLElBQUk3Qyx3REFBVUEsQ0FBQ3lDLE1BQU1LLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLElBQU0sSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQ1EsS0FBS1AsTUFBTWIsSUFBSTtRQUNwRjtRQUNBLE9BQVFhLE1BQU1RLFFBQVE7WUFDbEIsS0FBSztnQkFDRCxPQUFPLElBQUl6RCw0REFBWUEsQ0FBQ2lELE1BQU1iLElBQUk7WUFDdEMsS0FBSztnQkFDRCxPQUFPLElBQUlsQyw0REFBWUEsQ0FBQytDLE1BQU1iLElBQUk7WUFDdEMsS0FBSztnQkFDRCxPQUFPLElBQUk3QiwwREFBV0EsQ0FBQzBDLE1BQU1iLElBQUk7WUFDckMsS0FBSztnQkFDRCxPQUFPLElBQUlqQyx3REFBVUEsQ0FBQzhDLE1BQU1iLElBQUk7WUFDcEMsS0FBSztnQkFDRCxPQUFPLElBQUkvQixzREFBU0EsQ0FBQzRDLE1BQU1iLElBQUk7UUFDdkM7UUFDQSxjQUFjO1FBQ2QsSUFBSXNCLFFBQVFULE1BQU1VLElBQUksQ0FBQ0QsS0FBSyxDQUFDdkM7UUFDN0IsSUFBSXVDLE9BQU87WUFDUCxJQUFJRSxPQUFPQyxTQUFTSCxLQUFLLENBQUMsRUFBRSxJQUFJO1lBQ2hDN0QsK0RBQWNBLENBQUMrRCxTQUFTLEtBQUtBLFFBQVEsT0FBTyxPQUFRLE1BQU8sR0FBRyxhQUFhRixLQUFLLENBQUMsRUFBRSxHQUFHLGVBQWUsU0FBU1Q7WUFDOUcsT0FBTyxJQUFJM0MsMkRBQVdBLENBQUNzRCxPQUFPLEdBQUlGLEtBQUssQ0FBQyxFQUFFLEtBQUssT0FBUVQsTUFBTWIsSUFBSTtRQUNyRTtRQUNBLGNBQWM7UUFDZHNCLFFBQVFULE1BQU1VLElBQUksQ0FBQ0QsS0FBSyxDQUFDekM7UUFDekIsSUFBSXlDLE9BQU87WUFDUCxJQUFJRSxPQUFPQyxTQUFTSCxLQUFLLENBQUMsRUFBRTtZQUM1QjdELCtEQUFjQSxDQUFDK0QsU0FBUyxLQUFLQSxRQUFRLElBQUksd0JBQXdCLFNBQVNYO1lBQzFFLE9BQU8sSUFBSTdDLG9FQUFlQSxDQUFDd0QsTUFBTVgsTUFBTWIsSUFBSTtRQUMvQztRQUNBdkMsK0RBQWNBLENBQUMsT0FBTyxnQkFBZ0IsUUFBUW9ELE1BQU1VLElBQUk7SUFDNUQ7SUFDQTs7Ozs7S0FLQyxHQUNERyxnQkFBZ0JDLEtBQUssRUFBRTtRQUNuQixNQUFNQyxTQUFTRCxNQUFNUixHQUFHLENBQUMsQ0FBQ0ksT0FBUyxJQUFJLENBQUMsQ0FBQ1gsUUFBUSxDQUFDdkMscURBQVNBLENBQUNxQyxJQUFJLENBQUNhO1FBQ2pFLE1BQU1NLFFBQVEsSUFBSXpELHdEQUFVQSxDQUFDd0QsUUFBUTtRQUNyQyxPQUFPQyxNQUFNQyxZQUFZO0lBQzdCO0lBQ0E7Ozs7S0FJQyxHQUNEQyxPQUFPSixLQUFLLEVBQUVLLE1BQU0sRUFBRTtRQUNsQnhFLG9FQUFtQkEsQ0FBQ3dFLE9BQU9wQyxNQUFNLEVBQUUrQixNQUFNL0IsTUFBTSxFQUFFO1FBQ2pELE1BQU1nQyxTQUFTRCxNQUFNUixHQUFHLENBQUMsQ0FBQ0ksT0FBUyxJQUFJLENBQUMsQ0FBQ1gsUUFBUSxDQUFDdkMscURBQVNBLENBQUNxQyxJQUFJLENBQUNhO1FBQ2pFLE1BQU1NLFFBQVMsSUFBSXpELHdEQUFVQSxDQUFDd0QsUUFBUTtRQUN0QyxNQUFNSyxTQUFTLElBQUl0RSw4REFBTUE7UUFDekJrRSxNQUFNRSxNQUFNLENBQUNFLFFBQVFEO1FBQ3JCLE9BQU9DLE9BQU81QyxJQUFJO0lBQ3RCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RTLE9BQU82QixLQUFLLEVBQUV0QyxJQUFJLEVBQUU2QyxLQUFLLEVBQUU7UUFDdkIsTUFBTU4sU0FBU0QsTUFBTVIsR0FBRyxDQUFDLENBQUNJLE9BQVMsSUFBSSxDQUFDLENBQUNYLFFBQVEsQ0FBQ3ZDLHFEQUFTQSxDQUFDcUMsSUFBSSxDQUFDYTtRQUNqRSxNQUFNTSxRQUFRLElBQUl6RCx3REFBVUEsQ0FBQ3dELFFBQVE7UUFDckMsT0FBT0MsTUFBTS9CLE1BQU0sQ0FBQyxJQUFJcEMsOERBQU1BLENBQUMyQixNQUFNNkMsT0FBT2pEO0lBQ2hEO0lBQ0EsT0FBT2tELHdCQUF3QkMsS0FBSyxFQUFFO1FBQ2xDM0UsK0RBQWNBLENBQUMsT0FBUTJFLFVBQVcsWUFBWTlCLE9BQU8rQixTQUFTLENBQUNELFFBQVEsc0NBQXNDLFNBQVNBO1FBQ3RIbkQsc0JBQXNCbUQ7SUFDMUI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT0Usa0JBQWtCO1FBQ3JCLElBQUl0RCxnQkFBZ0IsTUFBTTtZQUN0QkEsZUFBZSxJQUFJMkI7UUFDdkI7UUFDQSxPQUFPM0I7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSx3QkFBd0JDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUU7UUFDN0MsT0FBT0gsd0JBQXdCQyxRQUFRQyxJQUFJQyxNQUFNc0IsU0FBUzJCLGVBQWU7SUFDN0U7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYWJpLWNvZGVyLmpzP2ZkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgV2hlbiBzZW5kaW5nIHZhbHVlcyB0byBvciByZWNlaXZpbmcgdmFsdWVzIGZyb20gYSBbW0NvbnRyYWN0XV0sIHRoZVxuICogIGRhdGEgaXMgZ2VuZXJhbGx5IGVuY29kZWQgdXNpbmcgdGhlIFtBQkkgc3RhbmRhcmRdKGxpbmstc29sYy1hYmkpLlxuICpcbiAqICBUaGUgQWJpQ29kZXIgcHJvdmlkZXMgYSB1dGlsaXR5IHRvIGVuY29kZSB2YWx1ZXMgdG8gQUJJIGRhdGEgYW5kXG4gKiAgZGVjb2RlIHZhbHVlcyBmcm9tIEFCSSBkYXRhLlxuICpcbiAqICBNb3N0IG9mIHRoZSB0aW1lLCBkZXZlbG9wZXJzIHNob3VsZCBmYXZvdXIgdGhlIFtbQ29udHJhY3RdXSBjbGFzcyxcbiAqICB3aGljaCBmdXJ0aGVyIGFic3RyYWN0cyBhIGxvdCBvZiB0aGUgZmluZXIgZGV0YWlscyBvZiBBQkkgZGF0YS5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkFCSSBFbmNvZGluZ1xuICovXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudENvdW50LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzLmpzXCI7XG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5LmpzXCI7XG5pbXBvcnQgeyBCb29sZWFuQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYm9vbGVhbi5qc1wiO1xuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlcy5qc1wiO1xuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzLmpzXCI7XG5pbXBvcnQgeyBOdWxsQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVsbC5qc1wiO1xuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmcuanNcIjtcbmltcG9ydCB7IFR1cGxlQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvdHVwbGUuanNcIjtcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sXG5jb25zdCBQYW5pY1JlYXNvbnMgPSBuZXcgTWFwKCk7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDAsIFwiR0VORVJJQ19QQU5JQ1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMSwgXCJBU1NFUlRfRkFMU0VcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTEsIFwiT1ZFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTIsIFwiRElWSURFX0JZX1pFUk9cIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjEsIFwiRU5VTV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMiwgXCJCQURfU1RPUkFHRV9EQVRBXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMxLCBcIlNUQUNLX1VOREVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMiwgXCJBUlJBWV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg0MSwgXCJPVVRfT0ZfTUVNT1JZXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDUxLCBcIlVOSU5JVElBTElaRURfRlVOQ1RJT05fQ0FMTFwiKTtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xubGV0IGRlZmF1bHRDb2RlciA9IG51bGw7XG5sZXQgZGVmYXVsdE1heEluZmxhdGlvbiA9IDEwMjQ7XG5mdW5jdGlvbiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBhYmlDb2Rlcikge1xuICAgIGxldCBtZXNzYWdlID0gXCJtaXNzaW5nIHJldmVydCBkYXRhXCI7XG4gICAgbGV0IHJlYXNvbiA9IG51bGw7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IG51bGw7XG4gICAgbGV0IHJldmVydCA9IG51bGw7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiZXhlY3V0aW9uIHJldmVydGVkXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChubyBkYXRhIHByZXNlbnQ7IGxpa2VseSByZXF1aXJlKGZhbHNlKSBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgcmVhc29uID0gXCJyZXF1aXJlKGZhbHNlKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCAlIDMyICE9PSA0KSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBkYXRhIGxlbmd0aClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDA4YzM3OWEwXCIpIHtcbiAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVhc29uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke0pTT04uc3RyaW5naWZ5KHJlYXNvbil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIHN0cmluZyBkYXRhKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4NGU0ODdiNzFcIikge1xuICAgICAgICAgICAgLy8gUGFuaWModWludDI1NilcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IE51bWJlcihhYmlDb2Rlci5kZWNvZGUoW1widWludDI1NlwiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdKTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlBhbmljXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtjb2RlXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYFBhbmljIGR1ZSB0byAke1BhbmljUmVhc29ucy5nZXQoY29kZSkgfHwgXCJVTktOT1dOXCJ9KCR7Y29kZX0pYDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7cmVhc29ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHBhbmljIGNvZGUpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdG86ICh0eC50byA/IGdldEFkZHJlc3ModHgudG8pIDogbnVsbCksXG4gICAgICAgIGRhdGE6ICh0eC5kYXRhIHx8IFwiMHhcIilcbiAgICB9O1xuICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUVycm9yKG1lc3NhZ2UsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICBhY3Rpb24sIGRhdGEsIHJlYXNvbiwgdHJhbnNhY3Rpb24sIGludm9jYXRpb24sIHJldmVydFxuICAgIH0pO1xufVxuLyoqXG4gKiAgVGhlICoqQWJpQ29kZXIqKiBpcyBhIGxvdy1sZXZlbCBjbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jb2RpbmcgSmF2YVNjcmlwdFxuICogIHZhbHVlcyBpbnRvIGJpbmFyeSBkYXRhIGFuZCBkZWNvZGluZyBiaW5hcnkgZGF0YSBpbnRvIEphdmFTY3JpcHQgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xuICAgICNnZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0uaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29kZXIodGhpcy4jZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0uaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIocGFyYW0uY29tcG9uZW50cy5tYXAoKGMpID0+IHRoaXMuI2dldENvZGVyKGMpKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnl0ZXNbMC05XStcbiAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhIGBgdWludGBgIGlzIGJ5IGRlZmF1bHQgYGAwYGAgYW5kIGBgYm9vbGBgXG4gICAgICogIGlzIGJ5IGRlZmF1bHQgYGBmYWxzZWBgLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZSB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gQUJJIGRhdGEuXG4gICAgICpcbiAgICAgKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICAgICAqL1xuICAgIGVuY29kZSh0eXBlcywgdmFsdWVzKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWVzLmxlbmd0aCwgdHlwZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSAobmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIikpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSB0aGUgQUJJICUlZGF0YSUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVsb29zZSUlIGRlY29kaW5nIGlzIGVuYWJsZWQsIHRoZW4gc3RyaWN0IHBhZGRpbmcgaXNcbiAgICAgKiAgbm90IGVuZm9yY2VkLiBTb21lIG9sZGVyIHZlcnNpb25zIG9mIFNvbGlkaXR5IGluY29ycmVjdGx5XG4gICAgICogIHBhZGRlZCBldmVudCBkYXRhIGVtaXR0ZWQgZnJvbSBgYGV4dGVybmFsYGAgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKG5ldyBSZWFkZXIoZGF0YSwgbG9vc2UsIGRlZmF1bHRNYXhJbmZsYXRpb24pKTtcbiAgICB9XG4gICAgc3RhdGljIF9zZXREZWZhdWx0TWF4SW5mbGF0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcImludmFsaWQgZGVmYXVsdE1heEluZmxhdGlvbiBmYWN0b3JcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHRNYXhJbmZsYXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNoYXJlZCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBkZWZhdWx0IFtbQWJpQ29kZXJdXS5cbiAgICAgKlxuICAgICAqICBPbiB0aGUgZmlyc3QgY2FsbCwgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQgaW50ZXJuYWxseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdEFiaUNvZGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdENvZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1jb21wYXRpYmxlIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXV0gRXJyb3IgZm9yIHRoZSBnaXZlblxuICAgICAqICByZXN1bHQgJSVkYXRhJSUgZm9yIHRoZSBbW0NhbGxFeGNlcHRpb25BY3Rpb25dXSAlJWFjdGlvbiUlIGFnYWluc3RcbiAgICAgKiAgdGhlIFRyYW5zYWN0aW9uICUldHglJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0QXJndW1lbnRDb3VudCIsImFzc2VydEFyZ3VtZW50IiwiUmVhZGVyIiwiV3JpdGVyIiwiQWRkcmVzc0NvZGVyIiwiQXJyYXlDb2RlciIsIkJvb2xlYW5Db2RlciIsIkJ5dGVzQ29kZXIiLCJGaXhlZEJ5dGVzQ29kZXIiLCJOdWxsQ29kZXIiLCJOdW1iZXJDb2RlciIsIlN0cmluZ0NvZGVyIiwiVHVwbGVDb2RlciIsIlBhcmFtVHlwZSIsImdldEFkZHJlc3MiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJtYWtlRXJyb3IiLCJQYW5pY1JlYXNvbnMiLCJNYXAiLCJzZXQiLCJwYXJhbVR5cGVCeXRlcyIsIlJlZ0V4cCIsInBhcmFtVHlwZU51bWJlciIsImRlZmF1bHRDb2RlciIsImRlZmF1bHRNYXhJbmZsYXRpb24iLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImFjdGlvbiIsInR4IiwiZGF0YSIsImFiaUNvZGVyIiwibWVzc2FnZSIsInJlYXNvbiIsImludm9jYXRpb24iLCJyZXZlcnQiLCJieXRlcyIsImxlbmd0aCIsInNsaWNlIiwiZGVjb2RlIiwic2lnbmF0dXJlIiwibmFtZSIsImFyZ3MiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb2RlIiwiTnVtYmVyIiwiZ2V0IiwidHJhbnNhY3Rpb24iLCJ0byIsImZyb20iLCJBYmlDb2RlciIsImdldENvZGVyIiwicGFyYW0iLCJpc0FycmF5IiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiaXNUdXBsZSIsImNvbXBvbmVudHMiLCJtYXAiLCJjIiwiYmFzZVR5cGUiLCJtYXRjaCIsInR5cGUiLCJzaXplIiwicGFyc2VJbnQiLCJnZXREZWZhdWx0VmFsdWUiLCJ0eXBlcyIsImNvZGVycyIsImNvZGVyIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwidmFsdWVzIiwid3JpdGVyIiwibG9vc2UiLCJfc2V0RGVmYXVsdE1heEluZmxhdGlvbiIsInZhbHVlIiwiaXNJbnRlZ2VyIiwiZGVmYXVsdEFiaUNvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n * @_ignore:\n */ const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index)=>{\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index)=>{\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void this.#names;\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(...args) {\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray(deep) {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            Padding.slice(bytes.length % WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    constructor(name, type, localName, dynamic){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */ class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor(){\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)(this.#data);\n    }\n    get length() {\n        return this.#dataLength;\n    }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value)=>{\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */ class Reader {\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = maxInflation != null ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(this.#data);\n    }\n    get dataLength() {\n        return this.#data.length;\n    }\n    get consumed() {\n        return this.#offset;\n    }\n    get bytes() {\n        return new Uint8Array(this.#data);\n    }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n            offset: this.#offset,\n            length: count,\n            info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n} //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRStCO0FBQy9COztDQUVDLEdBQ00sTUFBTVUsV0FBVyxHQUFHO0FBQzNCLE1BQU1DLFVBQVUsSUFBSUMsV0FBV0Y7QUFDL0IscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxNQUFNRyxpQkFBaUI7SUFBQztDQUFPO0FBQy9CLE1BQU1DLFNBQVMsQ0FBQztBQUNoQixNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLFNBQVNDLFNBQVNDLE1BQU07SUFDcEIsT0FBT0gsWUFBWUksR0FBRyxDQUFDRDtBQUMzQjtBQUNBLFNBQVNFLFNBQVNGLE1BQU0sRUFBRUcsS0FBSztJQUMzQk4sWUFBWU8sR0FBRyxDQUFDSixRQUFRRztBQUM1QjtBQUNBLFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUMzQixNQUFNQyxVQUFVLElBQUlDLE1BQU0sQ0FBQyx1REFBdUQsRUFBRUgsS0FBSyxDQUFDO0lBQzFGRSxRQUFRRCxLQUFLLEdBQUdBO0lBQ2hCLE1BQU1DO0FBQ1Y7QUFDQSxTQUFTRSxTQUFTUCxLQUFLLEVBQUVRLEtBQUssRUFBRUMsSUFBSTtJQUNoQyxJQUFJVCxNQUFNVSxPQUFPLENBQUMsU0FBUyxHQUFHO1FBQzFCLE9BQU9GLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQztZQUNwQixJQUFJRCxnQkFBZ0JFLFFBQVE7Z0JBQ3hCLE9BQU9QLFNBQVNYLFNBQVNnQixPQUFPQSxNQUFNSDtZQUMxQztZQUNBLE9BQU9HO1FBQ1g7SUFDSjtJQUNBLE9BQU9aLE1BQU1lLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYixNQUFNVTtRQUM5QixJQUFJRCxPQUFPSixNQUFNUyxRQUFRLENBQUNkO1FBQzFCLElBQUksQ0FBRUEsQ0FBQUEsUUFBUWEsS0FBSSxHQUFJO1lBQ2xCLElBQUlQLFFBQVFHLGdCQUFnQkUsUUFBUTtn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R0FBR3JFLFFBQVEsQ0FBQyxDQUFDc0U7UUFDekMsSUFBSSxDQUFDLENBQUNKLGtCQUFrQixDQUFDbEU7UUFDekIsSUFBSSxDQUFDLENBQUMyQyxNQUFNLElBQUlGLE1BQU16QyxNQUFNO1FBQzVCLG9EQUFvRDtRQUNwRCxPQUFPeUMsTUFBTTNDLEtBQUssQ0FBQyxHQUFHRTtJQUMxQjtJQUNBLHdCQUF3QjtJQUN4QjZFLFlBQVk7UUFDUixPQUFPcEgseURBQVFBLENBQUMsSUFBSSxDQUFDbUgsU0FBUyxDQUFDL0c7SUFDbkM7SUFDQWlILFlBQVk7UUFDUixPQUFPcEgseURBQVFBLENBQUMsSUFBSSxDQUFDa0gsU0FBUyxDQUFDL0c7SUFDbkM7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzP2NlZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgY29uY2F0LCBnZXRCeXRlc0NvcHksIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCB0b0JpZ0ludCwgdG9OdW1iZXIsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnRcbi8qLCBpc0Vycm9yKi9cbiB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmRTaXplID0gMzI7XG5jb25zdCBQYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCByZXN1bHROYW1lcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXROYW1lcyhyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0TmFtZXMuZ2V0KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBzZXROYW1lcyhyZXN1bHQsIG5hbWVzKSB7XG4gICAgcmVzdWx0TmFtZXMuc2V0KHJlc3VsdCwgbmFtZXMpO1xufVxuZnVuY3Rpb24gdGhyb3dFcnJvcihuYW1lLCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XG4gICAgd3JhcHBlZC5lcnJvciA9IGVycm9yO1xuICAgIHRocm93IHdyYXBwZWQ7XG59XG5mdW5jdGlvbiB0b09iamVjdChuYW1lcywgaXRlbXMsIGRlZXApIHtcbiAgICBpZiAobmFtZXMuaW5kZXhPZihudWxsKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zLmdldFZhbHVlKG5hbWUpO1xuICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bVtuYW1lXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5leHBvcnQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgIC8vIE5vIGxvbmdlciB1c2VkOyBidXQgY2Fubm90IGJlIHJlbW92ZWQgYXMgaXQgd2lsbCByZW1vdmUgdGhlXG4gICAgLy8gI3ByaXZhdGUgZmllbGQgZnJvbSB0aGUgLmQudHMgd2hpY2ggbWF5IGJyZWFrIGJhY2t3YXJkc1xuICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAjbmFtZXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAvLyBUbyBwcm9wZXJseSBzdWItY2xhc3MgQXJyYXkgc28gdGhlIG90aGVyIGJ1aWx0LWluXG4gICAgICAgIC8vIGZ1bmN0aW9ucyB3b3JrLCB0aGUgY29uc3RydWN0b3IgaGFzIHRvIGJlaGF2ZSBmYWlybHlcbiAgICAgICAgLy8gd2VsbC4gU28sIGluIHRoZSBldmVudCB3ZSBhcmUgY3JlYXRlZCB2aWEgZnJvbUl0ZW1zKClcbiAgICAgICAgLy8gd2UgYnVpbGQgdGhlIHJlYWQtb25seSBSZXN1bHQgb2JqZWN0IHdlIHdhbnQsIGJ1dCBvblxuICAgICAgICAvLyBhbnkgb3RoZXIgaW5wdXQsIHdlIHVzZSB0aGUgZGVmYXVsdCBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBjb25zdHJ1Y3RvcihndWFyZDogYW55LCBpdGVtczogQXJyYXk8YW55Piwga2V5cz86IEFycmF5PG51bGwgfCBzdHJpbmc+KTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSBhcmdzWzBdO1xuICAgICAgICBsZXQgaXRlbXMgPSBhcmdzWzFdO1xuICAgICAgICBsZXQgbmFtZXMgPSAoYXJnc1syXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgbGV0IHdyYXAgPSB0cnVlO1xuICAgICAgICBpZiAoZ3VhcmQgIT09IF9ndWFyZCkge1xuICAgICAgICAgICAgaXRlbXMgPSBhcmdzO1xuICAgICAgICAgICAgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHdyYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW4ndCBqdXN0IHBhc3MgaW4gLi4uaXRlbXMgc2luY2UgYW4gYXJyYXkgb2YgbGVuZ3RoIDFcbiAgICAgICAgLy8gaXMgYSBzcGVjaWFsIGNhc2UgaW4gdGhlIHN1cGVyLlxuICAgICAgICBzdXBlcihpdGVtcy5sZW5ndGgpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4geyB0aGlzW2luZGV4XSA9IGl0ZW07IH0pO1xuICAgICAgICAvLyBGaW5kIGFsbCB1bmlxdWUga2V5c1xuICAgICAgICBjb25zdCBuYW1lQ291bnRzID0gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhY2N1bS5zZXQobmFtZSwgKGFjY3VtLmdldChuYW1lKSB8fCAwKSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCAobmV3IE1hcCgpKSk7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkga2V5IHRoYXRzIG5vdCB1bmlxdWVcbiAgICAgICAgc2V0TmFtZXModGhpcywgT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIC8vIER1bW15IG9wZXJhdGlvbnMgdG8gcHJldmVudCBUeXBlU2NyaXB0IGZyb20gY29tcGxhaW5pbmdcbiAgICAgICAgdGhpcy4jbmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI25hbWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZvaWQgKHRoaXMuI25hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHdyYXBwZWQgUmVzdWx0IGlzIGltbXV0YWJsZVxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICAvLyBQcm94eSBpbmRpY2VzIGFuZCBuYW1lcyBzbyB3ZSBjYW4gdHJhcCBkZWZlcnJlZCBlcnJvcnNcbiAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByZXN1bHQgcmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25zIHdvcmsgd2l0aCBwcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSNub19wcml2YXRlX3Byb3BlcnR5X2ZvcndhcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBuYW1lIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldE5hbWVzKHByb3h5LCBnZXROYW1lcyh0aGlzKSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhIG5vcm1hbCBBcnJheS4gSWYgJSVkZWVwJSUsIGFueSBjaGlsZHJlblxuICAgICAqICB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc28gY29udmVydGVkIHRvIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KGRlZXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnRvQXJyYXkoZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXG4gICAgICogICUlZGVlcCUlLCBhbnkgY2hpbGRyZW4gd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvXG4gICAgICogIGNvbnZlcnRlZCB0byBhbiBPYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdChkZWVwKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUgIT0gbnVsbCwgYHZhbHVlIGF0IGluZGV4ICR7aW5kZXh9IHVubmFtZWRgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvT2JqZWN0KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9PYmplY3QobmFtZXMsIHRoaXMsIGRlZXApO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBtYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGZvciAlJW5hbWUlJS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcbiAgICAgKiAgYSBtZXRob2Qgb24gYSBbW1Jlc3VsdF1dIG9yIGl0cyBzdXBlcmNsYXNzIEFycmF5LCBvciBhbnlcbiAgICAgKiAgSmF2YVNjcmlwdCBrZXl3b3JkLCB0aGlzIGVuc3VyZXMgYWxsIG5hbWVkIHZhbHVlcyBhcmUgc3RpbGxcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhbHVlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROYW1lcyh0aGlzKS5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbUmVzdWx0XV0gZm9yICUlaXRlbXMlJSB3aXRoIGVhY2ggZW50cnlcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JdGVtcyhpdGVtcywga2V5cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gV29yZFNpemUpIHtcbiAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgLy8gVGhlIGNvZGVyIG5hbWU6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlLCBhcnJheSwgZXRjLlxuICAgIG5hbWU7XG4gICAgLy8gVGhlIGZ1bGx5IGV4cGFuZGVkIHR5cGUsIGluY2x1ZGluZyBjb21wb3NpdGUgdHlwZXM6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlKGFkZHJlc3MsYnl0ZXMpLCB1aW50MjU2WzNdWzRdW10sICBldGMuXG4gICAgdHlwZTtcbiAgICAvLyBUaGUgbG9jYWxOYW1lIGJvdW5kIGluIHRoZSBzaWduYXR1cmUsIGluIHRoaXMgZXhhbXBsZSBpdCBpcyBcImJhelwiOlxuICAgIC8vICAgLSB0dXBsZShhZGRyZXNzIGZvbywgdWludCBiYXIpIGJhelxuICAgIGxvY2FsTmFtZTtcbiAgICAvLyBXaGV0aGVyIHRoaXMgdHlwZSBpcyBkeW5hbWljOlxuICAgIC8vICAtIER5bmFtaWM6IGJ5dGVzLCBzdHJpbmcsIGFkZHJlc3NbXSwgdHVwbGUoYm9vbGVhbltdKSwgZXRjLlxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcbiAgICBkeW5hbWljO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRCeXRlc0NvcHkod3JpdGVyLmRhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbTsgcGFkIG9uIHRoZSByaWdodCB0byAqbmVhcmVzdCogV29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICAjYnl0ZXNSZWFkO1xuICAgICNwYXJlbnQ7XG4gICAgI21heEluZmxhdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFsbG93TG9vc2U6ICEhYWxsb3dMb29zZSB9KTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4SW5mbGF0aW9uID0gKG1heEluZmxhdGlvbiAhPSBudWxsKSA/IG1heEluZmxhdGlvbiA6IDEwMjQ7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudC4jaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNieXRlc1JlYWQgKz0gY291bnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBleGNlc3NpdmUgaW5mbGF0aW9uIChzZWU6ICM0NTM3KVxuICAgICAgICBhc3NlcnQodGhpcy4jbWF4SW5mbGF0aW9uIDwgMSB8fCB0aGlzLiNieXRlc1JlYWQgPD0gdGhpcy4jbWF4SW5mbGF0aW9uICogdGhpcy5kYXRhTGVuZ3RoLCBgY29tcHJlc3NlZCBBQkkgZGF0YSBleGNlZWRzIGluZmxhdGlvbiByYXRpbyBvZiAke3RoaXMuI21heEluZmxhdGlvbn0gKCBzZWU6IGh0dHBzOi9cXC9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvaXNzdWVzLzQ1MzcgKWAsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksIG9mZnNldDogdGhpcy4jb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBjb3VudCwgaW5mbzoge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGg6IHRoaXMuZGF0YUxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy5hbGxvd0xvb3NlLCB0aGlzLiNtYXhJbmZsYXRpb24pO1xuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnSW50KHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJjb25jYXQiLCJnZXRCeXRlc0NvcHkiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwidG9CaWdJbnQiLCJ0b051bWJlciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiV29yZFNpemUiLCJQYWRkaW5nIiwiVWludDhBcnJheSIsInBhc3NQcm9wZXJ0aWVzIiwiX2d1YXJkIiwicmVzdWx0TmFtZXMiLCJXZWFrTWFwIiwiZ2V0TmFtZXMiLCJyZXN1bHQiLCJnZXQiLCJzZXROYW1lcyIsIm5hbWVzIiwic2V0IiwidGhyb3dFcnJvciIsIm5hbWUiLCJlcnJvciIsIndyYXBwZWQiLCJFcnJvciIsInRvT2JqZWN0IiwiaXRlbXMiLCJkZWVwIiwiaW5kZXhPZiIsIm1hcCIsIml0ZW0iLCJpbmRleCIsIlJlc3VsdCIsInJlZHVjZSIsImFjY3VtIiwiZ2V0VmFsdWUiLCJBcnJheSIsImNvbnN0cnVjdG9yIiwiYXJncyIsImd1YXJkIiwic2xpY2UiLCJ3cmFwIiwibGVuZ3RoIiwiZm9yRWFjaCIsIm5hbWVDb3VudHMiLCJNYXAiLCJPYmplY3QiLCJmcmVlemUiLCJwcm94eSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiUmVmbGVjdCIsInZhbHVlIiwiRnVuY3Rpb24iLCJhcHBseSIsInRvQXJyYXkiLCJwdXNoIiwib3BlcmF0aW9uIiwic3RhcnQiLCJlbmQiLCJfbmFtZXMiLCJpIiwiZmlsdGVyIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiY2FsbCIsInVuZGVmaW5lZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmcm9tSXRlbXMiLCJrZXlzIiwiY2hlY2tSZXN1bHRFcnJvcnMiLCJlcnJvcnMiLCJjaGVja0Vycm9ycyIsInBhdGgiLCJvYmplY3QiLCJpc0FycmF5Iiwia2V5IiwiY2hpbGRQYXRoIiwiYnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJDb2RlciIsInR5cGUiLCJsb2NhbE5hbWUiLCJkeW5hbWljIiwiX3Rocm93RXJyb3IiLCJtZXNzYWdlIiwiV3JpdGVyIiwiZGF0YSIsImRhdGFMZW5ndGgiLCJ3cml0ZURhdGEiLCJhcHBlbmRXcml0ZXIiLCJ3cml0ZXIiLCJ3cml0ZUJ5dGVzIiwicGFkZGluZ09mZnNldCIsIndyaXRlVmFsdWUiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwiUmVhZGVyIiwiYnl0ZXNSZWFkIiwicGFyZW50IiwibWF4SW5mbGF0aW9uIiwiYWxsb3dMb29zZSIsImNvbnN1bWVkIiwiaW5jcmVtZW50Qnl0ZXNSZWFkIiwiY291bnQiLCJpbmZvIiwicGVla0J5dGVzIiwibG9vc2UiLCJhbGlnbmVkTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJzdWJSZWFkZXIiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiLCJyZWFkVmFsdWUiLCJyZWFkSW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ0w7QUFDWDtBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUkscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsV0FBVyxXQUFXQSxXQUFXO0lBQzNDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsSUFBSUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN0QyxJQUFJO1lBQ0FDLFFBQVFYLDZEQUFVQSxDQUFDVztRQUN2QixFQUNBLE9BQU9FLE9BQU87WUFDVixPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxNQUFNRSxPQUFPLEVBQUVMO1FBQzNDO1FBQ0EsT0FBT0QsT0FBT08sVUFBVSxDQUFDTDtJQUM3QjtJQUNBTSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPbEIsNkRBQVVBLENBQUNDLHdEQUFPQSxDQUFDaUIsT0FBT0MsU0FBUyxJQUFJO0lBQ2xEO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzP2NhODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi8uLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b0JlSGV4IH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGhzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRvQmVIZXgocmVhZGVyLnJlYWRWYWx1ZSgpLCAyMCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJ0b0JlSGV4IiwiVHlwZWQiLCJDb2RlciIsIkFkZHJlc3NDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsImVycm9yIiwiX3Rocm93RXJyb3IiLCJtZXNzYWdlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7Ozs7Q0FJQyxHQUNNLE1BQU1DLHVCQUF1QkQscURBQUtBO0lBRXJDRSxZQUFZQyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBLE1BQU1DLElBQUksRUFBRUQsTUFBTUUsSUFBSSxFQUFFLEtBQUtGLE1BQU1HLE9BQU87UUFDaEQsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FJLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxZQUFZO0lBQ2xDO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDUCxLQUFLLENBQUNLLE1BQU0sQ0FBQ0MsUUFBUUM7SUFDckM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1EsTUFBTSxDQUFDQztJQUM3QjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzP2Q0YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVyIiwiQW5vbnltb3VzQ29kZXIiLCJjb25zdHJ1Y3RvciIsImNvZGVyIiwibmFtZSIsInR5cGUiLCJkeW5hbWljIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anonymous.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */ class ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_4__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RztBQUMxRTtBQUNrQztBQUN0QjtBQUNoRDs7Q0FFQyxHQUNNLFNBQVNXLEtBQUtDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNO0lBQ3ZDLElBQUlDLGNBQWMsRUFBRTtJQUNwQixJQUFJQyxNQUFNQyxPQUFPLENBQUNILFNBQVM7UUFDdkJDLGNBQWNEO0lBQ2xCLE9BQ0ssSUFBSUEsVUFBVSxPQUFRQSxXQUFZLFVBQVU7UUFDN0MsSUFBSUksU0FBUyxDQUFDO1FBQ2RILGNBQWNGLE9BQU9NLEdBQUcsQ0FBQyxDQUFDQztZQUN0QixNQUFNQyxPQUFPRCxNQUFNRSxTQUFTO1lBQzVCcEIsdURBQU1BLENBQUNtQixNQUFNLHlEQUF5RCxvQkFBb0I7Z0JBQUVFLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVKO2dCQUFNO2dCQUFHSyxPQUFPWDtZQUFPO1lBQy9JWix1REFBTUEsQ0FBQyxDQUFDZ0IsTUFBTSxDQUFDRyxLQUFLLEVBQUUsMkRBQTJELG9CQUFvQjtnQkFBRUUsVUFBVTtnQkFBVUMsTUFBTTtvQkFBRUo7Z0JBQU07Z0JBQUdLLE9BQU9YO1lBQU87WUFDMUpJLE1BQU0sQ0FBQ0csS0FBSyxHQUFHO1lBQ2YsT0FBT1AsTUFBTSxDQUFDTyxLQUFLO1FBQ3ZCO0lBQ0osT0FDSztRQUNEbEIsK0RBQWNBLENBQUMsT0FBTyx1QkFBdUIsU0FBU1c7SUFDMUQ7SUFDQVgsK0RBQWNBLENBQUNVLE9BQU9hLE1BQU0sS0FBS1gsWUFBWVcsTUFBTSxFQUFFLCtCQUErQixTQUFTWjtJQUM3RixJQUFJYSxlQUFlLElBQUlsQixzREFBTUE7SUFDN0IsSUFBSW1CLGdCQUFnQixJQUFJbkIsc0RBQU1BO0lBQzlCLElBQUlvQixjQUFjLEVBQUU7SUFDcEJoQixPQUFPaUIsT0FBTyxDQUFDLENBQUNWLE9BQU9XO1FBQ25CLElBQUlOLFFBQVFWLFdBQVcsQ0FBQ2dCLE1BQU07UUFDOUIsSUFBSVgsTUFBTVksT0FBTyxFQUFFO1lBQ2Ysc0RBQXNEO1lBQ3RELElBQUlDLGdCQUFnQkwsY0FBY0YsTUFBTTtZQUN4QyxrREFBa0Q7WUFDbEROLE1BQU1jLE1BQU0sQ0FBQ04sZUFBZUg7WUFDNUIsMERBQTBEO1lBQzFELElBQUlVLGFBQWFSLGFBQWFTLG1CQUFtQjtZQUNqRFAsWUFBWVEsSUFBSSxDQUFDLENBQUNDO2dCQUNkSCxXQUFXRyxhQUFhTDtZQUM1QjtRQUNKLE9BQ0s7WUFDRGIsTUFBTWMsTUFBTSxDQUFDUCxjQUFjRjtRQUMvQjtJQUNKO0lBQ0EsdUVBQXVFO0lBQ3ZFSSxZQUFZQyxPQUFPLENBQUMsQ0FBQ1M7UUFBV0EsS0FBS1osYUFBYUQsTUFBTTtJQUFHO0lBQzNELElBQUlBLFNBQVNkLE9BQU80QixZQUFZLENBQUNiO0lBQ2pDRCxVQUFVZCxPQUFPNEIsWUFBWSxDQUFDWjtJQUM5QixPQUFPRjtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTZSxPQUFPQyxNQUFNLEVBQUU3QixNQUFNO0lBQ2pDLElBQUlDLFNBQVMsRUFBRTtJQUNmLElBQUk2QixPQUFPLEVBQUU7SUFDYixpQ0FBaUM7SUFDakMsSUFBSUMsYUFBYUYsT0FBT0csU0FBUyxDQUFDO0lBQ2xDaEMsT0FBT2lCLE9BQU8sQ0FBQyxDQUFDVjtRQUNaLElBQUlLLFFBQVE7UUFDWixJQUFJTCxNQUFNWSxPQUFPLEVBQUU7WUFDZixJQUFJYyxTQUFTSixPQUFPSyxTQUFTO1lBQzdCLElBQUlDLGVBQWVKLFdBQVdDLFNBQVMsQ0FBQ0M7WUFDeEMsSUFBSTtnQkFDQXJCLFFBQVFMLE1BQU02QixNQUFNLENBQUNEO1lBQ3pCLEVBQ0EsT0FBT0UsT0FBTztnQkFDViwyQkFBMkI7Z0JBQzNCLElBQUlqRCx3REFBT0EsQ0FBQ2lELE9BQU8sbUJBQW1CO29CQUNsQyxNQUFNQTtnQkFDVjtnQkFDQXpCLFFBQVF5QjtnQkFDUnpCLE1BQU0wQixRQUFRLEdBQUcvQixNQUFNQyxJQUFJO2dCQUMzQkksTUFBTUosSUFBSSxHQUFHRCxNQUFNRSxTQUFTO2dCQUM1QkcsTUFBTTJCLElBQUksR0FBR2hDLE1BQU1nQyxJQUFJO1lBQzNCO1FBQ0osT0FDSztZQUNELElBQUk7Z0JBQ0EzQixRQUFRTCxNQUFNNkIsTUFBTSxDQUFDUDtZQUN6QixFQUNBLE9BQU9RLE9BQU87Z0JBQ1YsMkJBQTJCO2dCQUMzQixJQUFJakQsd0RBQU9BLENBQUNpRCxPQUFPLG1CQUFtQjtvQkFDbEMsTUFBTUE7Z0JBQ1Y7Z0JBQ0F6QixRQUFReUI7Z0JBQ1J6QixNQUFNMEIsUUFBUSxHQUFHL0IsTUFBTUMsSUFBSTtnQkFDM0JJLE1BQU1KLElBQUksR0FBR0QsTUFBTUUsU0FBUztnQkFDNUJHLE1BQU0yQixJQUFJLEdBQUdoQyxNQUFNZ0MsSUFBSTtZQUMzQjtRQUNKO1FBQ0EsSUFBSTNCLFNBQVM0QixXQUFXO1lBQ3BCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBeEMsT0FBT3VCLElBQUksQ0FBQ1o7UUFDWmtCLEtBQUtOLElBQUksQ0FBQ2pCLE1BQU1FLFNBQVMsSUFBSTtJQUNqQztJQUNBLE9BQU9mLHNEQUFNQSxDQUFDZ0QsU0FBUyxDQUFDekMsUUFBUTZCO0FBQ3BDO0FBQ0E7O0NBRUMsR0FDTSxNQUFNYSxtQkFBbUJsRCxxREFBS0E7SUFHakNtRCxZQUFZckMsS0FBSyxFQUFFTSxNQUFNLEVBQUVKLFNBQVMsQ0FBRTtRQUNsQyxNQUFNOEIsT0FBUWhDLE1BQU1nQyxJQUFJLEdBQUcsTUFBTzFCLENBQUFBLFVBQVUsSUFBSUEsU0FBUyxFQUFDLElBQUs7UUFDL0QsTUFBTU0sVUFBV04sV0FBVyxDQUFDLEtBQUtOLE1BQU1ZLE9BQU87UUFDL0MsS0FBSyxDQUFDLFNBQVNvQixNQUFNOUIsV0FBV1U7UUFDaENoQyxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVvQjtZQUFPTTtRQUFPO0lBQzNDO0lBQ0FnQyxlQUFlO1FBQ1gsK0VBQStFO1FBQy9FLE1BQU1DLGVBQWUsSUFBSSxDQUFDdkMsS0FBSyxDQUFDc0MsWUFBWTtRQUM1QyxNQUFNRSxTQUFTLEVBQUU7UUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDbkMsTUFBTSxFQUFFbUMsSUFBSztZQUNsQ0QsT0FBT3ZCLElBQUksQ0FBQ3NCO1FBQ2hCO1FBQ0EsT0FBT0M7SUFDWDtJQUNBMUIsT0FBT3RCLE1BQU0sRUFBRWtELE1BQU0sRUFBRTtRQUNuQixNQUFNckMsUUFBUXBCLDRDQUFLQSxDQUFDMEQsV0FBVyxDQUFDRCxRQUFRO1FBQ3hDLElBQUksQ0FBQzlDLE1BQU1DLE9BQU8sQ0FBQ1EsUUFBUTtZQUN2QixJQUFJLENBQUN1QyxXQUFXLENBQUMsd0JBQXdCdkM7UUFDN0M7UUFDQSxJQUFJd0MsUUFBUSxJQUFJLENBQUN2QyxNQUFNO1FBQ3ZCLElBQUl1QyxVQUFVLENBQUMsR0FBRztZQUNkQSxRQUFReEMsTUFBTUMsTUFBTTtZQUNwQmQsT0FBT3NELFVBQVUsQ0FBQ3pDLE1BQU1DLE1BQU07UUFDbEM7UUFDQXRCLG9FQUFtQkEsQ0FBQ3FCLE1BQU1DLE1BQU0sRUFBRXVDLE9BQU8sZ0JBQWlCLEtBQUksQ0FBQzNDLFNBQVMsR0FBSSxNQUFNLElBQUksQ0FBQ0EsU0FBUyxHQUFJLEVBQUM7UUFDckcsSUFBSVQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJZ0QsSUFBSSxHQUFHQSxJQUFJcEMsTUFBTUMsTUFBTSxFQUFFbUMsSUFBSztZQUNuQ2hELE9BQU93QixJQUFJLENBQUMsSUFBSSxDQUFDakIsS0FBSztRQUMxQjtRQUNBLE9BQU9ULEtBQUtDLFFBQVFDLFFBQVFZO0lBQ2hDO0lBQ0F3QixPQUFPUCxNQUFNLEVBQUU7UUFDWCxJQUFJdUIsUUFBUSxJQUFJLENBQUN2QyxNQUFNO1FBQ3ZCLElBQUl1QyxVQUFVLENBQUMsR0FBRztZQUNkQSxRQUFRdkIsT0FBT0ssU0FBUztZQUN4QixzREFBc0Q7WUFDdEQsd0RBQXdEO1lBQ3hELHlEQUF5RDtZQUN6RCxzREFBc0Q7WUFDdEQsNERBQTREO1lBQzVEN0MsdURBQU1BLENBQUMrRCxRQUFRekQsd0RBQVFBLElBQUlrQyxPQUFPeUIsVUFBVSxFQUFFLDRCQUE0QixrQkFBa0I7Z0JBQUVDLFFBQVExQixPQUFPMkIsS0FBSztnQkFBRXZCLFFBQVFtQixRQUFRekQsd0RBQVFBO2dCQUFFa0IsUUFBUWdCLE9BQU95QixVQUFVO1lBQUM7UUFDNUs7UUFDQSxJQUFJdEQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJZ0QsSUFBSSxHQUFHQSxJQUFJSSxPQUFPSixJQUFLO1lBQzVCaEQsT0FBT3dCLElBQUksQ0FBQyxJQUFJM0IseURBQWNBLENBQUMsSUFBSSxDQUFDVSxLQUFLO1FBQzdDO1FBQ0EsT0FBT3FCLE9BQU9DLFFBQVE3QjtJQUMxQjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanM/YThiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFJlc3VsdCwgV29yZFNpemUsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIGFzc2VydCghdW5pcXVlW25hbWVdLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGFzc2VydChjb3VudCAqIFdvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBXb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImlzRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJUeXBlZCIsIkNvZGVyIiwiUmVzdWx0IiwiV29yZFNpemUiLCJXcml0ZXIiLCJBbm9ueW1vdXNDb2RlciIsInBhY2siLCJ3cml0ZXIiLCJjb2RlcnMiLCJ2YWx1ZXMiLCJhcnJheVZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInVuaXF1ZSIsIm1hcCIsImNvZGVyIiwibmFtZSIsImxvY2FsTmFtZSIsImFyZ3VtZW50IiwiaW5mbyIsInZhbHVlIiwibGVuZ3RoIiwic3RhdGljV3JpdGVyIiwiZHluYW1pY1dyaXRlciIsInVwZGF0ZUZ1bmNzIiwiZm9yRWFjaCIsImluZGV4IiwiZHluYW1pYyIsImR5bmFtaWNPZmZzZXQiLCJlbmNvZGUiLCJ1cGRhdGVGdW5jIiwid3JpdGVVcGRhdGFibGVWYWx1ZSIsInB1c2giLCJiYXNlT2Zmc2V0IiwiZnVuYyIsImFwcGVuZFdyaXRlciIsInVucGFjayIsInJlYWRlciIsImtleXMiLCJiYXNlUmVhZGVyIiwic3ViUmVhZGVyIiwib2Zmc2V0IiwicmVhZEluZGV4Iiwib2Zmc2V0UmVhZGVyIiwiZGVjb2RlIiwiZXJyb3IiLCJiYXNlVHlwZSIsInR5cGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsImZyb21JdGVtcyIsIkFycmF5Q29kZXIiLCJjb25zdHJ1Y3RvciIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGlsZCIsInJlc3VsdCIsImkiLCJfdmFsdWUiLCJkZXJlZmVyZW5jZSIsIl90aHJvd0Vycm9yIiwiY291bnQiLCJ3cml0ZVZhbHVlIiwiZGF0YUxlbmd0aCIsImJ1ZmZlciIsImJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUUscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxRQUFRQSxXQUFXO0lBQ3JDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN4QyxPQUFPRCxPQUFPSSxVQUFVLENBQUNGLFFBQVEsSUFBSTtJQUN6QztJQUNBRyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQ0EsT0FBT0MsU0FBUztJQUM3QjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcz84NmMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiXSwibmFtZXMiOlsiVHlwZWQiLCJDb2RlciIsIkJvb2xlYW5Db2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsIndyaXRlVmFsdWUiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkVmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2pCO0FBQzVDOztDQUVDLEdBQ00sTUFBTUcsMEJBQTBCRCxxREFBS0E7SUFDeENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsTUFBTUEsTUFBTUMsV0FBVztJQUNqQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCQSxRQUFRViw2REFBWUEsQ0FBQ1U7UUFDckIsSUFBSUMsU0FBU0YsT0FBT0csVUFBVSxDQUFDRixNQUFNQyxNQUFNO1FBQzNDQSxVQUFVRixPQUFPSSxVQUFVLENBQUNIO1FBQzVCLE9BQU9DO0lBQ1g7SUFDQUcsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT0EsT0FBT0MsU0FBUyxDQUFDRCxPQUFPRSxTQUFTLElBQUk7SUFDaEQ7QUFDSjtBQUNBOztDQUVDLEdBQ00sTUFBTUMsbUJBQW1CZjtJQUM1QkMsWUFBWUUsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxTQUFTQTtJQUNuQjtJQUNBUSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPZCx3REFBT0EsQ0FBQyxLQUFLLENBQUNhLE9BQU9DO0lBQ2hDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcz9mMzQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsIkNvZGVyIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImxlbmd0aCIsIndyaXRlVmFsdWUiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIiwicmVhZEluZGV4IiwiQnl0ZXNDb2RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */ class FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(reader.readBytes(this.size));\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUMzQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUssd0JBQXdCRCxxREFBS0E7SUFFdENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLElBQUlDLE9BQU8sVUFBVUMsT0FBT0g7UUFDNUIsS0FBSyxDQUFDRSxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCUixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVPO1FBQUssR0FBRztZQUFFQSxNQUFNO1FBQVM7SUFDdEQ7SUFDQUksZUFBZTtRQUNYLE9BQU8scUVBQXVFQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQ0wsSUFBSSxHQUFHO0lBQy9HO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLE9BQU9mLDZEQUFZQSxDQUFDRSw0Q0FBS0EsQ0FBQ2MsV0FBVyxDQUFDRixRQUFRLElBQUksQ0FBQ0csSUFBSTtRQUMzRCxJQUFJRixLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDWixJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDYSxXQUFXLENBQUMseUJBQXlCTDtRQUM5QztRQUNBLE9BQU9ELE9BQU9PLFVBQVUsQ0FBQ0w7SUFDN0I7SUFDQU0sT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT3JCLHdEQUFPQSxDQUFDcUIsT0FBT0MsU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7SUFDN0M7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzPzZlZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplIH0sIHsgc2l6ZTogXCJudW1iZXJcIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzQ29weShUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsIlR5cGVkIiwiQ29kZXIiLCJGaXhlZEJ5dGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJsb2NhbE5hbWUiLCJuYW1lIiwiU3RyaW5nIiwiZGVmYXVsdFZhbHVlIiwic3Vic3RyaW5nIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwiZGF0YSIsImRlcmVmZXJlbmNlIiwidHlwZSIsImxlbmd0aCIsIl90aHJvd0Vycm9yIiwid3JpdGVCeXRlcyIsImRlY29kZSIsInJlYWRlciIsInJlYWRCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDLE1BQU1DLFFBQVEsSUFBSUMsV0FBVyxFQUFFO0FBQy9COztDQUVDLEdBQ00sTUFBTUMsa0JBQWtCSCxxREFBS0E7SUFDaENJLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxJQUFJQSxXQUFXO0lBQ2pDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7UUFDbEIsSUFBSUEsU0FBUyxNQUFNO1lBQ2YsSUFBSSxDQUFDQyxXQUFXLENBQUMsWUFBWUQ7UUFDakM7UUFDQSxPQUFPRCxPQUFPRyxVQUFVLENBQUNWO0lBQzdCO0lBQ0FXLE9BQU9DLE1BQU0sRUFBRTtRQUNYQSxPQUFPQyxTQUFTLENBQUM7UUFDakIsT0FBTztJQUNYO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzP2IyMTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJFbXB0eSIsIlVpbnQ4QXJyYXkiLCJOdWxsQ29kZXIiLCJjb25zdHJ1Y3RvciIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        } else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkY7QUFDdkQ7QUFDa0I7QUFDdEQsTUFBTVEsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLGlCQUFpQkYsT0FBTztBQUM5Qjs7Q0FFQyxHQUNNLE1BQU1HLG9CQUFvQk4scURBQUtBO0lBR2xDTyxZQUFZQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQ2pDLE1BQU1DLE9BQVEsQ0FBQ0YsU0FBUyxRQUFRLE1BQUssSUFBTUQsT0FBTztRQUNsRCxLQUFLLENBQUNHLE1BQU1BLE1BQU1ELFdBQVc7UUFDN0JoQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVjO1lBQU1DO1FBQU8sR0FBRztZQUFFRCxNQUFNO1lBQVVDLFFBQVE7UUFBVTtJQUNqRjtJQUNBRyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLFFBQVFwQiwwREFBU0EsQ0FBQ0csNENBQUtBLENBQUNrQixXQUFXLENBQUNGLFFBQVEsSUFBSSxDQUFDRyxJQUFJO1FBQ3pELHFDQUFxQztRQUNyQyxJQUFJQyxlQUFldEIscURBQUlBLENBQUNRLGdCQUFnQkosd0RBQVFBLEdBQUc7UUFDbkQsSUFBSSxJQUFJLENBQUNRLE1BQU0sRUFBRTtZQUNiLElBQUlXLFNBQVN2QixxREFBSUEsQ0FBQ3NCLGNBQWMsSUFBSyxDQUFDWCxJQUFJLEdBQUcsSUFBSztZQUNsRCxJQUFJUSxRQUFRSSxVQUFVSixRQUFRLENBQUVJLENBQUFBLFNBQVNoQixJQUFHLEdBQUk7Z0JBQzVDLElBQUksQ0FBQ2lCLFdBQVcsQ0FBQyx1QkFBdUJOO1lBQzVDO1lBQ0FDLFFBQVFsQix1REFBTUEsQ0FBQ2tCLE9BQU8sSUFBSWYsd0RBQVFBO1FBQ3RDLE9BQ0ssSUFBSWUsUUFBUWQsUUFBUWMsUUFBUW5CLHFEQUFJQSxDQUFDc0IsY0FBYyxJQUFJLENBQUNYLElBQUksR0FBRyxJQUFJO1lBQ2hFLElBQUksQ0FBQ2EsV0FBVyxDQUFDLHVCQUF1Qk47UUFDNUM7UUFDQSxPQUFPRCxPQUFPUSxVQUFVLENBQUNOO0lBQzdCO0lBQ0FPLE9BQU9DLE1BQU0sRUFBRTtRQUNYLElBQUlSLFFBQVFuQixxREFBSUEsQ0FBQzJCLE9BQU9DLFNBQVMsSUFBSSxJQUFJLENBQUNqQixJQUFJLEdBQUc7UUFDakQsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNiTyxRQUFRckIseURBQVFBLENBQUNxQixPQUFPLElBQUksQ0FBQ1IsSUFBSSxHQUFHO1FBQ3hDO1FBQ0EsT0FBT1E7SUFDWDtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzPzcxNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZnJvbVR3b3MsIGdldEJpZ0ludCwgbWFzaywgdG9Ud29zIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFdvcmRTaXplIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBzaWduZWQ7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUsIHNpZ25lZCB9LCB7IHNpemU6IFwibnVtYmVyXCIsIHNpZ25lZDogXCJib29sZWFuXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gbWFzayhCTl9NQVhfVUlOVDI1NiwgV29yZFNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gbWFzayhtYXhVaW50VmFsdWUsICh0aGlzLnNpemUgKiA4KSAtIDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gYm91bmRzIHx8IHZhbHVlIDwgLShib3VuZHMgKyBCTl8xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHRvVHdvcyh2YWx1ZSwgOCAqIFdvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IEJOXzAgfHwgdmFsdWUgPiBtYXNrKG1heFVpbnRWYWx1ZSwgdGhpcy5zaXplICogOCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXNrKHJlYWRlci5yZWFkVmFsdWUoKSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImZyb21Ud29zIiwiZ2V0QmlnSW50IiwibWFzayIsInRvVHdvcyIsIlR5cGVkIiwiQ29kZXIiLCJXb3JkU2l6ZSIsIkJOXzAiLCJCaWdJbnQiLCJCTl8xIiwiQk5fTUFYX1VJTlQyNTYiLCJOdW1iZXJDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsInNpZ25lZCIsImxvY2FsTmFtZSIsIm5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwidHlwZSIsIm1heFVpbnRWYWx1ZSIsImJvdW5kcyIsIl90aHJvd0Vycm9yIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */ class StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUM1QjtBQUNXO0FBQy9DOztDQUVDLEdBQ00sTUFBTUksb0JBQW9CRCx3REFBaUJBO0lBQzlDRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFVBQVVBO0lBQ3BCO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsT0FBTyxLQUFLLENBQUNGLE9BQU9DLFFBQVFULDJEQUFXQSxDQUFDRSw0Q0FBS0EsQ0FBQ1MsV0FBVyxDQUFDRCxRQUFRO0lBQ3RFO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9aLDREQUFZQSxDQUFDLEtBQUssQ0FBQ1csT0FBT0M7SUFDckM7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcz9mYjZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyhUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsIlR5cGVkIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJTdHJpbmdDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwiZGVyZWZlcmVuY2UiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2RDtBQUN6QjtBQUNRO0FBQ0Y7QUFDMUM7O0NBRUMsR0FDTSxNQUFNSyxtQkFBbUJILHFEQUFLQTtJQUVqQ0ksWUFBWUMsTUFBTSxFQUFFQyxTQUFTLENBQUU7UUFDM0IsSUFBSUMsVUFBVTtRQUNkLE1BQU1DLFFBQVEsRUFBRTtRQUNoQkgsT0FBT0ksT0FBTyxDQUFDLENBQUNDO1lBQ1osSUFBSUEsTUFBTUgsT0FBTyxFQUFFO2dCQUNmQSxVQUFVO1lBQ2Q7WUFDQUMsTUFBTUcsSUFBSSxDQUFDRCxNQUFNRSxJQUFJO1FBQ3pCO1FBQ0EsTUFBTUEsT0FBUSxXQUFXSixNQUFNSyxJQUFJLENBQUMsT0FBTztRQUMzQyxLQUFLLENBQUMsU0FBU0QsTUFBTU4sV0FBV0M7UUFDaENULHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRU8sUUFBUVMsT0FBT0MsTUFBTSxDQUFDVixPQUFPVyxLQUFLO1FBQUk7SUFDbkU7SUFDQUMsZUFBZTtRQUNYLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNiLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDO1lBQ2pCUSxPQUFPUCxJQUFJLENBQUNELE1BQU1PLFlBQVk7UUFDbEM7UUFDQSw0REFBNEQ7UUFDNUQsTUFBTUUsY0FBYyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsTUFBTSxDQUFDLENBQUNDLE9BQU9YO1lBQzNDLE1BQU1ZLE9BQU9aLE1BQU1KLFNBQVM7WUFDNUIsSUFBSWdCLE1BQU07Z0JBQ04sSUFBSSxDQUFDRCxLQUFLLENBQUNDLEtBQUssRUFBRTtvQkFDZEQsS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2xCO2dCQUNBRCxLQUFLLENBQUNDLEtBQUs7WUFDZjtZQUNBLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO1FBQ0osbUJBQW1CO1FBQ25CLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDLE9BQU9hO1lBQ3hCLElBQUlELE9BQU9aLE1BQU1KLFNBQVM7WUFDMUIsSUFBSSxDQUFDZ0IsUUFBUUgsV0FBVyxDQUFDRyxLQUFLLEtBQUssR0FBRztnQkFDbEM7WUFDSjtZQUNBLElBQUlBLFNBQVMsVUFBVTtnQkFDbkJBLE9BQU87WUFDWDtZQUNBLElBQUlKLE1BQU0sQ0FBQ0ksS0FBSyxJQUFJLE1BQU07Z0JBQ3RCO1lBQ0o7WUFDQUosTUFBTSxDQUFDSSxLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssTUFBTTtRQUNoQztRQUNBLE9BQU9ULE9BQU9DLE1BQU0sQ0FBQ0c7SUFDekI7SUFDQU0sT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUTVCLDRDQUFLQSxDQUFDNkIsV0FBVyxDQUFDRixRQUFRO1FBQ3hDLE9BQU96QiwrQ0FBSUEsQ0FBQ3dCLFFBQVEsSUFBSSxDQUFDcEIsTUFBTSxFQUFFc0I7SUFDckM7SUFDQUUsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTzVCLGlEQUFNQSxDQUFDNEIsUUFBUSxJQUFJLENBQUN6QixNQUFNO0lBQ3JDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcz8zYTRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IHBhY2ssIHVucGFjayB9IGZyb20gXCIuL2FycmF5LmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcnM7XG4gICAgY29uc3RydWN0b3IoY29kZXJzLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlcnM6IE9iamVjdC5mcmVlemUoY29kZXJzLnNsaWNlKCkpIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIEFkZCBuYW1lZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJ0dXBsZVwiKTtcbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCB0aGlzLmNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJUeXBlZCIsIkNvZGVyIiwicGFjayIsInVucGFjayIsIlR1cGxlQ29kZXIiLCJjb25zdHJ1Y3RvciIsImNvZGVycyIsImxvY2FsTmFtZSIsImR5bmFtaWMiLCJ0eXBlcyIsImZvckVhY2giLCJjb2RlciIsInB1c2giLCJ0eXBlIiwiam9pbiIsIk9iamVjdCIsImZyZWV6ZSIsInNsaWNlIiwiZGVmYXVsdFZhbHVlIiwidmFsdWVzIiwidW5pcXVlTmFtZXMiLCJyZWR1Y2UiLCJhY2N1bSIsIm5hbWUiLCJpbmRleCIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/fragments.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ \n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() {\n        return this.#offset;\n    }\n    get length() {\n        return this.#tokens.length - this.#offset;\n    }\n    constructor(tokens){\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() {\n        return new TokenString(this.#tokens);\n    }\n    reset() {\n        this.#offset = 0;\n    }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t)=>{\n            return Object.freeze(Object.assign({}, t, {\n                match: t.match - from,\n                linkBack: t.linkBack - from,\n                linkNext: t.linkNext - from\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while(this.#offset < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = this.#offset; i < this.#tokens.length; i++){\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        } else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index)=>{\n                childType.#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            } else {\n                if (value == null || typeof value !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param)=>{\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index)=>{\n                components[index].#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push(async function() {\n                setValue(await result);\n            }());\n        } else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        this.#walkAsync(promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = `tuple(${comps.map((c)=>c.format()).join(\",\")})`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            anonymous\n        });\n    }\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            `constructor${joinParams(format, this.inputs)}`\n        ];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable\n        });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNpSDtBQUM1RTs7QUFFdEMscUNBQXFDO0FBQ3JDLFNBQVNPLE9BQU9DLEtBQUs7SUFDakIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkYsTUFBTUcsT0FBTyxDQUFDLENBQUNDLElBQU1ILE9BQU9JLEdBQUcsQ0FBQ0Q7SUFDaEMsT0FBT0UsT0FBT0MsTUFBTSxDQUFDTjtBQUN6QjtBQUNBLE1BQU1PLGlCQUFpQjtBQUN2QixNQUFNQyxnQkFBZ0JWLE9BQU9TLGVBQWVFLEtBQUssQ0FBQztBQUNsRCxzQkFBc0I7QUFDdEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxVQUFVYixPQUFPWSxTQUFTRCxLQUFLLENBQUM7QUFDdEMsTUFBTUcsV0FBVztBQUNqQixNQUFNQyxVQUFVZixPQUFPYyxTQUFTSCxLQUFLLENBQUM7QUFDdEMsTUFBTUssZUFBZTtBQUNyQixNQUFNQyxjQUFjakIsT0FBT2dCLGFBQWFMLEtBQUssQ0FBQztBQUM5QyxNQUFNTyxXQUFXO0FBQ2pCLGVBQWU7QUFDZixNQUFNQyxZQUFZO0lBQUNMO0lBQVVFO0lBQWNFO0lBQVVOO0NBQVMsQ0FBQ1EsSUFBSSxDQUFDO0FBQ3BFLE1BQU1DLFdBQVdyQixPQUFPbUIsVUFBVVIsS0FBSyxDQUFDO0FBQ3hDLDBCQUEwQjtBQUMxQixNQUFNVyxlQUFlO0lBQ2pCLEtBQUs7SUFBYyxLQUFLO0lBQ3hCLEtBQUs7SUFBZ0IsS0FBSztJQUMxQixLQUFLO0lBQVMsS0FBSztBQUN2QjtBQUNBLDJDQUEyQztBQUMzQyxNQUFNQyx3QkFBd0IsSUFBSUMsT0FBTztBQUN6QyxNQUFNQyxvQkFBb0IsSUFBSUQsT0FBTztBQUNyQyxNQUFNRSxnQkFBZ0IsSUFBSUYsT0FBTztBQUNqQyxrQ0FBa0M7QUFDbEMsTUFBTUcsVUFBVSxJQUFJSCxPQUFP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LEtBQUtTO0lBQ3pDO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcz83MWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBhc3NlcnQsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG47XG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cbmZ1bmN0aW9uIHNldGlmeShpdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xufVxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlIG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liRGVwbG95ID0gc2V0aWZ5KF9rd1Zpc2liRGVwbG95LnNwbGl0KFwiIFwiKSk7XG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXcgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWIgPSBzZXRpZnkoX2t3VmlzaWIuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3TW9kaWZpZXJzID0gXCJjYWxsZGF0YSBtZW1vcnkgc3RvcmFnZSBwYXlhYmxlIGluZGV4ZWRcIjtcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcbi8vIEFsbCBLZXl3b3Jkc1xuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbi8vIFNpbmdsZSBjaGFyYWN0ZXIgdG9rZW5zXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxuICAgIFwiW1wiOiBcIk9QRU5fQlJBQ0tFVFwiLCBcIl1cIjogXCJDTE9TRV9CUkFDS0VUXCIsXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxufTtcbi8vIFBhcnNlciByZWdleGVzIHRvIGNvbnN1bWUgdGhlIG5leHQgdG9rZW5cbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XG5jb25zdCByZWdleElkUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKVwiKTtcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcbmNvbnN0IHJlZ2V4VHlwZSA9IG5ldyBSZWdFeHAoXCJeKGFkZHJlc3N8Ym9vbHxieXRlcyhbMC05XSopfHN0cmluZ3x1P2ludChbMC05XSopKSRcIik7XG5jbGFzcyBUb2tlblN0cmluZyB7XG4gICAgI29mZnNldDtcbiAgICAjdG9rZW5zO1xuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XG4gICAgI3N1YlRva2VuU3RyaW5nKGZyb20gPSAwLCB0byA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAodC5tYXRjaCAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYWxsb3dlZDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJLRVlXT1JEXCIgfHwgIWFsbG93ZWQuaGFzKHRvcC50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcFR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke3RvcC50eXBlfSAke0pTT04uc3RyaW5naWZ5KHRvcC50ZXh0KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zIGF0IG9mZnNldCAke3Rva2Vucy5vZmZzZXR9OiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hbWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXG4gICAgICogIGBgXCJhZGRyZXNzXCJgYCB0eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxuICAgICAgICAgICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnBvcFR5cGUoXCJUWVBFXCIpKTtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQXJyYXlcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAob2JqLmxlbmd0aCAmJiBvYmoucGVla1R5cGUoXCJCUkFDS0VUXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCA9IGJyYWNrZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qga2V5d29yZHMgPSBjb25zdW1lS2V5d29yZHMob2JqLCBLd01vZGlmaWVycyk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVmdG92ZXIgdG9rZW5zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IG9iai5pbmRleGVkO1xuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xuICAgICAgICAgICAgaW5kZXhlZCA9ICEhaW5kZXhlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xuICAgICAgICBsZXQgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheVR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XG4gICAgICAgICAgICBjb25zdCBhcnJheUNoaWxkcmVuID0gUGFyYW1UeXBlLmZyb20oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInR1cGxlXCIgfHwgdHlwZS5zdGFydHNXaXRoKFwidHVwbGUoXCIgLyogZml4OiApICovKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCIoXCIgLyogZml4OiApICovKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHVzZSBsZXhlciB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai50eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXG4gICAgICovXG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBpbnB1dHM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIEpTT04uLi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBIdW1hbi1yZWFkYWJsZSBBQkkgKGFscmVhZHkgbGV4ZWQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gSlNPTiBBQklcbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50XG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luUGFyYW1zKGZvcm1hdCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEVycm9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBDdXN0b20gRXJyb3Igc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXJyb3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhpcyBldmVudCBpcyBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgYW5vbnltb3VzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFub255bW91cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFdmVudCB0b3BpYyBoYXNoLlxuICAgICAqL1xuICAgIGdldCB0b3BpY0hhc2goKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV2ZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcGljSGFzaChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFdmVudEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJldmVudFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHAsIHRydWUpKSA6IFtdLCAhIW9iai5hbm9ueW1vdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIGNvbnN0cnVjdG9yIGNhbiByZWNlaXZlIGFuIGVuZG93bWVudC5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBhc3NlcnQoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xuICAgICAgICBpZiAodGhpcy5wYXlhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU11dGFiaWxpdHkgPSAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3R5cGV9KCkke3RoaXMucGF5YWJsZSA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGYWxsYmFja0ZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGYWxsYmFja0ZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjaygpIFtwYXlhYmxlXVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBwYXlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLm91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2VsZWN0b3IgZm9yIGEgZnVuY3Rpb24gd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJhc3NlcnQiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0QXJndW1lbnQiLCJpZCIsInNldGlmeSIsIml0ZW1zIiwicmVzdWx0IiwiU2V0IiwiZm9yRWFjaCIsImsiLCJhZGQiLCJPYmplY3QiLCJmcmVlemUiLCJfa3dWaXNpYkRlcGxveSIsIkt3VmlzaWJEZXBsb3kiLCJzcGxpdCIsIl9rd1Zpc2liIiwiS3dWaXNpYiIsIl9rd1R5cGVzIiwiS3dUeXBlcyIsIl9rd01vZGlmaWVycyIsIkt3TW9kaWZpZXJzIiwiX2t3T3RoZXIiLCJfa2V5d29yZHMiLCJqb2luIiwiS2V5d29yZHMiLCJTaW1wbGVUb2tlbnMiLCJyZWdleFdoaXRlc3BhY2VQcmVmaXgiLCJSZWdFeHAiLCJyZWdleE51bWJlclByZWZpeCIsInJlZ2V4SWRQcmVmaXgiLCJyZWdleElkIiwicmVnZXhUeXBlIiwiVG9rZW5TdHJpbmciLCJvZmZzZXQiLCJ0b2tlbnMiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsInNsaWNlIiwiY2xvbmUiLCJyZXNldCIsInN1YlRva2VuU3RyaW5nIiwiZnJvbSIsInRvIiwibWFwIiwidCIsImFzc2lnbiIsIm1hdGNoIiwibGlua0JhY2siLCJsaW5rTmV4dCIsInBvcEtleXdvcmQiLCJhbGxvd2VkIiwidG9wIiwicGVlayIsInR5cGUiLCJoYXMiLCJ0ZXh0IiwiRXJyb3IiLCJwb3AiLCJwb3BUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInBvcFBhcmVuIiwicG9wUGFyYW1zIiwibGluayIsInB1c2giLCJwZWVrS2V5d29yZCIsInBlZWtUeXBlIiwidG9TdHJpbmciLCJpIiwidG9rZW4iLCJsZXgiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsImJyYWNrZXRzIiwiY29tbWFzIiwiY3VyIiwic3Vic3RyaW5nIiwiZGVwdGgiLCJ2YWx1ZSIsInN1ZmZpeCIsImFsbG93U2luZ2xlIiwic2V0IiwiaW5jbHVkZWQiLCJrZXkiLCJrZXlzIiwiY29uc3VtZU5hbWUiLCJrZXl3b3JkIiwiY29uc3VtZUtleXdvcmRzIiwia2V5d29yZHMiLCJjb25zdW1lTXV0YWJpbGl0eSIsIm1vZGlmaWVycyIsImNvbnN1bWVQYXJhbXMiLCJhbGxvd0luZGV4ZWQiLCJQYXJhbVR5cGUiLCJjb25zdW1lR2FzIiwiY29uc3VtZUVvaSIsInJlZ2V4QXJyYXlUeXBlIiwidmVyaWZ5QmFzaWNUeXBlIiwicGFyc2VJbnQiLCJzaXplIiwiX2d1YXJkIiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmb3IiLCJQYXJhbVR5cGVJbnRlcm5hbCIsIkVycm9yRnJhZ21lbnRJbnRlcm5hbCIsIkV2ZW50RnJhZ21lbnRJbnRlcm5hbCIsIkNvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCIsIkZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCIsIkZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCIsIlN0cnVjdEZyYWdtZW50SW50ZXJuYWwiLCJndWFyZCIsIm5hbWUiLCJiYXNlVHlwZSIsImluZGV4ZWQiLCJjb21wb25lbnRzIiwiYXJyYXlMZW5ndGgiLCJhcnJheUNoaWxkcmVuIiwiZGVmaW5lUHJvcGVydHkiLCJmb3JtYXQiLCJpc0FycmF5IiwicGFyc2UiLCJTdHJpbmciLCJpc1R1cGxlIiwiYyIsImNvbXAiLCJpc0luZGV4YWJsZSIsIndhbGsiLCJwcm9jZXNzIiwiQXJyYXkiLCJfdGhpcyIsInYiLCJ3YWxrQXN5bmMiLCJwcm9taXNlcyIsInNldFZhbHVlIiwiY2hpbGRUeXBlIiwiaW5kZXgiLCJwYXJhbSIsInRoZW4iLCJQcm9taXNlIiwiYWxsIiwib2JqIiwiaXNQYXJhbVR5cGUiLCJlcnJvciIsImNvbXBzIiwiYnJhY2tldCIsImFycmF5TWF0Y2giLCJzdGFydHNXaXRoIiwidHVwbGUiLCJGcmFnbWVudCIsImlucHV0cyIsImUiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGYWxsYmFja0ZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIlN0cnVjdEZyYWdtZW50Iiwib3BlcmF0aW9uIiwiaXNDb25zdHJ1Y3RvciIsImlzRnJhZ21lbnQiLCJpc0Vycm9yIiwiaXNFdmVudCIsImlzRnVuY3Rpb24iLCJpc1N0cnVjdCIsIk5hbWVkRnJhZ21lbnQiLCJqb2luUGFyYW1zIiwicGFyYW1zIiwicCIsInNlbGVjdG9yIiwiaW5wdXQiLCJhbm9ueW1vdXMiLCJ0b3BpY0hhc2giLCJnZXRUb3BpY0hhc2giLCJmcmFnbWVudCIsInBheWFibGUiLCJnYXMiLCJzdGF0ZU11dGFiaWxpdHkiLCJ1bmRlZmluZWQiLCJlcnJvck9iaiIsInRvcElzVmFsaWQiLCJtdXRhYmlsaXR5Iiwib3V0cHV0cyIsImNvbnN0YW50IiwibyIsImdldFNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/interface.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abi-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ \n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            } catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = values.length > 0 ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#functions.get(name), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()){\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for(let i = matching.length - 1; i >= 0; i--){\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#events.get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#errors.get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof value.formatJson === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n} //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDOEM7QUFDVDtBQUN3SjtBQUNwSjtBQUM2QjtBQUNtRDtBQUN2RjtBQUNFO0FBQ3JDOzs7Q0FHQyxHQUNNLE1BQU15QjtJQXFCVDs7S0FFQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxDQUFFO1FBQy9CLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNQztZQUFXSDtZQUFPQztRQUN0QztJQUNKO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUk7SUF5QlQ7O0tBRUMsR0FDRFAsWUFBWUMsUUFBUSxFQUFFTyxRQUFRLEVBQUVMLElBQUksRUFBRU0sS0FBSyxDQUFFO1FBQ3pDLE1BQU1MLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztZQUFVQztRQUMvQztJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQztJQXFCVDs7S0FFQyxHQUNEVixZQUFZQyxRQUFRLEVBQUVPLFFBQVEsRUFBRUwsSUFBSSxDQUFFO1FBQ2xDLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztRQUNyQztJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1HO0lBU1Q7Ozs7S0FJQyxHQUNELE9BQU9DLFVBQVVILEtBQUssRUFBRTtRQUNwQixPQUFPLENB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VXNDLElBQUkrRCxJQUFJLEVBQUUvRCxJQUFJOEYsTUFBTTtJQUM5RztJQUNBOzs7OztLQUtDLEdBQ0RxQixXQUFXcEQsSUFBSSxFQUFFO1FBQ2IsTUFBTXFELFVBQVU5Syx3REFBT0EsQ0FBQ3lIO1FBQ3hCLE1BQU1yRyxXQUFXLElBQUksQ0FBQ2lHLFFBQVEsQ0FBQ3pILDBEQUFTQSxDQUFDa0wsU0FBUyxHQUFHO1FBQ3JELElBQUksQ0FBQzFKLFVBQVU7WUFDWCxPQUFPO1FBQ1g7UUFDQSxNQUFNRSxPQUFPLElBQUksQ0FBQyxDQUFDeUIsUUFBUSxDQUFDMkUsTUFBTSxDQUFDdEcsU0FBU2dCLE1BQU0sRUFBRXhDLDBEQUFTQSxDQUFDa0wsU0FBUztRQUN2RSxPQUFPLElBQUlqSixpQkFBaUJULFVBQVVBLFNBQVNPLFFBQVEsRUFBRUw7SUFDN0Q7SUFDQTs7Ozs7S0FLQyxHQUNELE9BQU9pQyxLQUFLM0IsS0FBSyxFQUFFO1FBQ2YsMkNBQTJDO1FBQzNDLElBQUlBLGlCQUFpQmUsV0FBVztZQUM1QixPQUFPZjtRQUNYO1FBQ0EsT0FBTztRQUNQLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLE9BQU8sSUFBSWUsVUFBVUosS0FBS1csS0FBSyxDQUFDdEI7UUFDcEM7UUFDQSxrREFBa0Q7UUFDbEQsSUFBSSxPQUFRQSxNQUFNZ0QsVUFBVSxLQUFNLFlBQVk7WUFDMUMsT0FBTyxJQUFJakMsVUFBVWYsTUFBTWdELFVBQVU7UUFDekM7UUFDQSw0Q0FBNEM7UUFDNUMsSUFBSSxPQUFRaEQsTUFBTUgsTUFBTSxLQUFNLFlBQVk7WUFDdEMsT0FBTyxJQUFJa0IsVUFBVWYsTUFBTUgsTUFBTSxDQUFDO1FBQ3RDO1FBQ0EscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSWtCLFVBQVVmO0lBQ3pCO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcz9lNTY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIHRvcGljO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBFdmVudCB3aXRoIGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCB0b3BpYywgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcbiAqICBmaXQgd2l0aGluIGEgdG9waWMgKGkuZS4gbm90IGEgZml4ZWQtbGVuZ3RoLCAzMi1ieXRlIHR5cGUpLiBJdFxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcbiAgICB9XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgQ29udHJhY3QgQUJJIG1lbWJlcnMgKGkuZS4gbWV0aG9kcywgZXZlbnRzLCBlcnJvcnMsIGV0YykuXG4gICAgICovXG4gICAgZnJhZ21lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZGVwbG95O1xuICAgIC8qKlxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIElmIHJlY2VpdmluZyBldGhlciBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVjZWl2ZTtcbiAgICAjZXJyb3JzO1xuICAgICNldmVudHM7XG4gICAgI2Z1bmN0aW9ucztcbiAgICAvLyAgICAjc3RydWN0czogTWFwPHN0cmluZywgU3RydWN0RnJhZ21lbnQ+O1xuICAgICNhYmlDb2RlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEludGVyZmFjZSBmb3IgdGhlICUlZnJhZ21lbnRzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dhcm5pbmddIEludmFsaWQgRnJhZ21lbnQgJHtKU09OLnN0cmluZ2lmeShhKX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuIEludGVyZmFjZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIHY2IGluc3RhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdEpzb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdEpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBsZWdhY3kgSW50ZXJmYWNlOyBmcm9tIGFuIG9sZGVyIHZlcnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiaWQiLCJjb25jYXQiLCJkYXRhU2xpY2UiLCJnZXRCaWdJbnQiLCJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImhleGxpZnkiLCJ6ZXJvUGFkQnl0ZXMiLCJ6ZXJvUGFkVmFsdWUiLCJpc0hleFN0cmluZyIsImRlZmluZVByb3BlcnRpZXMiLCJhc3NlcnRBcmd1bWVudCIsInRvQmVIZXgiLCJhc3NlcnQiLCJBYmlDb2RlciIsImNoZWNrUmVzdWx0RXJyb3JzIiwiUmVzdWx0IiwiQ29uc3RydWN0b3JGcmFnbWVudCIsIkVycm9yRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRnJhZ21lbnQiLCJGdW5jdGlvbkZyYWdtZW50IiwiUGFyYW1UeXBlIiwiVHlwZWQiLCJMb2dEZXNjcmlwdGlvbiIsImNvbnN0cnVjdG9yIiwiZnJhZ21lbnQiLCJ0b3BpYyIsImFyZ3MiLCJuYW1lIiwic2lnbmF0dXJlIiwiZm9ybWF0IiwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsInNlbGVjdG9yIiwidmFsdWUiLCJFcnJvckRlc2NyaXB0aW9uIiwiSW5kZXhlZCIsImlzSW5kZXhlZCIsIl9pc0luZGV4ZWQiLCJoYXNoIiwiUGFuaWNSZWFzb25zIiwiQnVpbHRpbkVycm9ycyIsImlucHV0cyIsInJlYXNvbiIsIm1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29kZSIsInRvU3RyaW5nIiwiSW50ZXJmYWNlIiwiZXJyb3JzIiwiZXZlbnRzIiwiZnVuY3Rpb25zIiwiYWJpQ29kZXIiLCJmcmFnbWVudHMiLCJhYmkiLCJwYXJzZSIsIk1hcCIsImZyYWdzIiwiYSIsInB1c2giLCJmcm9tIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwiT2JqZWN0IiwiZnJlZXplIiwiZmFsbGJhY2siLCJyZWNlaXZlIiwiZ2V0QWJpQ29kZXIiLCJmb3JFYWNoIiwiaW5kZXgiLCJidWNrZXQiLCJ0eXBlIiwiZGVwbG95IiwibGVuZ3RoIiwicGF5YWJsZSIsImhhcyIsInNldCIsIm1pbmltYWwiLCJtYXAiLCJmIiwiZm9ybWF0SnNvbiIsImoiLCJkZWZhdWx0QWJpQ29kZXIiLCJnZXRGdW5jdGlvbiIsImtleSIsInZhbHVlcyIsImZvcmNlVW5pcXVlIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwibWF0Y2hpbmciLCJzcGxpdCIsImxhc3RWYWx1ZSIsInZhbHVlTGVuZ3RoIiwiYWxsb3dPcHRpb25zIiwiaXNUeXBlZCIsImkiLCJzcGxpY2UiLCJiYXNlVHlwZSIsImxhc3RBcmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXRjaFN0ciIsIm0iLCJqb2luIiwicmVzdWx0IiwiZ2V0IiwiZ2V0RnVuY3Rpb25OYW1lIiwiaGFzRnVuY3Rpb24iLCJmb3JFYWNoRnVuY3Rpb24iLCJjYWxsYmFjayIsIm5hbWVzIiwia2V5cyIsInNvcnQiLCJiIiwibG9jYWxlQ29tcGFyZSIsImdldEV2ZW50IiwiZXZlbnRUb3BpYyIsInRvcGljSGFzaCIsImdldEV2ZW50TmFtZSIsImhhc0V2ZW50IiwiZm9yRWFjaEV2ZW50IiwiZ2V0RXJyb3IiLCJmb3JFYWNoRXJyb3IiLCJfZGVjb2RlUGFyYW1zIiwicGFyYW1zIiwiZGF0YSIsImRlY29kZSIsIl9lbmNvZGVQYXJhbXMiLCJlbmNvZGUiLCJlbmNvZGVEZXBsb3kiLCJkZWNvZGVFcnJvclJlc3VsdCIsImVuY29kZUVycm9yUmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25EYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJieXRlcyIsIm91dHB1dHMiLCJpbmZvIiwibWV0aG9kIiwibWFrZUVycm9yIiwiX2RhdGEiLCJ0eCIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiY3VzdG9tUHJlZml4Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZWYiLCJyZXZlcnQiLCJlIiwicGFyc2VkIiwicGFyc2VUcmFuc2FjdGlvbiIsImludm9jYXRpb24iLCJlbmNvZGVGdW5jdGlvblJlc3VsdCIsImVuY29kZUZpbHRlclRvcGljcyIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsInRvcGljcyIsImFub255bW91cyIsImVuY29kZVRvcGljIiwicGFyYW0iLCJtYXRjaCIsImluZGV4ZWQiLCJwb3AiLCJlbmNvZGVFdmVudExvZyIsImRhdGFUeXBlcyIsImRhdGFWYWx1ZXMiLCJFcnJvciIsImRlY29kZUV2ZW50TG9nIiwibm9uSW5kZXhlZCIsImR5bmFtaWMiLCJyZXN1bHRJbmRleGVkIiwicmVzdWx0Tm9uSW5kZXhlZCIsIm5vbkluZGV4ZWRJbmRleCIsImluZGV4ZWRJbmRleCIsImZyb21JdGVtcyIsInBhcnNlQ2FsbFJlc3VsdCIsInBhcnNlTG9nIiwicGFyc2VFcnJvciIsImhleERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/typed.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/typed.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ \nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    #options;\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v)=>v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n} //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDbUU7QUFDcEUsTUFBTUUsU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsUUFBUSxHQUFHO1FBQ1hDLFNBQVM7UUFDVEQsU0FBUyxDQUFDO0lBQ2Q7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBTyxJQUFJRSxNQUFNTCxRQUFRLENBQUMsRUFBRUksU0FBUyxLQUFLLElBQUksR0FBRyxFQUFFRCxNQUFNLENBQUMsRUFBRUQsT0FBTztRQUFFRTtRQUFRRDtJQUFNO0FBQ3ZGO0FBQ0EsU0FBU0csRUFBRUosS0FBSyxFQUFFSyxJQUFJO0lBQ2xCLHdDQUF3QztJQUN4QyxPQUFPLElBQUlGLE1BQU1MLFFBQVEsQ0FBQyxLQUFLLEVBQUUsT0FBU08sT0FBTyxHQUFHLENBQUMsRUFBRUwsT0FBTztRQUFFSztJQUFLO0FBQ3pFO0FBQ0EsTUFBTUMsZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQ2hDOztDQUVDLEdBQ00sTUFBTUw7SUFTVCxDQUFDTSxPQUFPLENBQUM7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRVosS0FBSyxFQUFFUyxPQUFPLENBQUU7UUFDckMsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVO1FBQ2Q7UUFDQWIsOERBQWFBLENBQUNFLFFBQVFhLE9BQU87UUFDN0JkLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVM7WUFBY007WUFBTVo7UUFBTTtRQUNuRCxJQUFJLENBQUMsQ0FBQ1MsT0FBTyxHQUFHQTtRQUNoQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDSSxNQUFNO0lBQ2Y7SUFDQTs7S0FFQyxHQUNEQSxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxTQUFTO1lB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QkFDckIsTUFBTSxJQUFJRSxNQUFNLENBQUMsdUJBQXVCLEVBQUVGLEtBQUssTUFBTSxFQUFFWixNQUFNWSxJQUFJLENBQUMsQ0FBQztZQUN2RTtZQUNBLE9BQU9aLE1BQU1BLEtBQUs7UUFDdEI7UUFDQSxPQUFPQTtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzPzJkZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0UHJpdmF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJfZ2F1cmQiLCJuIiwidmFsdWUiLCJ3aWR0aCIsInNpZ25lZCIsIlR5cGVkIiwiYiIsInNpemUiLCJfdHlwZWRTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJvcHRpb25zIiwiY29uc3RydWN0b3IiLCJnYXVyZCIsInR5cGUiLCJmb3JtYXQiLCJFcnJvciIsIm1hcCIsInYiLCJqb2luIiwiZGVmYXVsdFZhbHVlIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImlzQmlnSW50IiwibWF0Y2giLCJpc0RhdGEiLCJzdGFydHNXaXRoIiwiaXNTdHJpbmciLCJ0dXBsZU5hbWUiLCJUeXBlRXJyb3IiLCJhcnJheUxlbmd0aCIsImxlbmd0aCIsImZyb20iLCJ1aW50OCIsInVpbnQxNiIsInVpbnQyNCIsInVpbnQzMiIsInVpbnQ0MCIsInVpbnQ0OCIsInVpbnQ1NiIsInVpbnQ2NCIsInVpbnQ3MiIsInVpbnQ4MCIsInVpbnQ4OCIsInVpbnQ5NiIsInVpbnQxMDQiLCJ1aW50MTEyIiwidWludDEyMCIsInVpbnQxMjgiLCJ1aW50MTM2IiwidWludDE0NCIsInVpbnQxNTIiLCJ1aW50MTYwIiwidWludDE2OCIsInVpbnQxNzYiLCJ1aW50MTg0IiwidWludDE5MiIsInVpbnQyMDAiLCJ1aW50MjA4IiwidWludDIxNiIsInVpbnQyMjQiLCJ1aW50MjMyIiwidWludDI0MCIsInVpbnQyNDgiLCJ1aW50MjU2IiwidWludCIsImludDgiLCJpbnQxNiIsImludDI0IiwiaW50MzIiLCJpbnQ0MCIsImludDQ4IiwiaW50NTYiLCJpbnQ2NCIsImludDcyIiwiaW50ODAiLCJpbnQ4OCIsImludDk2IiwiaW50MTA0IiwiaW50MTEyIiwiaW50MTIwIiwiaW50MTI4IiwiaW50MTM2IiwiaW50MTQ0IiwiaW50MTUyIiwiaW50MTYwIiwiaW50MTY4IiwiaW50MTc2IiwiaW50MTg0IiwiaW50MTkyIiwiaW50MjAwIiwiaW50MjA4IiwiaW50MjE2IiwiaW50MjI0IiwiaW50MjMyIiwiaW50MjQwIiwiaW50MjQ4IiwiaW50MjU2IiwiaW50IiwiYnl0ZXMxIiwiYnl0ZXMyIiwiYnl0ZXMzIiwiYnl0ZXM0IiwiYnl0ZXM1IiwiYnl0ZXM2IiwiYnl0ZXM3IiwiYnl0ZXM4IiwiYnl0ZXM5IiwiYnl0ZXMxMCIsImJ5dGVzMTEiLCJieXRlczEyIiwiYnl0ZXMxMyIsImJ5dGVzMTQiLCJieXRlczE1IiwiYnl0ZXMxNiIsImJ5dGVzMTciLCJieXRlczE4IiwiYnl0ZXMxOSIsImJ5dGVzMjAiLCJieXRlczIxIiwiYnl0ZXMyMiIsImJ5dGVzMjMiLCJieXRlczI0IiwiYnl0ZXMyNSIsImJ5dGVzMjYiLCJieXRlczI3IiwiYnl0ZXMyOCIsImJ5dGVzMjkiLCJieXRlczMwIiwiYnl0ZXMzMSIsImJ5dGVzMzIiLCJhZGRyZXNzIiwiYm9vbCIsImJ5dGVzIiwic3RyaW5nIiwiYXJyYXkiLCJkeW5hbWljIiwidHVwbGUiLCJuYW1lIiwib3ZlcnJpZGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiaXNUeXBlZCIsImRlcmVmZXJlbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/address.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/address.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ2M7QUFDN0QsTUFBTUcsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLFNBQVNFLG1CQUFtQkMsT0FBTztJQUMvQixzQ0FBc0M7SUFDdEMsMkVBQTJFO0lBQzNFLE9BQU87SUFDUEEsVUFBVUEsUUFBUUMsV0FBVztJQUM3QixNQUFNQyxRQUFRRixRQUFRRyxTQUFTLENBQUMsR0FBR0MsS0FBSyxDQUFDO0lBQ3pDLE1BQU1DLFdBQVcsSUFBSUMsV0FBVztJQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCRixRQUFRLENBQUNFLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxFQUFFLENBQUNDLFVBQVUsQ0FBQztJQUN0QztJQUNBLE1BQU1DLFNBQVNmLHlEQUFRQSxDQUFDRCwyREFBU0EsQ0FBQ1k7SUFDbEMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1FBQzVCLElBQUksTUFBTyxDQUFDQSxLQUFLLEVBQUUsSUFBSSxLQUFNLEdBQUc7WUFDNUJMLEtBQUssQ0FBQ0ssRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0csV0FBVztRQUNuQztRQUNBLElBQUksQ0FBQ0QsTUFBTSxDQUFDRixLQUFLLEVBQUUsR0FBRyxJQUFHLEtBQU0sR0FBRztZQUM5QkwsS0FBSyxDQUFDSyxJQUFJLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxJQUFJLEVBQUUsQ0FBQ0csV0FBVztRQUMzQztJQUNKO0lBQ0EsT0FBTyxPQUFPUixNQUFNUyxJQUFJLENBQUM7QUFDN0I7QUFDQSx1RUFBdUU7QUFDdkUsc0JBQXNCO0FBQ3RCLE1BQU1DLGFBQWEsQ0FBQztBQUNwQixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO0lBQ3pCSyxV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ZWhDLE9BQU87SUFDbEMsMkVBQTJFO0lBQzNFLElBQUlpQyxTQUFTcEMsT0FBTytCLFdBQVc1QixVQUFVK0IsUUFBUSxDQUFDLElBQUlyQixXQUFXO0lBQ2pFLE1BQU91QixPQUFPZCxNQUFNLEdBQUcsR0FBSTtRQUN2QmMsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT2pCLGFBQWEsU0FBU2lCLFVBQVVBO0FBQ2xELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcz9hMTk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJCTl8zNiIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsImNoYXJzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJleHBhbmRlZCIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImhhc2hlZCIsInRvVXBwZXJDYXNlIiwiam9pbiIsImliYW5Mb29rdXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzYWZlRGlnaXRzIiwiaWJhbkNoZWNrc3VtIiwibWFwIiwiYyIsImxlbmd0aCIsImJsb2NrIiwicGFyc2VJbnQiLCJjaGVja3N1bSIsIkJhc2UzNiIsInJlc3VsdCIsImtleSIsImZyb21CYXNlMzYiLCJ2YWx1ZSIsImdldEFkZHJlc3MiLCJtYXRjaCIsInN0YXJ0c1dpdGgiLCJ0b1N0cmluZyIsImdldEljYXBBZGRyZXNzIiwiYmFzZTM2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/checks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/checks.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n} //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDakI7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNHLGNBQWNDLEtBQUs7SUFDL0IsT0FBUUEsU0FBUyxPQUFRQSxNQUFNRixVQUFVLEtBQU07QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sU0FBU0csVUFBVUQsS0FBSztJQUMzQixJQUFJO1FBQ0FGLHVEQUFVQSxDQUFDRTtRQUNYLE9BQU87SUFDWCxFQUNBLE9BQU9FLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQSxlQUFlQyxhQUFhQyxNQUFNLEVBQUVDLE9BQU87SUFDdkMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixJQUFJQyxVQUFVLFFBQVFBLFdBQVcsOENBQThDO1FBQzNFVix1REFBTUEsQ0FBQyxPQUFRUSxXQUFZLFVBQVUscUJBQXFCLHFCQUFxQjtZQUFFSixPQUFPSTtRQUFPO1FBQy9GUCwrREFBY0EsQ0FBQyxPQUFPLGlFQUFpRSxVQUFVTztJQUNyRztJQUNBLE9BQU9OLHVEQUFVQSxDQUFDUTtBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxTQUFTQyxlQUFlSCxNQUFNLEVBQUVJLFFBQVE7SUFDM0MsSUFBSSxPQUFRSixXQUFZLFVBQVU7UUFDOUIsSUFBSUEsT0FBT0ssS0FBSyxDQUFDLHNCQUFzQjtZQUNuQyxPQUFPWCx1REFBVUEsQ0FBQ007UUFDdEI7UUFDQVIsdURBQU1BLENBQUNZLFlBQVksTUFBTSxzQ0FBc0MseUJBQXlCO1lBQUVFLFdBQVc7UUFBYztRQUNuSCxPQUFPUCxhQUFhQyxRQUFRSSxTQUFTRyxXQUFXLENBQUNQO0lBQ3JELE9BQ0ssSUFBSUwsY0FBY0ssU0FBUztRQUM1QixPQUFPRCxhQUFhQyxRQUFRQSxPQUFPTixVQUFVO0lBQ2pELE9BQ0ssSUFBSU0sVUFBVSxPQUFRQSxPQUFPUSxJQUFJLEtBQU0sWUFBWTtRQUNwRCxPQUFPVCxhQUFhQyxRQUFRQTtJQUNoQztJQUNBUCwrREFBY0EsQ0FBQyxPQUFPLGlDQUFpQyxVQUFVTztBQUNyRSxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcz84NDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZ2V0QWRkcmVzcyIsImlzQWRkcmVzc2FibGUiLCJ2YWx1ZSIsImlzQWRkcmVzcyIsImVycm9yIiwiY2hlY2tBZGRyZXNzIiwidGFyZ2V0IiwicHJvbWlzZSIsInJlc3VsdCIsInJlc29sdmVBZGRyZXNzIiwicmVzb2x2ZXIiLCJtYXRjaCIsIm9wZXJhdGlvbiIsInJlc29sdmVOYW1lIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* binding */ getCreateAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */ function getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.encodeRlp)([\n        from,\n        nonceHex\n    ])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */ function getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        from,\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=contract-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ3VEO0FBQzVEO0FBQzFDLHNHQUFzRztBQUN0Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTUSxpQkFBaUJDLEVBQUU7SUFDL0IsTUFBTUMsT0FBT0gsdURBQVVBLENBQUNFLEdBQUdDLElBQUk7SUFDL0IsTUFBTUMsUUFBUVIsMERBQVNBLENBQUNNLEdBQUdFLEtBQUssRUFBRTtJQUNsQyxJQUFJQyxXQUFXRCxNQUFNRSxRQUFRLENBQUM7SUFDOUIsSUFBSUQsYUFBYSxLQUFLO1FBQ2xCQSxXQUFXO0lBQ2YsT0FDSyxJQUFJQSxTQUFTRSxNQUFNLEdBQUcsR0FBRztRQUMxQkYsV0FBVyxRQUFRQTtJQUN2QixPQUNLO1FBQ0RBLFdBQVcsT0FBT0E7SUFDdEI7SUFDQSxPQUFPTCx1REFBVUEsQ0FBQ0wsMERBQVNBLENBQUNGLDJEQUFTQSxDQUFDSywwREFBU0EsQ0FBQztRQUFDSztRQUFNRTtLQUFTLElBQUk7QUFDeEU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNHLGtCQUFrQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGFBQWE7SUFDekQsTUFBTVIsT0FBT0gsdURBQVVBLENBQUNTO0lBQ3hCLE1BQU1HLE9BQU9mLHlEQUFRQSxDQUFDYSxPQUFPO0lBQzdCLE1BQU1HLGVBQWVoQix5REFBUUEsQ0FBQ2MsZUFBZTtJQUM3Q1osK0RBQWNBLENBQUNhLEtBQUtMLE1BQU0sS0FBSyxJQUFJLHlCQUF5QixRQUFRRztJQUNwRVgsK0RBQWNBLENBQUNjLGFBQWFOLE1BQU0sS0FBSyxJQUFJLGlDQUFpQyxnQkFBZ0JJO0lBQzVGLE9BQU9YLHVEQUFVQSxDQUFDTCwwREFBU0EsQ0FBQ0YsMkRBQVNBLENBQUNDLHVEQUFNQSxDQUFDO1FBQUM7UUFBUVM7UUFBTVM7UUFBTUM7S0FBYSxJQUFJO0FBQ3ZGLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY29udHJhY3QtYWRkcmVzcy5qcz9jMGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBlbmNvZGVSbHAsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xuLy8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURWBgIGZvciAlJXR4JSUuXG4gKlxuICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhbiBFT0Egd2hlbiBzZW5kaW5nIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAoaS5lLlxuICogIHdoZW4gdGhlIGBgdG9gYCBhZGRyZXNzIGlzIGBgbnVsbGBgKS5cbiAqXG4gKiAgVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYSBjb250cmFjdCwgYnkgdXNpbmcgdGhlIGNvbnRyYWN0J3MgYWRkcmVzcyBhcyB0aGVcbiAqICBgYHRvYGAgYW5kIHRoZSBjb250cmFjdCdzIG5vbmNlLlxuICpcbiAqICBAZXhhbXBsZVxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCI7XG4gKiAgICBub25jZSA9IDU7XG4gKlxuICogICAgZ2V0Q3JlYXRlQWRkcmVzcyh7IGZyb20sIG5vbmNlIH0pO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlQWRkcmVzcyh0eCkge1xuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xuICAgIGNvbnN0IG5vbmNlID0gZ2V0QmlnSW50KHR4Lm5vbmNlLCBcInR4Lm5vbmNlXCIpO1xuICAgIGxldCBub25jZUhleCA9IG5vbmNlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAobm9uY2VIZXggPT09IFwiMFwiKSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChub25jZUhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweDBcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1NihlbmNvZGVSbHAoW2Zyb20sIG5vbmNlSGV4XSkpLCAxMikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEUyYGAgb3BlcmF0aW9uXG4gKiAgd2l0aCB0aGUgZ2l2ZW4gJSVmcm9tJSUsICUlc2FsdCUlIGFuZCAlJWluaXRDb2RlSGFzaCUlLlxuICpcbiAqICBUbyBjb21wdXRlIHRoZSAlJWluaXRDb2RlSGFzaCUlIGZyb20gYSBjb250cmFjdCdzIGluaXQgY29kZSwgdXNlXG4gKiAgdGhlIFtba2VjY2FrMjU2XV0gZnVuY3Rpb24uXG4gKlxuICogIEZvciBhIHF1aWNrIG92ZXJ2aWV3IGFuZCBleGFtcGxlIG9mIGBgQ1JFQVRFMmBgLCBzZWUgW1tsaW5rLXJpY21vby13aXNwc11dLlxuICpcbiAqICBAZXhhbXBsZVxuICogICAgLy8gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIlxuICpcbiAqICAgIC8vIFRoZSBzYWx0XG4gKiAgICBzYWx0ID0gaWQoXCJIZWxsb1dvcmxkXCIpXG4gKlxuICogICAgLy8gVGhlIGhhc2ggb2YgdGhlIGluaXRDb2RlXG4gKiAgICBpbml0Q29kZSA9IFwiMHg2Mzk0MTk4ZGYxNjAwMDUyNjEwM2ZmNjAyMDYwMDQ2MDFjMzM1YWZhNjA0MDUxNjA2MGYzXCI7XG4gKiAgICBpbml0Q29kZUhhc2ggPSBrZWNjYWsyNTYoaW5pdENvZGUpXG4gKlxuICogICAgZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoX2Zyb20sIF9zYWx0LCBfaW5pdENvZGVIYXNoKSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3MoX2Zyb20pO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIGNvbnN0IGluaXRDb2RlSGFzaCA9IGdldEJ5dGVzKF9pbml0Q29kZUhhc2gsIFwiaW5pdENvZGVIYXNoXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHNhbHQubGVuZ3RoID09PSAzMiwgXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIF9zYWx0KTtcbiAgICBhc3NlcnRBcmd1bWVudChpbml0Q29kZUhhc2gubGVuZ3RoID09PSAzMiwgXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBfaW5pdENvZGVIYXNoKTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGNvbmNhdChbXCIweGZmXCIsIGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsImNvbmNhdCIsImRhdGFTbGljZSIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZW5jb2RlUmxwIiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsInR4IiwiZnJvbSIsIm5vbmNlIiwibm9uY2VIZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsImdldENyZWF0ZTJBZGRyZXNzIiwiX2Zyb20iLCJfc2FsdCIsIl9pbml0Q29kZUhhc2giLCJzYWx0IiwiaW5pdENvZGVIYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/addresses.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: () => (/* binding */ ZeroAddress)\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */ const ZeroAddress = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BLGNBQWMsNkNBQTZDLENBQ3hFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzPzIzMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCJdLCJuYW1lcyI6WyJaZXJvQWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: () => (/* binding */ ZeroHash)\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */ const ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BLFdBQVcscUVBQXFFLENBQzdGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzPzk3ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gaGFzaC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJaZXJvSGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/contract.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wrappers.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    constructor(contract, fragment, args){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function(...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function(...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function(...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function(...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args)=>{\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function(...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once })=>{\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof target === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_8__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            filters\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n} //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNpQjtBQUNwRSxzRUFBc0U7QUFDdEUseUJBQXlCO0FBQ21DO0FBQ2lHO0FBQ2pCO0FBQzVJLE1BQU1vQixPQUFPQyxPQUFPO0FBQ3BCLFNBQVNDLFFBQVFDLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxZQUFZRixLQUFLO0lBQ3RCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUcsV0FBVyxLQUFNO0FBQ3BEO0FBQ0EsU0FBU0MsV0FBV0osS0FBSztJQUNyQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1LLFdBQVcsS0FBTTtBQUNwRDtBQUNBLFNBQVNDLFFBQVFOLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNTyxlQUFlLEtBQU07QUFDeEQ7QUFDQSxTQUFTQyxZQUFZUixLQUFLO0lBQ3RCLElBQUlBLFNBQVMsTUFBTTtRQUNmLElBQUlJLFdBQVdKLFFBQVE7WUFDbkIsT0FBT0E7UUFDWDtRQUNBLElBQUlBLE1BQU1TLFFBQVEsRUFBRTtZQUNoQixPQUFPVCxNQUFNUyxRQUFRO1FBQ3pCO0lBQ0o7SUFDQSxPQUFPQztBQUNYO0FBQ0EsTUFBTUM7SUFDRixDQUFDQyxNQUFNLENBQUM7SUFFUkMsWUFBWUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksQ0FBRTtRQUNsQ2pDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWdDO1FBQVM7UUFDbEMsSUFBSUEsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSwwREFBMEQ7UUFDMUQsTUFBTUMsU0FBU0MsVUFBVVAsU0FBU00sTUFBTSxFQUFFO1FBQzFDLE1BQU1FLFdBQVdsQixXQUFXZ0IsVUFBVUEsU0FBUztRQUMvQyxJQUFJLENBQUMsQ0FBQ1IsTUFBTSxHQUFHO1lBQ1gsTUFBTVcsZUFBZSxNQUFNQyxRQUFRQyxHQUFHLENBQUNWLFNBQVNFLE1BQU0sQ0FBQ1MsR0FBRyxDQUFDLENBQUNDLE9BQU9DO2dCQUMvRCxNQUFNQyxNQUFNYixJQUFJLENBQUNZLE1BQU07Z0JBQ3ZCLElBQUlDLE9BQU8sTUFBTTtvQkFDYixPQUFPO2dCQUNYO2dCQUNBLE9BQU9GLE1BQU1HLFNBQVMsQ0FBQ2QsSUFBSSxDQUFDWSxNQUFNLEVBQUUsQ0FBQ0csTUFBTS9CO29CQUN2QyxJQUFJK0IsU0FBUyxXQUFXO3dCQUNwQixJQUFJQyxNQUFNQyxPQUFPLENBQUNqQyxRQUFROzRCQUN0QixPQUFPd0IsUUFBUUMsR0FBRyxDQUFDekIsTUFBTTBCLEdBQUcsQ0FBQyxDQUFDUSxJQUFNdEQsaUVBQWNBLENBQUNzRCxHQUFHWjt3QkFDMUQ7d0JBQ0EsT0FBTzFDLGlFQUFjQSxDQUFDb0IsT0FBT3NCO29CQUNqQztvQkFDQSxPQUFPdEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9jLFNBQVNxQixTQUFTLENBQUNDLGtCQUFrQixDQUFDckIsVUFBVVE7UUFDM0Q7SUFDSjtJQUNBYyxpQkFBaUI7UUFDYixPQUFPLElBQUksQ0FBQyxDQUFDekIsTUFBTTtJQUN2QjtBQUNKO0FBQ0EscUNBQXFDO0FBQ3JDLGlFQUFpRTtBQUNqRSw0Q0FBNEM7QUFDNUMsbUVBQW1FO0FBQ25FLHFDQUFxQztBQUNyQyx3SkFBd0o7QUFDeEosU0FBU1MsVUFBVXJCLEtBQUssRUFBRXNDLE9BQU87SUFDN0IsSUFBSXRDLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUksT0FBUUEsS0FBSyxDQUFDc0MsUUFBUSxLQUFNLFlBQVk7UUFDeEMsT0FBT3RDO0lBQ1g7SUFDQSxJQUFJQSxNQUFNUyxRQUFRLElBQUksT0FBUVQsTUFBTVMsUUFBUSxDQUFDNkIsUUFBUSxLQUFNLFlBQVk7UUFDbkUsT0FBT3RDLE1BQU1TLFFBQVE7SUFDekI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTOEIsWUFBWXZDLEtBQUs7SUFDdEIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTVMsUUFBUSxJQUFJO0FBQzdCO0FBQ0E7O0NBRUMsR0FDTSxlQUFlK0IsY0FBY1gsR0FBRyxFQUFFWSxPQUFPO0lBQzVDLGlFQUFpRTtJQUNqRSxNQUFNQyxhQUFhaEUsZ0RBQUtBLENBQUNpRSxXQUFXLENBQUNkLEtBQUs7SUFDMUN0QywrREFBY0EsQ0FBQyxPQUFRbUQsZUFBZ0IsVUFBVSwrQkFBK0IsYUFBYWI7SUFDN0YsNEVBQTRFO0lBQzVFLE1BQU1lLFlBQVkvRCxtRUFBV0EsQ0FBQzZEO0lBQzlCbkQsK0RBQWNBLENBQUNxRCxVQUFVQyxFQUFFLElBQUksUUFBUSxDQUFDSixXQUFXLEVBQUUsRUFBRUssT0FBTyxDQUFDLFNBQVMsR0FBRyxzQkFBc0IsZ0JBQWdCRixVQUFVQyxFQUFFO0lBQzdIdEQsK0RBQWNBLENBQUNxRCxVQUFVRyxJQUFJLElBQUksUUFBUSxDQUFDTixXQUFXLEVBQUUsRUFBRUssT0FBTyxDQUFDLFdBQVcsR0FBRyx3QkFBd0Isa0JBQWtCRixVQUFVRyxJQUFJO0lBQ3ZJLG1CQUFtQjtJQUNuQixJQUFJSCxVQUFVSSxJQUFJLEVBQUU7UUFDaEJKLFVBQVVJLElBQUksR0FBR0osVUFBVUksSUFBSTtJQUNuQztJQUNBLE9BQU9KO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLGVBQWVLLFlBQVlDLE9BQU8sRUFBRWpDLE1BQU0sRUFBRUQsSUFBSTtJQUNuRCwwREFBMEQ7SUFDMUQsTUFBTUksU0FBU0MsVUFBVTZCLFNBQVM7SUFDbEMsTUFBTTVCLFdBQVdsQixXQUFXZ0IsVUFBVUEsU0FBUztJQUMvQyxPQUFPLE1BQU1JLFFBQVFDLEdBQUcsQ0FBQ1IsT0FBT1MsR0FBRyxDQUFDLENBQUNDLE9BQU9DO1FBQ3hDLE9BQU9ELE1BQU1HLFNBQVMsQ0FBQ2QsSUFBSSxDQUFDWSxNQUFNLEVBQUUsQ0FBQ0csTUFBTS9CO1lBQ3ZDQSxRQUFRdEIsZ0RBQUtBLENBQUNpRSxXQUFXLENBQUMzQyxPQUFPK0I7WUFDakMsSUFBSUEsU0FBUyxXQUFXO2dCQUNwQixPQUFPbkQsaUVBQWNBLENBQUNvQixPQUFPc0I7WUFDakM7WUFDQSxPQUFPdEI7UUFDWDtJQUNKO0FBQ0o7QUFDQSxTQUFTbUQscUJBQXFCckMsUUFBUTtJQUNsQyxNQUFNc0Msc0JBQXNCLGVBQWdCUixTQUFTO1FBQ2pELGtFQUFrRTtRQUNsRSxNQUFNUyxLQUFNLE1BQU1iLGNBQWNJLFdBQVc7WUFBQztTQUFPO1FBQ25EUyxHQUFHUixFQUFFLEdBQUcsTUFBTS9CLFNBQVN3QyxVQUFVO1FBQ2pDLElBQUlELEdBQUdMLElBQUksRUFBRTtZQUNUSyxHQUFHTCxJQUFJLEdBQUcsTUFBTXBFLGlFQUFjQSxDQUFDeUUsR0FBR0wsSUFBSSxFQUFFeEMsWUFBWU0sU0FBU00sTUFBTTtRQUN2RTtRQUNBLE1BQU1tQyxRQUFRekMsU0FBU3FCLFNBQVM7UUFDaEMsTUFBTXFCLFVBQVd4RSwwREFBU0EsQ0FBRXFFLEdBQUdyRCxLQUFLLElBQUlILE1BQU8sdUJBQXVCQTtRQUN0RSxNQUFNNEQsU0FBVSxDQUFDSixHQUFHTixJQUFJLElBQUksSUFBRyxNQUFPO1FBQ3RDLElBQUlRLE1BQU1HLFFBQVEsSUFBSSxDQUFDSCxNQUFNRyxRQUFRLENBQUNDLE9BQU8sSUFBSUosTUFBTUssT0FBTyxJQUFJLENBQUNILFVBQVUsQ0FBQ0QsU0FBUztZQUNuRmpFLCtEQUFjQSxDQUFDLE9BQU8scUVBQXFFLGFBQWFxRDtRQUM1RztRQUNBckQsK0RBQWNBLENBQUNnRSxNQUFNRyxRQUFRLElBQUlELFFBQVEsNkNBQTZDLGtCQUFrQkosR0FBR04sSUFBSTtRQUMvRyxxREFBcUQ7UUFDckQsTUFBTVksVUFBVUosTUFBTUssT0FBTyxJQUFLTCxNQUFNRyxRQUFRLElBQUlILE1BQU1HLFFBQVEsQ0FBQ0MsT0FBTztRQUMxRXBFLCtEQUFjQSxDQUFDb0UsV0FBV0gsU0FBUyw2Q0FBNkMsbUJBQW1CSCxHQUFHckQsS0FBSztRQUMzRyxzREFBc0Q7UUFDdERULCtEQUFjQSxDQUFDZ0UsTUFBTUcsUUFBUSxJQUFJRCxRQUFRLDZDQUE2QyxrQkFBa0JKLEdBQUdOLElBQUk7UUFDL0csT0FBT007SUFDWDtJQUNBLE1BQU1RLGFBQWEsZUFBZ0JqQixTQUFTO1FBQ3hDLE1BQU14QixTQUFTQyxVQUFVUCxTQUFTTSxNQUFNLEVBQUU7UUFDMUM5Qix1REFBTUEsQ0FBQ1MsUUFBUXFCLFNBQVMsNENBQTRDLHlCQUF5QjtZQUFFMEMsV0FBVztRQUFPO1FBQ2pILE1BQU1ULEtBQUssTUFBTUQsb0JBQW9CUjtRQUNyQyxJQUFJO1lBQ0EsT0FBTyxNQUFNeEIsT0FBT25CLElBQUksQ0FBQ29EO1FBQzdCLEVBQ0EsT0FBT1UsT0FBTztZQUNWLElBQUk5RSxnRUFBZUEsQ0FBQzhFLFVBQVVBLE1BQU1oQixJQUFJLEVBQUU7Z0JBQ3RDLE1BQU1qQyxTQUFTcUIsU0FBUyxDQUFDOUMsU0FBUyxDQUFDMEUsTUFBTWhCLElBQUksRUFBRU07WUFDbkQ7WUFDQSxNQUFNVTtRQUNWO0lBQ0o7SUFDQSxNQUFNQyxPQUFPLGVBQWdCcEIsU0FBUztRQUNsQyxNQUFNeEIsU0FBU04sU0FBU00sTUFBTTtRQUM5QjlCLHVEQUFNQSxDQUFDZ0IsUUFBUWMsU0FBUyx5REFBeUQseUJBQXlCO1lBQUUwQyxXQUFXO1FBQWtCO1FBQ3pJLE1BQU1ULEtBQUssTUFBTWpDLE9BQU9iLGVBQWUsQ0FBQyxNQUFNNkMsb0JBQW9CUjtRQUNsRSxNQUFNbkMsV0FBVzhCLFlBQVl6QixTQUFTTSxNQUFNO1FBQzVDLGtGQUFrRjtRQUNsRixtQkFBbUI7UUFDbkIsT0FBTyxJQUFJMUIscUVBQTJCQSxDQUFDb0IsU0FBU3FCLFNBQVMsRUFBRTFCLFVBQVU0QztJQUN6RTtJQUNBLE1BQU1sRCxjQUFjLGVBQWdCeUMsU0FBUztRQUN6QyxNQUFNeEIsU0FBU0MsVUFBVVAsU0FBU00sTUFBTSxFQUFFO1FBQzFDOUIsdURBQU1BLENBQUNZLFlBQVlrQixTQUFTLG1EQUFtRCx5QkFBeUI7WUFBRTBDLFdBQVc7UUFBYztRQUNuSSxPQUFPLE1BQU0xQyxPQUFPakIsV0FBVyxDQUFDLE1BQU1pRCxvQkFBb0JSO0lBQzlEO0lBQ0EsTUFBTXFCLFNBQVMsT0FBT3JCO1FBQ2xCLE9BQU8sTUFBTW9CLEtBQUtwQjtJQUN0QjtJQUNBN0QsaUVBQWdCQSxDQUFDa0YsUUFBUTtRQUNyQkMsV0FBV3BEO1FBQ1hYO1FBQ0FpRDtRQUNBWTtRQUFNSDtJQUNWO0lBQ0EsT0FBT0k7QUFDWDtBQUNBLFNBQVNFLG1CQUFtQnJELFFBQVEsRUFBRXNELEdBQUc7SUFDckMsTUFBTUMsY0FBYyxTQUFVLEdBQUdyRCxJQUFJO1FBQ2pDLE1BQU1ELFdBQVdELFNBQVNxQixTQUFTLENBQUNtQyxXQUFXLENBQUNGLEtBQUtwRDtRQUNyRDFCLHVEQUFNQSxDQUFDeUIsVUFBVSx3QkFBd0IseUJBQXlCO1lBQzlEK0MsV0FBVztZQUNYUyxNQUFNO2dCQUFFSDtnQkFBS3BEO1lBQUs7UUFDdEI7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsTUFBTXFDLHNCQUFzQixlQUFnQixHQUFHcEMsSUFBSTtRQUMvQyxNQUFNRCxXQUFXc0QsZUFBZXJEO1FBQ2hDLGtFQUFrRTtRQUNsRSxJQUFJNEIsWUFBWSxDQUFDO1FBQ2pCLElBQUk3QixTQUFTRSxNQUFNLENBQUNDLE1BQU0sR0FBRyxNQUFNRixLQUFLRSxNQUFNLEVBQUU7WUFDNUMwQixZQUFZLE1BQU1KLGNBQWN4QixLQUFLd0QsR0FBRztZQUN4QyxJQUFJNUIsVUFBVUksSUFBSSxFQUFFO2dCQUNoQkosVUFBVUksSUFBSSxHQUFHLE1BQU1wRSxpRUFBY0EsQ0FBQ2dFLFVBQVVJLElBQUksRUFBRXhDLFlBQVlNLFNBQVNNLE1BQU07WUFDckY7UUFDSjtRQUNBLElBQUlMLFNBQVNFLE1BQU0sQ0FBQ0MsTUFBTSxLQUFLRixLQUFLRSxNQUFNLEVBQUU7WUFDeEMsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsTUFBTUksZUFBZSxNQUFNMEIsWUFBWW5DLFNBQVNNLE1BQU0sRUFBRUwsU0FBU0UsTUFBTSxFQUFFRDtRQUN6RSxPQUFPeUQsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRzlCLFdBQVcsTUFBTXpELGtFQUFpQkEsQ0FBQztZQUN4RDBELElBQUkvQixTQUFTd0MsVUFBVTtZQUN2QlAsTUFBTWpDLFNBQVNxQixTQUFTLENBQUN3QyxrQkFBa0IsQ0FBQzVELFVBQVVRO1FBQzFEO0lBQ0o7SUFDQSxNQUFNc0MsYUFBYSxlQUFnQixHQUFHN0MsSUFBSTtRQUN0QyxNQUFNNEQsU0FBUyxNQUFNQyxvQkFBb0I3RDtRQUN6QyxJQUFJNEQsT0FBTzFELE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE9BQU8wRCxNQUFNLENBQUMsRUFBRTtRQUNwQjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxNQUFNWixPQUFPLGVBQWdCLEdBQUdoRCxJQUFJO1FBQ2hDLE1BQU1JLFNBQVNOLFNBQVNNLE1BQU07UUFDOUI5Qix1REFBTUEsQ0FBQ2dCLFFBQVFjLFNBQVMseURBQXlELHlCQUF5QjtZQUFFMEMsV0FBVztRQUFrQjtRQUN6SSxNQUFNVCxLQUFLLE1BQU1qQyxPQUFPYixlQUFlLENBQUMsTUFBTTZDLHVCQUF1QnBDO1FBQ3JFLE1BQU1QLFdBQVc4QixZQUFZekIsU0FBU00sTUFBTTtRQUM1QyxrRkFBa0Y7UUFDbEYsbUJBQW1CO1FBQ25CLE9BQU8sSUFBSTFCLHFFQUEyQkEsQ0FBQ29CLFNBQVNxQixTQUFTLEVBQUUxQixVQUFVNEM7SUFDekU7SUFDQSxNQUFNbEQsY0FBYyxlQUFnQixHQUFHYSxJQUFJO1FBQ3ZDLE1BQU1JLFNBQVNDLFVBQVVQLFNBQVNNLE1BQU0sRUFBRTtRQUMxQzlCLHVEQUFNQSxDQUFDWSxZQUFZa0IsU0FBUyxtREFBbUQseUJBQXlCO1lBQUUwQyxXQUFXO1FBQWM7UUFDbkksT0FBTyxNQUFNMUMsT0FBT2pCLFdBQVcsQ0FBQyxNQUFNaUQsdUJBQXVCcEM7SUFDakU7SUFDQSxNQUFNNkQsbUJBQW1CLGVBQWdCLEdBQUc3RCxJQUFJO1FBQzVDLE1BQU1JLFNBQVNDLFVBQVVQLFNBQVNNLE1BQU0sRUFBRTtRQUMxQzlCLHVEQUFNQSxDQUFDUyxRQUFRcUIsU0FBUyw0Q0FBNEMseUJBQXlCO1lBQUUwQyxXQUFXO1FBQU87UUFDakgsTUFBTVQsS0FBSyxNQUFNRCx1QkFBdUJwQztRQUN4QyxJQUFJNEQsU0FBUztRQUNiLElBQUk7WUFDQUEsU0FBUyxNQUFNeEQsT0FBT25CLElBQUksQ0FBQ29EO1FBQy9CLEVBQ0EsT0FBT1UsT0FBTztZQUNWLElBQUk5RSxnRUFBZUEsQ0FBQzhFLFVBQVVBLE1BQU1oQixJQUFJLEVBQUU7Z0JBQ3RDLE1BQU1qQyxTQUFTcUIsU0FBUyxDQUFDOUMsU0FBUyxDQUFDMEUsTUFBTWhCLElBQUksRUFBRU07WUFDbkQ7WUFDQSxNQUFNVTtRQUNWO1FBQ0EsTUFBTWhELFdBQVdzRCxlQUFlckQ7UUFDaEMsT0FBT0YsU0FBU3FCLFNBQVMsQ0FBQzJDLG9CQUFvQixDQUFDL0QsVUFBVTZEO0lBQzdEO0lBQ0EsTUFBTVgsU0FBUyxPQUFPLEdBQUdqRDtRQUNyQixNQUFNRCxXQUFXc0QsZUFBZXJEO1FBQ2hDLElBQUlELFNBQVNnRSxRQUFRLEVBQUU7WUFDbkIsT0FBTyxNQUFNbEIsY0FBYzdDO1FBQy9CO1FBQ0EsT0FBTyxNQUFNZ0QsUUFBUWhEO0lBQ3pCO0lBQ0FqQyxpRUFBZ0JBLENBQUNrRixRQUFRO1FBQ3JCZSxNQUFNbEUsU0FBU3FCLFNBQVMsQ0FBQzhDLGVBQWUsQ0FBQ2I7UUFDekNGLFdBQVdwRDtRQUFVb0UsTUFBTWQ7UUFDM0JDO1FBQ0FsRTtRQUNBaUQ7UUFDQVk7UUFBTUg7UUFBWWdCO0lBQ3RCO0lBQ0EsOEVBQThFO0lBQzlFSixPQUFPVSxjQUFjLENBQUNsQixRQUFRLFlBQVk7UUFDdENtQixjQUFjO1FBQ2RDLFlBQVk7UUFDWkMsS0FBSztZQUNELE1BQU12RSxXQUFXRCxTQUFTcUIsU0FBUyxDQUFDbUMsV0FBVyxDQUFDRjtZQUNoRDlFLHVEQUFNQSxDQUFDeUIsVUFBVSx3QkFBd0IseUJBQXlCO2dCQUM5RCtDLFdBQVc7Z0JBQ1hTLE1BQU07b0JBQUVIO2dCQUFJO1lBQ2hCO1lBQ0EsT0FBT3JEO1FBQ1g7SUFDSjtJQUNBLE9BQU9rRDtBQUNYO0FBQ0EsU0FBU3NCLGtCQUFrQnpFLFFBQVEsRUFBRXNELEdBQUc7SUFDcEMsTUFBTUMsY0FBYyxTQUFVLEdBQUdyRCxJQUFJO1FBQ2pDLE1BQU1ELFdBQVdELFNBQVNxQixTQUFTLENBQUNxRCxRQUFRLENBQUNwQixLQUFLcEQ7UUFDbEQxQix1REFBTUEsQ0FBQ3lCLFVBQVUsd0JBQXdCLHlCQUF5QjtZQUM5RCtDLFdBQVc7WUFDWFMsTUFBTTtnQkFBRUg7Z0JBQUtwRDtZQUFLO1FBQ3RCO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLE1BQU1rRCxTQUFTLFNBQVUsR0FBR2pELElBQUk7UUFDNUIsT0FBTyxJQUFJTCxvQkFBb0JHLFVBQVV1RCxlQUFlckQsT0FBT0E7SUFDbkU7SUFDQWpDLGlFQUFnQkEsQ0FBQ2tGLFFBQVE7UUFDckJlLE1BQU1sRSxTQUFTcUIsU0FBUyxDQUFDc0QsWUFBWSxDQUFDckI7UUFDdENGLFdBQVdwRDtRQUFVb0UsTUFBTWQ7UUFDM0JDO0lBQ0o7SUFDQSw4RUFBOEU7SUFDOUVJLE9BQU9VLGNBQWMsQ0FBQ2xCLFFBQVEsWUFBWTtRQUN0Q21CLGNBQWM7UUFDZEMsWUFBWTtRQUNaQyxLQUFLO1lBQ0QsTUFBTXZFLFdBQVdELFNBQVNxQixTQUFTLENBQUNxRCxRQUFRLENBQUNwQjtZQUM3QzlFLHVEQUFNQSxDQUFDeUIsVUFBVSx3QkFBd0IseUJBQXlCO2dCQUM5RCtDLFdBQVc7Z0JBQ1hTLE1BQU07b0JBQUVIO2dCQUFJO1lBQ2hCO1lBQ0EsT0FBT3JEO1FBQ1g7SUFDSjtJQUNBLE9BQU9rRDtBQUNYO0FBQ0Esa0VBQWtFO0FBQ2xFLHFFQUFxRTtBQUNyRSxtRUFBbUU7QUFDbkUsaUVBQWlFO0FBQ2pFLE1BQU15QixXQUFXQyxPQUFPQyxHQUFHLENBQUM7QUFDNUIsTUFBTUMsaUJBQWlCLElBQUlDO0FBQzNCLFNBQVNDLFlBQVlqRixRQUFRLEVBQUVrRixNQUFNO0lBQ2pDSCxlQUFlSSxHQUFHLENBQUNuRixRQUFRLENBQUM0RSxTQUFTLEVBQUVNO0FBQzNDO0FBQ0EsU0FBU0UsWUFBWXBGLFFBQVE7SUFDekIsT0FBTytFLGVBQWVQLEdBQUcsQ0FBQ3hFLFFBQVEsQ0FBQzRFLFNBQVM7QUFDaEQ7QUFDQSxTQUFTUyxXQUFXbkcsS0FBSztJQUNyQixPQUFRQSxTQUFTLE9BQVFBLFVBQVcsWUFBYSxvQkFBb0JBLFNBQ2hFLE9BQVFBLE1BQU1xQyxjQUFjLEtBQU0sY0FBZXJDLE1BQU1lLFFBQVE7QUFDeEU7QUFDQSxlQUFlcUYsV0FBV3RGLFFBQVEsRUFBRXVGLEtBQUs7SUFDckMsSUFBSUM7SUFDSixJQUFJdkYsV0FBVztJQUNmLDZEQUE2RDtJQUM3RCxvQ0FBb0M7SUFDcEMsSUFBSWlCLE1BQU1DLE9BQU8sQ0FBQ29FLFFBQVE7UUFDdEIsTUFBTUUsZUFBZSxTQUFVdkIsSUFBSTtZQUMvQixJQUFJOUYsNERBQVdBLENBQUM4RixNQUFNLEtBQUs7Z0JBQ3ZCLE9BQU9BO1lBQ1g7WUFDQSxNQUFNakUsV0FBV0QsU0FBU3FCLFNBQVMsQ0FBQ3FELFFBQVEsQ0FBQ1I7WUFDN0N6RiwrREFBY0EsQ0FBQ3dCLFVBQVUsb0JBQW9CLFFBQVFpRTtZQUNyRCxPQUFPakUsU0FBU3lGLFNBQVM7UUFDN0I7UUFDQSw2RUFBNkU7UUFDN0VGLFNBQVNELE1BQU0zRSxHQUFHLENBQUMsQ0FBQytFO1lBQ2hCLElBQUlBLEtBQUssTUFBTTtnQkFDWCxPQUFPO1lBQ1g7WUFDQSxJQUFJekUsTUFBTUMsT0FBTyxDQUFDd0UsSUFBSTtnQkFDbEIsT0FBT0EsRUFBRS9FLEdBQUcsQ0FBQzZFO1lBQ2pCO1lBQ0EsT0FBT0EsYUFBYUU7UUFDeEI7SUFDSixPQUNLLElBQUlKLFVBQVUsS0FBSztRQUNwQkMsU0FBUztZQUFDO1NBQUs7SUFDbkIsT0FDSyxJQUFJLE9BQVFELFVBQVcsVUFBVTtRQUNsQyxJQUFJbkgsNERBQVdBLENBQUNtSCxPQUFPLEtBQUs7WUFDeEIsYUFBYTtZQUNiQyxTQUFTO2dCQUFDRDthQUFNO1FBQ3BCLE9BQ0s7WUFDRCw2REFBNkQ7WUFDN0R0RixXQUFXRCxTQUFTcUIsU0FBUyxDQUFDcUQsUUFBUSxDQUFDYTtZQUN2QzlHLCtEQUFjQSxDQUFDd0IsVUFBVSxvQkFBb0IsU0FBU3NGO1lBQ3REQyxTQUFTO2dCQUFDdkYsU0FBU3lGLFNBQVM7YUFBQztRQUNqQztJQUNKLE9BQ0ssSUFBSUwsV0FBV0UsUUFBUTtRQUN4QiwrREFBK0Q7UUFDL0RDLFNBQVMsTUFBTUQsTUFBTWhFLGNBQWM7SUFDdkMsT0FDSyxJQUFJLGNBQWNnRSxPQUFPO1FBQzFCLGlEQUFpRDtRQUNqRHRGLFdBQVdzRixNQUFNdEYsUUFBUTtRQUN6QnVGLFNBQVM7WUFBQ3ZGLFNBQVN5RixTQUFTO1NBQUM7SUFDakMsT0FDSztRQUNEakgsK0RBQWNBLENBQUMsT0FBTyxzQkFBc0IsU0FBUzhHO0lBQ3pEO0lBQ0Esc0NBQXNDO0lBQ3RDQyxTQUFTQSxPQUFPNUUsR0FBRyxDQUFDLENBQUNnRjtRQUNqQixJQUFJQSxLQUFLLE1BQU07WUFDWCxPQUFPO1FBQ1g7UUFDQSxJQUFJMUUsTUFBTUMsT0FBTyxDQUFDeUUsSUFBSTtZQUNsQixNQUFNQyxRQUFRM0UsTUFBTWdCLElBQUksQ0FBQyxJQUFJNEQsSUFBSUYsRUFBRWhGLEdBQUcsQ0FBQyxDQUFDZ0YsSUFBTUEsRUFBRUcsV0FBVyxLQUFLYixNQUFNO1lBQ3RFLElBQUlXLE1BQU16RixNQUFNLEtBQUssR0FBRztnQkFDcEIsT0FBT3lGLEtBQUssQ0FBQyxFQUFFO1lBQ25CO1lBQ0FBLE1BQU1HLElBQUk7WUFDVixPQUFPSDtRQUNYO1FBQ0EsT0FBT0QsRUFBRUcsV0FBVztJQUN4QjtJQUNBLE1BQU1FLE1BQU1ULE9BQU81RSxHQUFHLENBQUMsQ0FBQ2dGO1FBQ3BCLElBQUlBLEtBQUssTUFBTTtZQUNYLE9BQU87UUFDWDtRQUNBLElBQUkxRSxNQUFNQyxPQUFPLENBQUN5RSxJQUFJO1lBQ2xCLE9BQU9BLEVBQUVNLElBQUksQ0FBQztRQUNsQjtRQUNBLE9BQU9OO0lBQ1gsR0FBR00sSUFBSSxDQUFDO0lBQ1IsT0FBTztRQUFFakc7UUFBVWdHO1FBQUtUO0lBQU87QUFDbkM7QUFDQSxlQUFlVyxPQUFPbkcsUUFBUSxFQUFFdUYsS0FBSztJQUNqQyxNQUFNLEVBQUVhLElBQUksRUFBRSxHQUFHaEIsWUFBWXBGO0lBQzdCLE9BQU9vRyxLQUFLNUIsR0FBRyxDQUFDLENBQUMsTUFBTWMsV0FBV3RGLFVBQVV1RixNQUFLLEVBQUdVLEdBQUcsS0FBSztBQUNoRTtBQUNBLGVBQWVJLE9BQU9yRyxRQUFRLEVBQUVnRCxTQUFTLEVBQUV1QyxLQUFLO0lBQzVDLHdEQUF3RDtJQUN4RCxNQUFNNUYsV0FBVzhCLFlBQVl6QixTQUFTTSxNQUFNO0lBQzVDOUIsdURBQU1BLENBQUNtQixVQUFVLGdEQUFnRCx5QkFBeUI7UUFBRXFEO0lBQVU7SUFDdEcsTUFBTSxFQUFFL0MsUUFBUSxFQUFFZ0csR0FBRyxFQUFFVCxNQUFNLEVBQUUsR0FBRyxNQUFNRixXQUFXdEYsVUFBVXVGO0lBQzdELE1BQU0sRUFBRWUsSUFBSSxFQUFFRixJQUFJLEVBQUUsR0FBR2hCLFlBQVlwRjtJQUNuQyxJQUFJdUcsTUFBTUgsS0FBSzVCLEdBQUcsQ0FBQ3lCO0lBQ25CLElBQUksQ0FBQ00sS0FBSztRQUNOLE1BQU1DLFVBQVdGLE9BQU9BLE9BQU90RztRQUMvQixNQUFNRixTQUFTO1lBQUUwRztZQUFTaEI7UUFBTztRQUNqQyxNQUFNaUIsV0FBVyxDQUFDQztZQUNkLElBQUlDLGdCQUFnQjFHO1lBQ3BCLElBQUkwRyxpQkFBaUIsTUFBTTtnQkFDdkIsSUFBSTtvQkFDQUEsZ0JBQWdCM0csU0FBU3FCLFNBQVMsQ0FBQ3FELFFBQVEsQ0FBQ2dDLElBQUlsQixNQUFNLENBQUMsRUFBRTtnQkFDN0QsRUFDQSxPQUFPdkMsT0FBTyxDQUFFO1lBQ3BCO1lBQ0EsOERBQThEO1lBQzlELElBQUkwRCxlQUFlO2dCQUNmLE1BQU1DLGlCQUFpQkQ7Z0JBQ3ZCLE1BQU16RyxPQUFPRCxXQUFXRCxTQUFTcUIsU0FBUyxDQUFDd0YsY0FBYyxDQUFDNUcsVUFBVXlHLElBQUl6RSxJQUFJLEVBQUV5RSxJQUFJbEIsTUFBTSxJQUFJLEVBQUU7Z0JBQzlGc0IsS0FBSzlHLFVBQVV1RixPQUFPckYsTUFBTSxDQUFDdUc7b0JBQ3pCLE9BQU8sSUFBSS9ILDhEQUFvQkEsQ0FBQ3NCLFVBQVV5RyxVQUFVbEIsT0FBT3FCLGdCQUFnQkY7Z0JBQy9FO1lBQ0osT0FDSztnQkFDREksS0FBSzlHLFVBQVV1RixPQUFPLEVBQUUsRUFBRSxDQUFDa0I7b0JBQ3ZCLE9BQU8sSUFBSTlILHFFQUEyQkEsQ0FBQ3FCLFVBQVV5RyxVQUFVbEIsT0FBT21CO2dCQUN0RTtZQUNKO1FBQ0o7UUFDQSxJQUFJSyxXQUFXLEVBQUU7UUFDakIsTUFBTUMsUUFBUTtZQUNWLElBQUlELFNBQVMzRyxNQUFNLEVBQUU7Z0JBQ2pCO1lBQ0o7WUFDQTJHLFNBQVNFLElBQUksQ0FBQ3RILFNBQVN1SCxFQUFFLENBQUNwSCxRQUFRMkc7UUFDdEM7UUFDQSxNQUFNVSxPQUFPO1lBQ1QsSUFBSUosU0FBUzNHLE1BQU0sSUFBSSxHQUFHO2dCQUN0QjtZQUNKO1lBQ0EsSUFBSWdILFVBQVVMO1lBQ2RBLFdBQVcsRUFBRTtZQUNiLE1BQU1yRyxRQUFRQyxHQUFHLENBQUN5RztZQUNsQnpILFNBQVMwSCxHQUFHLENBQUN2SCxRQUFRMkc7UUFDekI7UUFDQUYsTUFBTTtZQUFFTjtZQUFLcUIsV0FBVyxFQUFFO1lBQUVOO1lBQU9HO1FBQUs7UUFDeENmLEtBQUtqQixHQUFHLENBQUNjLEtBQUtNO0lBQ2xCO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLG9FQUFvRTtBQUNwRSxvRUFBb0U7QUFDcEUsOENBQThDO0FBQzlDLElBQUlnQixXQUFXN0csUUFBUThHLE9BQU87QUFDOUIsZUFBZUMsTUFBTXpILFFBQVEsRUFBRXVGLEtBQUssRUFBRXJGLElBQUksRUFBRXdILFdBQVc7SUFDbkQsTUFBTUg7SUFDTixNQUFNaEIsTUFBTSxNQUFNSixPQUFPbkcsVUFBVXVGO0lBQ25DLElBQUksQ0FBQ2dCLEtBQUs7UUFDTixPQUFPO0lBQ1g7SUFDQSxNQUFNb0IsUUFBUXBCLElBQUllLFNBQVMsQ0FBQ2xILE1BQU07SUFDbENtRyxJQUFJZSxTQUFTLEdBQUdmLElBQUllLFNBQVMsQ0FBQ3hILE1BQU0sQ0FBQyxDQUFDLEVBQUUyRyxRQUFRLEVBQUVtQixJQUFJLEVBQUU7UUFDcEQsTUFBTUMsV0FBVzNHLE1BQU1nQixJQUFJLENBQUNoQztRQUM1QixJQUFJd0gsYUFBYTtZQUNiRyxTQUFTWixJQUFJLENBQUNTLFlBQVlFLE9BQU8sT0FBT25CO1FBQzVDO1FBQ0EsSUFBSTtZQUNBQSxTQUFTdEgsSUFBSSxDQUFDYSxhQUFhNkg7UUFDL0IsRUFDQSxPQUFPNUUsT0FBTyxDQUFFO1FBQ2hCLE9BQU8sQ0FBQzJFO0lBQ1o7SUFDQSxJQUFJckIsSUFBSWUsU0FBUyxDQUFDbEgsTUFBTSxLQUFLLEdBQUc7UUFDNUJtRyxJQUFJWSxJQUFJO1FBQ1IvQixZQUFZcEYsVUFBVW9HLElBQUksQ0FBQzBCLE1BQU0sQ0FBQ3ZCLElBQUlOLEdBQUc7SUFDN0M7SUFDQSxPQUFRMEIsUUFBUTtBQUNwQjtBQUNBLGVBQWViLEtBQUs5RyxRQUFRLEVBQUV1RixLQUFLLEVBQUVyRixJQUFJLEVBQUV3SCxXQUFXO0lBQ2xELElBQUk7UUFDQSxNQUFNSDtJQUNWLEVBQ0EsT0FBT3RFLE9BQU8sQ0FBRTtJQUNoQixNQUFNOEUsZ0JBQWdCTixNQUFNekgsVUFBVXVGLE9BQU9yRixNQUFNd0g7SUFDbkRILFdBQVdRO0lBQ1gsT0FBTyxNQUFNQTtBQUNqQjtBQUNBLE1BQU1DLGlCQUFpQjtJQUFDO0NBQU87QUFDeEIsTUFBTUM7SUFpQ1Q7Ozs7S0FJQyxHQUNEbEksWUFBWW1JLE1BQU0sRUFBRUMsR0FBRyxFQUFFN0gsTUFBTSxFQUFFOEgsU0FBUyxDQUFFO1FBQ3hDM0osK0RBQWNBLENBQUMsT0FBUXlKLFdBQVksWUFBWXJLLGdFQUFhQSxDQUFDcUssU0FBUyxxQ0FBcUMsVUFBVUE7UUFDckgsSUFBSTVILFVBQVUsTUFBTTtZQUNoQkEsU0FBUztRQUNiO1FBQ0EsTUFBTW1DLFFBQVE5RSxvREFBU0EsQ0FBQ3VFLElBQUksQ0FBQ2lHO1FBQzdCbEssaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFaUs7WUFBUTVIO1lBQVFlLFdBQVdvQjtRQUFNO1FBQzFEa0IsT0FBT1UsY0FBYyxDQUFDLElBQUksRUFBRU8sVUFBVTtZQUFFMUYsT0FBTyxDQUFDO1FBQUU7UUFDbEQsSUFBSW1KO1FBQ0osSUFBSS9CLE9BQU87UUFDWCxJQUFJZ0MsV0FBVztRQUNmLElBQUlGLFdBQVc7WUFDWCxNQUFNekksV0FBVzhCLFlBQVluQjtZQUM3QixrRkFBa0Y7WUFDbEYsbUJBQW1CO1lBQ25CZ0ksV0FBVyxJQUFJMUoscUVBQTJCQSxDQUFDLElBQUksQ0FBQ3lDLFNBQVMsRUFBRTFCLFVBQVV5STtRQUN6RTtRQUNBLElBQUloQyxPQUFPLElBQUltQztRQUNmLG9DQUFvQztRQUNwQyxJQUFJLE9BQVFMLFdBQVksVUFBVTtZQUM5QixJQUFJOUosNERBQVdBLENBQUM4SixTQUFTO2dCQUNyQjVCLE9BQU80QjtnQkFDUEcsY0FBYzNILFFBQVE4RyxPQUFPLENBQUNVO1lBQ2xDLE9BQ0s7Z0JBQ0QsTUFBTTFILFdBQVdELFVBQVVELFFBQVE7Z0JBQ25DLElBQUksQ0FBQ2hCLFdBQVdrQixXQUFXO29CQUN2QixNQUFNakMsMERBQVNBLENBQUMsb0RBQW9ELHlCQUF5Qjt3QkFDekZ5RSxXQUFXO29CQUNmO2dCQUNKO2dCQUNBcUYsY0FBYzdILFNBQVNqQixXQUFXLENBQUMySSxRQUFRTSxJQUFJLENBQUMsQ0FBQ2xDO29CQUM3QyxJQUFJQSxRQUFRLE1BQU07d0JBQ2QsTUFBTS9ILDBEQUFTQSxDQUFDLHVFQUF1RSxxQkFBcUI7NEJBQ3hHVyxPQUFPZ0o7d0JBQ1g7b0JBQ0o7b0JBQ0E5QyxZQUFZLElBQUksRUFBRWtCLElBQUksR0FBR0E7b0JBQ3pCLE9BQU9BO2dCQUNYO1lBQ0o7UUFDSixPQUNLO1lBQ0QrQixjQUFjSCxPQUFPMUYsVUFBVSxHQUFHZ0csSUFBSSxDQUFDLENBQUNsQztnQkFDcEMsSUFBSUEsUUFBUSxNQUFNO29CQUNkLE1BQU0sSUFBSWpHLE1BQU07Z0JBQ3BCO2dCQUNBK0UsWUFBWSxJQUFJLEVBQUVrQixJQUFJLEdBQUdBO2dCQUN6QixPQUFPQTtZQUNYO1FBQ0o7UUFDQSx5QkFBeUI7UUFDekJyQixZQUFZLElBQUksRUFBRTtZQUFFb0Q7WUFBYS9CO1lBQU1nQztZQUFVbEM7UUFBSztRQUN0RCx3QkFBd0I7UUFDeEIsTUFBTXFDLFVBQVUsSUFBSUMsTUFBTSxDQUFDLEdBQUc7WUFDMUJsRSxLQUFLLENBQUMwRCxRQUFRUyxNQUFNQztnQkFDaEIsMERBQTBEO2dCQUMxRCxJQUFJLE9BQVFELFNBQVUsWUFBWVgsZUFBZWhHLE9BQU8sQ0FBQzJHLFNBQVMsR0FBRztvQkFDakUsT0FBT0UsUUFBUXJFLEdBQUcsQ0FBQzBELFFBQVFTLE1BQU1DO2dCQUNyQztnQkFDQSxJQUFJO29CQUNBLE9BQU8sSUFBSSxDQUFDbEUsUUFBUSxDQUFDaUU7Z0JBQ3pCLEVBQ0EsT0FBTzFGLE9BQU87b0JBQ1YsSUFBSSxDQUFDM0Usd0RBQU9BLENBQUMyRSxPQUFPLHVCQUF1QkEsTUFBTTZGLFFBQVEsS0FBSyxPQUFPO3dCQUNqRSxNQUFNN0Y7b0JBQ1Y7Z0JBQ0o7Z0JBQ0EsT0FBT3JEO1lBQ1g7WUFDQW1KLEtBQUssQ0FBQ2IsUUFBUVM7Z0JBQ1YsMERBQTBEO2dCQUMxRCxJQUFJWCxlQUFlaEcsT0FBTyxDQUFDMkcsU0FBUyxHQUFHO29CQUNuQyxPQUFPRSxRQUFRRSxHQUFHLENBQUNiLFFBQVFTO2dCQUMvQjtnQkFDQSxPQUFPRSxRQUFRRSxHQUFHLENBQUNiLFFBQVFTLFNBQVMsSUFBSSxDQUFDdEgsU0FBUyxDQUFDMkgsUUFBUSxDQUFDQyxPQUFPTjtZQUN2RTtRQUNKO1FBQ0ExSyxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUV3SztRQUFRO1FBQ2pDeEssaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQjJFLFVBQVcsTUFBT0UsT0FBTyxJQUFJTCxNQUFNRyxRQUFRLEdBQUtQLHFCQUFxQixJQUFJLElBQUs7UUFDbEY7UUFDQSxnREFBZ0Q7UUFDaEQsT0FBTyxJQUFJcUcsTUFBTSxJQUFJLEVBQUU7WUFDbkJsRSxLQUFLLENBQUMwRCxRQUFRUyxNQUFNQztnQkFDaEIsSUFBSSxPQUFRRCxTQUFVLFlBQVlBLFFBQVFULFVBQVVGLGVBQWVoRyxPQUFPLENBQUMyRyxTQUFTLEdBQUc7b0JBQ25GLE9BQU9FLFFBQVFyRSxHQUFHLENBQUMwRCxRQUFRUyxNQUFNQztnQkFDckM7Z0JBQ0EsK0NBQStDO2dCQUMvQyxJQUFJO29CQUNBLE9BQU9WLE9BQU8xRSxXQUFXLENBQUNtRjtnQkFDOUIsRUFDQSxPQUFPMUYsT0FBTztvQkFDVixJQUFJLENBQUMzRSx3REFBT0EsQ0FBQzJFLE9BQU8sdUJBQXVCQSxNQUFNNkYsUUFBUSxLQUFLLE9BQU87d0JBQ2pFLE1BQU03RjtvQkFDVjtnQkFDSjtnQkFDQSxPQUFPckQ7WUFDWDtZQUNBbUosS0FBSyxDQUFDYixRQUFRUztnQkFDVixJQUFJLE9BQVFBLFNBQVUsWUFBWUEsUUFBUVQsVUFBVUYsZUFBZWhHLE9BQU8sQ0FBQzJHLFNBQVMsR0FBRztvQkFDbkYsT0FBT0UsUUFBUUUsR0FBRyxDQUFDYixRQUFRUztnQkFDL0I7Z0JBQ0EsT0FBT1QsT0FBTzdHLFNBQVMsQ0FBQzZILFdBQVcsQ0FBQ1A7WUFDeEM7UUFDSjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0RRLFFBQVE3SSxNQUFNLEVBQUU7UUFDWixPQUFPLElBQUkySCxhQUFhLElBQUksQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQzdHLFNBQVMsRUFBRWY7SUFDekQ7SUFDQTs7O0tBR0MsR0FDRDhJLE9BQU9sQixNQUFNLEVBQUU7UUFDWCxPQUFPLElBQUlELGFBQWFDLFFBQVEsSUFBSSxDQUFDN0csU0FBUyxFQUFFLElBQUksQ0FBQ2YsTUFBTTtJQUMvRDtJQUNBOztLQUVDLEdBQ0QsTUFBTWtDLGFBQWE7UUFBRSxPQUFPLE1BQU00QyxZQUFZLElBQUksRUFBRWlELFdBQVc7SUFBRTtJQUNqRTs7S0FFQyxHQUNELE1BQU1nQixrQkFBa0I7UUFDcEIsTUFBTTFKLFdBQVc4QixZQUFZLElBQUksQ0FBQ25CLE1BQU07UUFDeEM5Qix1REFBTUEsQ0FBQ21CLFVBQVUscUNBQXFDLHlCQUF5QjtZQUFFcUQsV0FBVztRQUFrQjtRQUM5RyxNQUFNc0csT0FBTyxNQUFNM0osU0FBUzRKLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQy9HLFVBQVU7UUFDekQsSUFBSThHLFNBQVMsTUFBTTtZQUNmLE9BQU87UUFDWDtRQUNBLE9BQU9BO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxNQUFNRSxvQkFBb0I7UUFDdEIsbUZBQW1GO1FBQ25GLE1BQU1sQixXQUFXLElBQUksQ0FBQ21CLHFCQUFxQjtRQUMzQyxJQUFJbkIsVUFBVTtZQUNWLE1BQU1BLFNBQVNvQixJQUFJO1lBQ25CLE9BQU8sSUFBSTtRQUNmO1FBQ0EsaUJBQWlCO1FBQ2pCLE1BQU1KLE9BQU8sTUFBTSxJQUFJLENBQUNELGVBQWU7UUFDdkMsSUFBSUMsUUFBUSxNQUFNO1lBQ2QsT0FBTyxJQUFJO1FBQ2Y7UUFDQSxpREFBaUQ7UUFDakQsTUFBTTNKLFdBQVc4QixZQUFZLElBQUksQ0FBQ25CLE1BQU07UUFDeEM5Qix1REFBTUEsQ0FBQ21CLFlBQVksTUFBTSw4Q0FBOEMseUJBQXlCO1lBQUVxRCxXQUFXO1FBQW9CO1FBQ2pJLE9BQU8sSUFBSXRDLFFBQVEsQ0FBQzhHLFNBQVNtQztZQUN6QixNQUFNQyxZQUFZO2dCQUNkLElBQUk7b0JBQ0EsTUFBTU4sT0FBTyxNQUFNLElBQUksQ0FBQ0QsZUFBZTtvQkFDdkMsSUFBSUMsUUFBUSxNQUFNO3dCQUNkLE9BQU85QixRQUFRLElBQUk7b0JBQ3ZCO29CQUNBN0gsU0FBU2lJLElBQUksQ0FBQyxTQUFTZ0M7Z0JBQzNCLEVBQ0EsT0FBTzNHLE9BQU87b0JBQ1YwRyxPQUFPMUc7Z0JBQ1g7WUFDSjtZQUNBMkc7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDREgsd0JBQXdCO1FBQ3BCLE9BQU9yRSxZQUFZLElBQUksRUFBRWtELFFBQVE7SUFDckM7SUFDQTs7OztLQUlDLEdBQ0Q5RSxZQUFZRixHQUFHLEVBQUU7UUFDYixJQUFJLE9BQVFBLFFBQVMsVUFBVTtZQUMzQkEsTUFBTUEsSUFBSXVHLE1BQU07UUFDcEI7UUFDQSxNQUFNQyxPQUFPekcsbUJBQW1CLElBQUksRUFBRUM7UUFDdEMsT0FBT3dHO0lBQ1g7SUFDQTs7OztLQUlDLEdBQ0RwRixTQUFTcEIsR0FBRyxFQUFFO1FBQ1YsSUFBSSxPQUFRQSxRQUFTLFVBQVU7WUFDM0JBLE1BQU1BLElBQUl1RyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT3BGLGtCQUFrQixJQUFJLEVBQUVuQjtJQUNuQztJQUNBOztLQUVDLEdBQ0QsTUFBTXlHLGlCQUFpQkMsSUFBSSxFQUFFO1FBQ3pCLE1BQU0sSUFBSTNKLE1BQU07SUFDcEI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFjQSxHQUNBOzs7O0tBSUMsR0FDRCxNQUFNNEosWUFBWTFFLEtBQUssRUFBRTJFLFNBQVMsRUFBRUMsT0FBTyxFQUFFO1FBQ3pDLElBQUlELGFBQWEsTUFBTTtZQUNuQkEsWUFBWTtRQUNoQjtRQUNBLElBQUlDLFdBQVcsTUFBTTtZQUNqQkEsVUFBVTtRQUNkO1FBQ0EsTUFBTSxFQUFFN0QsSUFBSSxFQUFFK0IsV0FBVyxFQUFFLEdBQUdqRCxZQUFZLElBQUk7UUFDOUMsTUFBTW9CLFVBQVdGLE9BQU9BLE9BQVEsTUFBTStCO1FBQ3RDLE1BQU0sRUFBRXBJLFFBQVEsRUFBRXVGLE1BQU0sRUFBRSxHQUFHLE1BQU1GLFdBQVcsSUFBSSxFQUFFQztRQUNwRCxNQUFNekYsU0FBUztZQUFFMEc7WUFBU2hCO1lBQVEwRTtZQUFXQztRQUFRO1FBQ3JELE1BQU14SyxXQUFXOEIsWUFBWSxJQUFJLENBQUNuQixNQUFNO1FBQ3hDOUIsdURBQU1BLENBQUNtQixVQUFVLDRDQUE0Qyx5QkFBeUI7WUFBRXFELFdBQVc7UUFBYztRQUNqSCxPQUFPLENBQUMsTUFBTXJELFNBQVN5SyxPQUFPLENBQUN0SyxPQUFNLEVBQUdjLEdBQUcsQ0FBQyxDQUFDOEY7WUFDekMsSUFBSUMsZ0JBQWdCMUc7WUFDcEIsSUFBSTBHLGlCQUFpQixNQUFNO2dCQUN2QixJQUFJO29CQUNBQSxnQkFBZ0IsSUFBSSxDQUFDdEYsU0FBUyxDQUFDcUQsUUFBUSxDQUFDZ0MsSUFBSWxCLE1BQU0sQ0FBQyxFQUFFO2dCQUN6RCxFQUNBLE9BQU92QyxPQUFPLENBQUU7WUFDcEI7WUFDQSxJQUFJMEQsZUFBZTtnQkFDZixJQUFJO29CQUNBLE9BQU8sSUFBSTlILGtEQUFRQSxDQUFDNkgsS0FBSyxJQUFJLENBQUNyRixTQUFTLEVBQUVzRjtnQkFDN0MsRUFDQSxPQUFPMUQsT0FBTztvQkFDVixPQUFPLElBQUluRSwyREFBaUJBLENBQUM0SCxLQUFLekQ7Z0JBQ3RDO1lBQ0o7WUFDQSxPQUFPLElBQUlqRix1REFBR0EsQ0FBQzBJLEtBQUsvRztRQUN4QjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxNQUFNdUgsR0FBRzNCLEtBQUssRUFBRWtCLFFBQVEsRUFBRTtRQUN0QixNQUFNRixNQUFNLE1BQU1GLE9BQU8sSUFBSSxFQUFFLE1BQU1kO1FBQ3JDZ0IsSUFBSWUsU0FBUyxDQUFDTCxJQUFJLENBQUM7WUFBRVI7WUFBVW1CLE1BQU07UUFBTTtRQUMzQ3JCLElBQUlTLEtBQUs7UUFDVCxPQUFPLElBQUk7SUFDZjtJQUNBOzs7S0FHQyxHQUNELE1BQU1ZLEtBQUtyQyxLQUFLLEVBQUVrQixRQUFRLEVBQUU7UUFDeEIsTUFBTUYsTUFBTSxNQUFNRixPQUFPLElBQUksRUFBRSxRQUFRZDtRQUN2Q2dCLElBQUllLFNBQVMsQ0FBQ0wsSUFBSSxDQUFDO1lBQUVSO1lBQVVtQixNQUFNO1FBQUs7UUFDMUNyQixJQUFJUyxLQUFLO1FBQ1QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTUYsS0FBS3ZCLEtBQUssRUFBRSxHQUFHckYsSUFBSSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTTRHLEtBQUssSUFBSSxFQUFFdkIsT0FBT3JGLE1BQU07SUFDekM7SUFDQTs7O0tBR0MsR0FDRCxNQUFNbUssY0FBYzlFLEtBQUssRUFBRTtRQUN2QixJQUFJQSxPQUFPO1lBQ1AsTUFBTWdCLE1BQU0sTUFBTUosT0FBTyxJQUFJLEVBQUVaO1lBQy9CLElBQUksQ0FBQ2dCLEtBQUs7Z0JBQ04sT0FBTztZQUNYO1lBQ0EsT0FBT0EsSUFBSWUsU0FBUyxDQUFDbEgsTUFBTTtRQUMvQjtRQUNBLE1BQU0sRUFBRWdHLElBQUksRUFBRSxHQUFHaEIsWUFBWSxJQUFJO1FBQ2pDLElBQUlrRixRQUFRO1FBQ1osS0FBSyxNQUFNLEVBQUVoRCxTQUFTLEVBQUUsSUFBSWxCLEtBQUtsQixNQUFNLEdBQUk7WUFDdkNvRixTQUFTaEQsVUFBVWxILE1BQU07UUFDN0I7UUFDQSxPQUFPa0s7SUFDWDtJQUNBOzs7S0FHQyxHQUNELE1BQU1oRCxVQUFVL0IsS0FBSyxFQUFFO1FBQ25CLElBQUlBLE9BQU87WUFDUCxNQUFNZ0IsTUFBTSxNQUFNSixPQUFPLElBQUksRUFBRVo7WUFDL0IsSUFBSSxDQUFDZ0IsS0FBSztnQkFDTixPQUFPLEVBQUU7WUFDYjtZQUNBLE9BQU9BLElBQUllLFNBQVMsQ0FBQzFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU2RixRQUFRLEVBQUUsR0FBS0E7UUFDL0M7UUFDQSxNQUFNLEVBQUVMLElBQUksRUFBRSxHQUFHaEIsWUFBWSxJQUFJO1FBQ2pDLElBQUl0QixTQUFTLEVBQUU7UUFDZixLQUFLLE1BQU0sRUFBRXdELFNBQVMsRUFBRSxJQUFJbEIsS0FBS2xCLE1BQU0sR0FBSTtZQUN2Q3BCLFNBQVNBLE9BQU95RyxNQUFNLENBQUNqRCxVQUFVMUcsR0FBRyxDQUFDLENBQUMsRUFBRTZGLFFBQVEsRUFBRSxHQUFLQTtRQUMzRDtRQUNBLE9BQU8zQztJQUNYO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTXVELElBQUk5QixLQUFLLEVBQUVrQixRQUFRLEVBQUU7UUFDdkIsTUFBTUYsTUFBTSxNQUFNSixPQUFPLElBQUksRUFBRVo7UUFDL0IsSUFBSSxDQUFDZ0IsS0FBSztZQUNOLE9BQU8sSUFBSTtRQUNmO1FBQ0EsSUFBSUUsVUFBVTtZQUNWLE1BQU0zRixRQUFReUYsSUFBSWUsU0FBUyxDQUFDMUcsR0FBRyxDQUFDLENBQUMsRUFBRTZGLFFBQVEsRUFBRSxHQUFLQSxVQUFVekUsT0FBTyxDQUFDeUU7WUFDcEUsSUFBSTNGLFNBQVMsR0FBRztnQkFDWnlGLElBQUllLFNBQVMsQ0FBQ2tELE1BQU0sQ0FBQzFKLE9BQU87WUFDaEM7UUFDSjtRQUNBLElBQUkyRixZQUFZLFFBQVFGLElBQUllLFNBQVMsQ0FBQ2xILE1BQU0sS0FBSyxHQUFHO1lBQ2hEbUcsSUFBSVksSUFBSTtZQUNSL0IsWUFBWSxJQUFJLEVBQUVnQixJQUFJLENBQUMwQixNQUFNLENBQUN2QixJQUFJTixHQUFHO1FBQ3pDO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7O0tBR0MsR0FDRCxNQUFNd0UsbUJBQW1CbEYsS0FBSyxFQUFFO1FBQzVCLElBQUlBLE9BQU87WUFDUCxNQUFNZ0IsTUFBTSxNQUFNSixPQUFPLElBQUksRUFBRVo7WUFDL0IsSUFBSSxDQUFDZ0IsS0FBSztnQkFDTixPQUFPLElBQUk7WUFDZjtZQUNBQSxJQUFJWSxJQUFJO1lBQ1IvQixZQUFZLElBQUksRUFBRWdCLElBQUksQ0FBQzBCLE1BQU0sQ0FBQ3ZCLElBQUlOLEdBQUc7UUFDekMsT0FDSztZQUNELE1BQU0sRUFBRUcsSUFBSSxFQUFFLEdBQUdoQixZQUFZLElBQUk7WUFDakMsS0FBSyxNQUFNLEVBQUVhLEdBQUcsRUFBRWtCLElBQUksRUFBRSxJQUFJZixLQUFLbEIsTUFBTSxHQUFJO2dCQUN2Q2lDO2dCQUNBZixLQUFLMEIsTUFBTSxDQUFDN0I7WUFDaEI7UUFDSjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDRCxNQUFNeUUsWUFBWW5GLEtBQUssRUFBRWtCLFFBQVEsRUFBRTtRQUMvQixPQUFPLE1BQU0sSUFBSSxDQUFDUyxFQUFFLENBQUMzQixPQUFPa0I7SUFDaEM7SUFDQTs7S0FFQyxHQUNELE1BQU1rRSxlQUFlcEYsS0FBSyxFQUFFa0IsUUFBUSxFQUFFO1FBQ2xDLE9BQU8sTUFBTSxJQUFJLENBQUNZLEdBQUcsQ0FBQzlCLE9BQU9rQjtJQUNqQztJQUNBOztLQUVDLEdBQ0QsT0FBT21FLFdBQVd6QyxHQUFHLEVBQUU7UUFDbkIsTUFBTTBDLHVCQUF1QjVDO1lBQ3pCbEksWUFBWXlHLE9BQU8sRUFBRWxHLFNBQVMsSUFBSSxDQUFFO2dCQUNoQyxLQUFLLENBQUNrRyxTQUFTMkIsS0FBSzdIO1lBQ3hCO1FBQ0o7UUFDQSxPQUFPdUs7SUFDWDtJQUVBOztLQUVDLEdBQ0QsT0FBTzNJLEtBQUtnRyxNQUFNLEVBQUVDLEdBQUcsRUFBRTdILE1BQU0sRUFBRTtRQUM3QixJQUFJQSxVQUFVLE1BQU07WUFDaEJBLFNBQVM7UUFDYjtRQUNBLE1BQU1OLFdBQVcsSUFBSSxJQUFJLENBQUNrSSxRQUFRQyxLQUFLN0g7UUFDdkMsT0FBT047SUFDWDtBQUNKO0FBQ0EsU0FBUzhLO0lBQ0wsT0FBTzdDO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLE1BQU04QyxpQkFBaUJEO0FBQzlCLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L2NvbnRyYWN0LmpzPzI2NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50ZXJmYWNlLCBUeXBlZCB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzQWRkcmVzc2FibGUsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBMb2cgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNIZXhTdHJpbmcsIHJlc29sdmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0RXZlbnRQYXlsb2FkLCBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQsIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSwgRXZlbnRMb2csIFVuZGVjb2RlZEV2ZW50TG9nIH0gZnJvbSBcIi4vd3JhcHBlcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5mdW5jdGlvbiBjYW5DYWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmNhbGwpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuRXN0aW1hdGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZXN0aW1hdGVHYXMpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuUmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZXNvbHZlTmFtZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5TZW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYW5SZXNvbHZlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBQcmVwYXJlZFRvcGljRmlsdGVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGZyYWdtZW50O1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZnJhZ21lbnQgfSk7XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IFByb21pc2UuYWxsKGZyYWdtZW50LmlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3ModiwgcmVzb2x2ZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0VG9waWNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmaWx0ZXI7XG4gICAgfVxufVxuLy8gQSA9IEFyZ3VtZW50cyBwYXNzZWQgaW4gYXMgYSB0dXBsZVxuLy8gUiA9IFRoZSByZXN1bHQgdHlwZSBvZiB0aGUgY2FsbCAoaS5lLiBpZiBvbmx5IG9uZSByZXR1cm4gdHlwZSxcbi8vICAgICB0aGUgcXVhbGlmaWVkIHR5cGUsIG90aGVyd2lzZSBSZXN1bHQpXG4vLyBEID0gVGhlIHR5cGUgdGhlIGRlZmF1bHQgY2FsbCB3aWxsIHJldHVybiAoaS5lLiBSIGZvciB2aWV3L3B1cmUsXG4vLyAgICAgVHJhbnNhY3Rpb25SZXNwb25zZSBvdGhlcndpc2UpXG4vL2V4cG9ydCBpbnRlcmZhY2UgQ29udHJhY3RNZXRob2Q8QSBleHRlbmRzIEFycmF5PGFueT4gPSBBcnJheTxhbnk+LCBSID0gYW55LCBEIGV4dGVuZHMgUiB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSA9IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZT4ge1xuZnVuY3Rpb24gZ2V0UnVubmVyKHZhbHVlLCBmZWF0dXJlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnByb3ZpZGVyICYmIHR5cGVvZiAodmFsdWUucHJvdmlkZXJbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5wcm92aWRlciB8fCBudWxsO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5T3ZlcnJpZGVzKGFyZywgYWxsb3dlZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgb3ZlcnJpZGVzIHBhc3NlZCBpbiBhcmUgYSB2YWxpZCBvdmVycmlkZXMgb2JqZWN0XG4gICAgY29uc3QgX292ZXJyaWRlcyA9IFR5cGVkLmRlcmVmZXJlbmNlKGFyZywgXCJvdmVycmlkZXNcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChfb3ZlcnJpZGVzKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIG92ZXJyaWRlcyBwYXJhbWV0ZXJcIiwgXCJvdmVycmlkZXNcIiwgYXJnKTtcbiAgICAvLyBDcmVhdGUgYSBzaGFsbG93IGNvcHkgKHdlJ2xsIGRlZXAtaWZ5IGFueXRoaW5nIG5lZWRlZCBkdXJpbmcgbm9ybWFsaXppbmcpXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gY29weVJlcXVlc3QoX292ZXJyaWRlcyk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLnRvID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJ0b1wiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSB0b1wiLCBcIm92ZXJyaWRlcy50b1wiLCBvdmVycmlkZXMudG8pO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy5kYXRhID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJkYXRhXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIGRhdGFcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCBvdmVycmlkZXMuZGF0YSk7XG4gICAgLy8gUmVzb2x2ZSBhbnkgZnJvbVxuICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICBvdmVycmlkZXMuZnJvbSA9IG92ZXJyaWRlcy5mcm9tO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQXJncyhfcnVubmVyLCBpbnB1dHMsIGFyZ3MpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKF9ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRGYWxsYmFjayhjb250cmFjdCkge1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBjb25zdCB0eCA9IChhd2FpdCBjb3B5T3ZlcnJpZGVzKG92ZXJyaWRlcywgW1wiZGF0YVwiXSkpO1xuICAgICAgICB0eC50byA9IGF3YWl0IGNvbnRyYWN0LmdldEFkZHJlc3MoKTtcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRyYWN0LmludGVyZmFjZTtcbiAgICAgICAgY29uc3Qgbm9WYWx1ZSA9IChnZXRCaWdJbnQoKHR4LnZhbHVlIHx8IEJOXzApLCBcIm92ZXJyaWRlcy52YWx1ZVwiKSA9PT0gQk5fMCk7XG4gICAgICAgIGNvbnN0IG5vRGF0YSA9ICgodHguZGF0YSB8fCBcIjB4XCIpID09PSBcIjB4XCIpO1xuICAgICAgICBpZiAoaWZhY2UuZmFsbGJhY2sgJiYgIWlmYWNlLmZhbGxiYWNrLnBheWFibGUgJiYgaWZhY2UucmVjZWl2ZSAmJiAhbm9EYXRhICYmICFub1ZhbHVlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUgb3Igc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlc1wiLCBvdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IHBheWFibGUgY29udHJhY3RzIHRvIHNldCBub24temVybyB2YWx1ZVxuICAgICAgICBjb25zdCBwYXlhYmxlID0gaWZhY2UucmVjZWl2ZSB8fCAoaWZhY2UuZmFsbGJhY2sgJiYgaWZhY2UuZmFsbGJhY2sucGF5YWJsZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBheWFibGUgfHwgbm9WYWx1ZSwgXCJjYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlcy52YWx1ZVwiLCB0eC52YWx1ZSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgZmFsbGJhY2sgY29udHJhY3RzIHRvIHNldCBub24tZW1wdHkgZGF0YVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIChvdmVycmlkZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQob3ZlcnJpZGVzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZE1ldGhvZChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXdhaXQgY29weU92ZXJyaWRlcyhhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3Mob3ZlcnJpZGVzLmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3I6IGZyYWdtZW50IGlucHV0cyBkb2Vzbid0IG1hdGNoIGFyZ3VtZW50czsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgcmVzb2x2ZUFyZ3MoY29udHJhY3QucnVubmVyLCBmcmFnbWVudC5pbnB1dHMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzLCBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICB0bzogY29udHJhY3QuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGljQ2FsbFJlc3VsdCguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbFJlc3VsdCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0YXRpY0NhbGwoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQoLi4uYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb25OYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnQsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsLCBzdGF0aWNDYWxsUmVzdWx0LFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEV2ZW50KGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRUb3BpY0ZpbHRlcihjb250cmFjdCwgZ2V0RnJhZ21lbnQoLi4uYXJncyksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50TmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50XG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuLy8gVGhlIGNvbWJpbmF0aW9uIG9mIFR5cGVTY3J5cGUsIFByaXZhdGUgRmllbGRzIGFuZCBQcm94aWVzIG1ha2VzXG4vLyB0aGUgd29ybGQgZ28gYm9vbTsgc28gd2UgaGlkZSB2YXJpYWJsZXMgd2l0aCBzb21lIHRyaWNrZXJ5IGtlZXBpbmdcbi8vIGEgc3ltYm9sIGF0dGFjaGVkIHRvIGVhY2ggQmFzZUNvbnRyYWN0IHdoaWNoIGl0cyBzdWItY2xhc3MgKGV2ZW5cbi8vIHZpYSBhIFByb3h5KSBjYW4gcmVhY2ggYW5kIHVzZSB0byBsb29rIHVwIGl0cyBpbnRlcm5hbCB2YWx1ZXMuXG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzSW50ZXJuYWxfY29udHJhY3RcIik7XG5jb25zdCBpbnRlcm5hbFZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZXRJbnRlcm5hbChjb250cmFjdCwgdmFsdWVzKSB7XG4gICAgaW50ZXJuYWxWYWx1ZXMuc2V0KGNvbnRyYWN0W2ludGVybmFsXSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsKGNvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGludGVybmFsVmFsdWVzLmdldChjb250cmFjdFtpbnRlcm5hbF0pO1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgKFwiZ2V0VG9waWNGaWx0ZXJcIiBpbiB2YWx1ZSkgJiZcbiAgICAgICAgKHR5cGVvZiAodmFsdWUuZ2V0VG9waWNGaWx0ZXIpID09PSBcImZ1bmN0aW9uXCIpICYmIHZhbHVlLmZyYWdtZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSB7XG4gICAgbGV0IHRvcGljcztcbiAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgIC8vIENvbnZlcnQgbmFtZWQgZXZlbnRzIHRvIHRvcGljSGFzaCBhbmQgZ2V0IHRoZSBmcmFnbWVudCBmb3JcbiAgICAvLyBldmVudHMgd2hpY2ggbmVlZCBkZWNvbnN0cnVjdGluZy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgY29uc3QgdG9waWNIYXNoaWZ5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBcnJheSBvZiBUb3BpY3MgYW5kIE5hbWVzOyBlLmcuIGBbIFwiMHgxMjM0Li4uODlhYlwiLCBcIlRyYW5zZmVyKGFkZHJlc3MpXCIgXWBcbiAgICAgICAgdG9waWNzID0gZXZlbnQubWFwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLm1hcCh0b3BpY0hhc2hpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvcGljSGFzaGlmeShlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICB0b3BpY3MgPSBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XG4gICAgICAgICAgICAvLyBUb3BpYyBIYXNoXG4gICAgICAgICAgICB0b3BpY3MgPSBbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTmFtZSBvciBTaWduYXR1cmU7IGUuZy4gYFwiVHJhbnNmZXJcIiwgYFwiVHJhbnNmZXIoYWRkcmVzcylcImBcbiAgICAgICAgICAgIGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0RlZmVycmVkKGV2ZW50KSkge1xuICAgICAgICAvLyBEZWZlcnJlZCBUb3BpYyBGaWx0ZXI7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2Zlcihmcm9tKWBcbiAgICAgICAgdG9waWNzID0gYXdhaXQgZXZlbnQuZ2V0VG9waWNGaWx0ZXIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJmcmFnbWVudFwiIGluIGV2ZW50KSB7XG4gICAgICAgIC8vIENvbnRyYWN0RXZlbnQ7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2ZlcmBcbiAgICAgICAgZnJhZ21lbnQgPSBldmVudC5mcmFnbWVudDtcbiAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIGV2ZW50IG5hbWVcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpY3MgYW5kIHNvcnQgVG9waWNTZXRzXG4gICAgdG9waWNzID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICBjb25zdCB0YWcgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSkuam9pbihcIiZcIik7XG4gICAgcmV0dXJuIHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH07XG59XG5hc3luYyBmdW5jdGlvbiBoYXNTdWIoY29udHJhY3QsIGV2ZW50KSB7XG4gICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgcmV0dXJuIHN1YnMuZ2V0KChhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkpLnRhZykgfHwgbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1Yihjb250cmFjdCwgb3BlcmF0aW9uLCBldmVudCkge1xuICAgIC8vIE1ha2Ugc3VyZSBvdXIgcnVubmVyIGNhbiBhY3R1YWxseSBzdWJzY3JpYmUgdG8gZXZlbnRzXG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzdWJzY3JpYmluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbiAgICBjb25zdCB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpO1xuICAgIGNvbnN0IHsgYWRkciwgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIGxldCBzdWIgPSBzdWJzLmdldCh0YWcpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiBjb250cmFjdCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzIH07XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgbnVsbCwgd2UgZG8gbm90IGRlY29uc3RydWN0IHRoZSBhcmdzIHRvIGVtaXRcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZvdW5kRnJhZ21lbnQgPSBmb3VuZEZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBmcmFnbWVudCA/IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpIDogW107XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0RXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIF9mb3VuZEZyYWdtZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIFtdLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0aW5nLnB1c2gocHJvdmlkZXIub24oZmlsdGVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSBzdGFydGluZztcbiAgICAgICAgICAgIHN0YXJ0aW5nID0gW107XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdGFydGVkKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLm9mZihmaWx0ZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ViID0geyB0YWcsIGxpc3RlbmVyczogW10sIHN0YXJ0LCBzdG9wIH07XG4gICAgICAgIHN1YnMuc2V0KHRhZywgc3ViKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Yjtcbn1cbi8vIFdlIHVzZSB0aGlzIHRvIGVuc3VyZSBvbmUgZW1pdCByZXNvbHZlcyBiZWZvcmUgZmlyaW5nIHRoZSBuZXh0IHRvXG4vLyBlbnN1cmUgY29ycmVjdCBvcmRlcmluZyAobm90ZSB0aGlzIGNhbm5vdCB0aHJvdyBhbmQganVzdCBhZGRzIHRoZVxuLy8gbm90aWNlIHRvIHRoZSBldmVudCBxdWV1IHVzaW5nIHNldFRpbWVvdXQpLlxubGV0IGxhc3RFbWl0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5hc3luYyBmdW5jdGlvbiBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKGNvbnRyYWN0LCBldmVudCk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhc3NBcmdzID0gQXJyYXkuZnJvbShhcmdzKTtcbiAgICAgICAgaWYgKHBheWxvYWRGdW5jKSB7XG4gICAgICAgICAgICBwYXNzQXJncy5wdXNoKHBheWxvYWRGdW5jKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250cmFjdCwgLi4ucGFzc0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiAhb25jZTtcbiAgICB9KTtcbiAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgZ2V0SW50ZXJuYWwoY29udHJhY3QpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gKGNvdW50ID4gMCk7XG59XG5hc3luYyBmdW5jdGlvbiBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYyk7XG4gICAgbGFzdEVtaXQgPSByZXN1bHRQcm9taXNlO1xuICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlO1xufVxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuZXhwb3J0IGNsYXNzIEJhc2VDb250cmFjdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0YXJnZXQgdG8gY29ubmVjdCB0by5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSBhbiBhZGRyZXNzLCBFTlMgbmFtZSBvciBhbnkgW1tBZGRyZXNzYWJsZV1dLCBzdWNoIGFzXG4gICAgICogIGFub3RoZXIgY29udHJhY3QuIFRvIGdldCB0aGUgcmVzb3ZsZWQgYWRkcmVzcywgdXNlIHRoZSBgYGdldEFkZHJlc3NgYFxuICAgICAqICBtZXRob2QuXG4gICAgICovXG4gICAgdGFyZ2V0O1xuICAgIC8qKlxuICAgICAqICBUaGUgY29udHJhY3QgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGludGVyZmFjZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBydW5uZXIuIFRoaXMgaXMgZ2VuZXJhbGx5IGEgW1tQcm92aWRlcl1dIG9yIGFcbiAgICAgKiAgW1tTaWduZXJdXSwgd2hpY2ggZGljdGF0ZXMgd2hhdCBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgKipDb250cmFjdCoqIGNvbm5lY3RlZCB0byBhIFtbUHJvdmlkZXJdXSBtYXlcbiAgICAgKiAgb25seSBleGVjdXRlIHJlYWQtb25seSBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHJ1bm5lcjtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBFdmVudHMgYXZhaWxhYmxlIG9uIHRoaXMgY29udHJhY3QuXG4gICAgICovXG4gICAgZmlsdGVycztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgW2ludGVybmFsXTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZhbGxiYWNrIG9yIHJlY2VpdmUgZnVuY3Rpb24gaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGNvbnRyYWN0IGNvbm5lY3RlZCB0byAlJXRhcmdldCUlIHdpdGggdGhlICUlYWJpJSUgYW5kXG4gICAgICogIG9wdGlvbmFsbHkgY29ubmVjdGVkIHRvIGEgJSVydW5uZXIlJSB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gYmVoYWxmXG4gICAgICogIG9mLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWJpLCBydW5uZXIsIF9kZXBsb3lUeCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIgfHwgaXNBZGRyZXNzYWJsZSh0YXJnZXQpLCBcImludmFsaWQgdmFsdWUgZm9yIENvbnRyYWN0IHRhcmdldFwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBJbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdGFyZ2V0LCBydW5uZXIsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZToge30gfSk7XG4gICAgICAgIGxldCBhZGRyUHJvbWlzZTtcbiAgICAgICAgbGV0IGFkZHIgPSBudWxsO1xuICAgICAgICBsZXQgZGVwbG95VHggPSBudWxsO1xuICAgICAgICBpZiAoX2RlcGxveVR4KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHJ1bm5lcik7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgICAgICBkZXBsb3lUeCA9IG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCBfZGVwbG95VHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXJnZXQgYXMgdGhlIGFkZHJlc3NcbiAgICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBhZGRyID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGdldFJ1bm5lcihydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5SZXNvbHZlKHJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lIHJlc29sdXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImFuIEVOUyBuYW1lIHVzZWQgZm9yIGEgY29udHJhY3QgdGFyZ2V0IG11c3QgYmUgY29ycmVjdGx5IGNvbmZpZ3VyZWRcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkclByb21pc2UgPSB0YXJnZXQuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG91ciBwcml2YXRlIHZhbHVlc1xuICAgICAgICBzZXRJbnRlcm5hbCh0aGlzLCB7IGFkZHJQcm9taXNlLCBhZGRyLCBkZXBsb3lUeCwgc3VicyB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBldmVudCBmaWx0ZXJzXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgfHwgdGhpcy5pbnRlcmZhY2UuaGFzRXZlbnQoU3RyaW5nKHByb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmaWx0ZXJzIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAoKGlmYWNlLnJlY2VpdmUgfHwgaWZhY2UuZmFsbGJhY2spID8gKGJ1aWxkV3JhcHBlZEZhbGxiYWNrKHRoaXMpKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gYSBQcm94eSB0aGF0IHdpbGwgcmVzcG9uZCB0byBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHByb3BlcnRpZXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEZ1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmludGVyZmFjZS5oYXNGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB0YXJnZXQgYW5kIEFCSSwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUlcnVubmVyJSUuXG4gICAgICovXG4gICAgY29ubmVjdChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGhpcy50YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBydW5uZXIsIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXRhcmdldCUlLlxuICAgICAqL1xuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSByZXNvbHZlZCBhZGRyZXNzIG9mIHRoaXMgQ29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIGF3YWl0IGdldEludGVybmFsKHRoaXMpLmFkZHJQcm9taXNlOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZGVwbG95ZWQgYnl0ZWNvZGUgb3IgbnVsbCBpZiBubyBieXRlY29kZSBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBsb3llZENvZGUoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwicnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImdldERlcGxveWVkQ29kZVwiIH0pO1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGlzIENvbnRyYWN0IG9uY2UgdGhlIGJ5dGVjb2RlIGhhcyBiZWVuIGRlcGxveWVkLCBvclxuICAgICAqICByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIGFscmVhZHkgZGVwbG95ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvckRlcGxveW1lbnQoKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdGhlIGRlcGxveWVtZW50IHRyYW5zYWN0aW9uOyBqdXN0IHVzZSB0aGF0ICh0aHJvd3MgaWYgZGVwbG95ZW1lbnQgZmFpbHMpXG4gICAgICAgIGNvbnN0IGRlcGxveVR4ID0gdGhpcy5kZXBsb3ltZW50VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKGRlcGxveVR4KSB7XG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lUeC53YWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgY29kZVxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNhbiBzdWJzY3JpYmUgdG8gYSBwcm92aWRlciBldmVudFxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyICE9IG51bGwsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIndhaXRGb3JEZXBsb3ltZW50XCIgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja0NvZGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCBjaGVja0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tDb2RlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGRlcGxveSB0aGlzIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgcmV0dXJuZWQgZnJvbSBhXG4gICAgICogIFtbQ29udHJhY3RGYWN0b3J5XV0uXG4gICAgICovXG4gICAgZGVwbG95bWVudFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWwodGhpcykuZGVwbG95VHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBtZXRob2QgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGV2ZW50IGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkV3JhcHBlZEV2ZW50KHRoaXMsIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeVRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qXG4gICAgLy8gQFRPRE86IHRoaXMgaXMgYSBub24tYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlLCBidXQgd2lsbCBiZSBhZGRlZFxuICAgIC8vICAgICAgICBpbiB2NyBhbmQgaW4gYSBwb3RlbnRpYWwgU21hcnRDb250cmFjdCBjbGFzcyBpbiBhbiB1cGNvbWluZ1xuICAgIC8vICAgICAgICB2NiByZWxlYXNlXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2g6IHN0cmluZyk6IFByb21pc2U8bnVsbCB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLFxuICAgICAgICAgICAgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlUcmFuc2FjdGlvblwiIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogIFByb3ZpZGUgaGlzdG9yaWMgYWNjZXNzIHRvIGV2ZW50IGRhdGEgZm9yICUlZXZlbnQlJSBpbiB0aGUgcmFuZ2VcbiAgICAgKiAgJSVmcm9tQmxvY2slJSAoZGVmYXVsdDogYGAwYGApIHRvICUldG9CbG9jayUlIChkZWZhdWx0OiBgYFwibGF0ZXN0XCJgYClcbiAgICAgKiAgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2ssIHRvQmxvY2spIHtcbiAgICAgICAgaWYgKGZyb21CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0Jsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWRkciwgYWRkclByb21pc2UgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogKGF3YWl0IGFkZHJQcm9taXNlKSk7XG4gICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyh0aGlzLCBldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzLCBmcm9tQmxvY2ssIHRvQmxvY2sgfTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5RmlsdGVyXCIgfSk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpKS5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLmludGVyZmFjZSwgZm91bmRGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nKGxvZywgcHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUuXG4gICAgICovXG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLCBidXQgcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgICAqICBhZnRlciBpdCBpcyBmaXJlZCBvbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uY2VcIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW1pdCBhbiAlJWV2ZW50JSUgY2FsbGluZyBhbGwgbGlzdGVuZXJzIHdpdGggJSVhcmdzJSUuXG4gICAgICpcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYGB0cnVlYGAgaWYgYW55IGxpc3RlbmVycyB3ZXJlIGNhbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbWl0KHRoaXMsIGV2ZW50LCBhcmdzLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIG9mICUlZXZlbnQlJSBvciB0aGUgdG90YWwgbnVtYmVyXG4gICAgICogIG9mIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvICUlZXZlbnQlJSBvciBhbGwgbGlzdGVuZXJzXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSB0aGUgJSVsaXN0ZW5lciUlIGZyb20gdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZVxuICAgICAqICBhbGwgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaWZcbiAgICAgKiAgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhZywgc3RvcCB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb25dLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvZmZdLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBDbGFzcyBmb3IgdGhlICUlYWJpJSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkQ2xhc3MoYWJpKSB7XG4gICAgICAgIGNsYXNzIEN1c3RvbUNvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHJ1bm5lciA9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihhZGRyZXNzLCBhYmksIHJ1bm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN1c3RvbUNvbnRyYWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBCYXNlQ29udHJhY3Qgd2l0aCBhIHNwZWNpZmllZCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odGFyZ2V0LCBhYmksIHJ1bm5lcikge1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgdGhpcyh0YXJnZXQsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9Db250cmFjdEJhc2UoKSB7XG4gICAgcmV0dXJuIEJhc2VDb250cmFjdDtcbn1cbi8qKlxuICogIEEgW1tCYXNlQ29udHJhY3RdXSB3aXRoIG5vIHR5cGUgZ3VhcmRzIG9uIGl0cyBtZXRob2RzIG9yIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgX0NvbnRyYWN0QmFzZSgpIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJJbnRlcmZhY2UiLCJUeXBlZCIsImlzQWRkcmVzc2FibGUiLCJyZXNvbHZlQWRkcmVzcyIsImNvcHlSZXF1ZXN0IiwiTG9nIiwiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImlzQ2FsbEV4Y2VwdGlvbiIsImlzSGV4U3RyaW5nIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJDb250cmFjdEV2ZW50UGF5bG9hZCIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSIsIkV2ZW50TG9nIiwiVW5kZWNvZGVkRXZlbnRMb2ciLCJCTl8wIiwiQmlnSW50IiwiY2FuQ2FsbCIsInZhbHVlIiwiY2FsbCIsImNhbkVzdGltYXRlIiwiZXN0aW1hdGVHYXMiLCJjYW5SZXNvbHZlIiwicmVzb2x2ZU5hbWUiLCJjYW5TZW5kIiwic2VuZFRyYW5zYWN0aW9uIiwiZ2V0UmVzb2x2ZXIiLCJwcm92aWRlciIsInVuZGVmaW5lZCIsIlByZXBhcmVkVG9waWNGaWx0ZXIiLCJmaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRyYWN0IiwiZnJhZ21lbnQiLCJhcmdzIiwiaW5wdXRzIiwibGVuZ3RoIiwiRXJyb3IiLCJydW5uZXIiLCJnZXRSdW5uZXIiLCJyZXNvbHZlciIsInJlc29sdmVkQXJncyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJwYXJhbSIsImluZGV4IiwiYXJnIiwid2Fsa0FzeW5jIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJpbnRlcmZhY2UiLCJlbmNvZGVGaWx0ZXJUb3BpY3MiLCJnZXRUb3BpY0ZpbHRlciIsImZlYXR1cmUiLCJnZXRQcm92aWRlciIsImNvcHlPdmVycmlkZXMiLCJhbGxvd2VkIiwiX292ZXJyaWRlcyIsImRlcmVmZXJlbmNlIiwib3ZlcnJpZGVzIiwidG8iLCJpbmRleE9mIiwiZGF0YSIsImZyb20iLCJyZXNvbHZlQXJncyIsIl9ydW5uZXIiLCJidWlsZFdyYXBwZWRGYWxsYmFjayIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJ0eCIsImdldEFkZHJlc3MiLCJpZmFjZSIsIm5vVmFsdWUiLCJub0RhdGEiLCJmYWxsYmFjayIsInBheWFibGUiLCJyZWNlaXZlIiwic3RhdGljQ2FsbCIsIm9wZXJhdGlvbiIsImVycm9yIiwic2VuZCIsIm1ldGhvZCIsIl9jb250cmFjdCIsImJ1aWxkV3JhcHBlZE1ldGhvZCIsImtleSIsImdldEZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJpbmZvIiwicG9wIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwicmVzdWx0Iiwic3RhdGljQ2FsbFJlc3VsdCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiY29uc3RhbnQiLCJuYW1lIiwiZ2V0RnVuY3Rpb25OYW1lIiwiX2tleSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImJ1aWxkV3JhcHBlZEV2ZW50IiwiZ2V0RXZlbnQiLCJnZXRFdmVudE5hbWUiLCJpbnRlcm5hbCIsIlN5bWJvbCIsImZvciIsImludGVybmFsVmFsdWVzIiwiV2Vha01hcCIsInNldEludGVybmFsIiwidmFsdWVzIiwic2V0IiwiZ2V0SW50ZXJuYWwiLCJpc0RlZmVycmVkIiwiZ2V0U3ViSW5mbyIsImV2ZW50IiwidG9waWNzIiwidG9waWNIYXNoaWZ5IiwidG9waWNIYXNoIiwiZSIsInQiLCJpdGVtcyIsIlNldCIsInRvTG93ZXJDYXNlIiwic29ydCIsInRhZyIsImpvaW4iLCJoYXNTdWIiLCJzdWJzIiwiZ2V0U3ViIiwiYWRkciIsInN1YiIsImFkZHJlc3MiLCJsaXN0ZW5lciIsImxvZyIsImZvdW5kRnJhZ21lbnQiLCJfZm91bmRGcmFnbWVudCIsImRlY29kZUV2ZW50TG9nIiwiZW1pdCIsInN0YXJ0aW5nIiwic3RhcnQiLCJwdXNoIiwib24iLCJzdG9wIiwic3RhcnRlZCIsIm9mZiIsImxpc3RlbmVycyIsImxhc3RFbWl0IiwicmVzb2x2ZSIsIl9lbWl0IiwicGF5bG9hZEZ1bmMiLCJjb3VudCIsIm9uY2UiLCJwYXNzQXJncyIsImRlbGV0ZSIsInJlc3VsdFByb21pc2UiLCJwYXNzUHJvcGVydGllcyIsIkJhc2VDb250cmFjdCIsInRhcmdldCIsImFiaSIsIl9kZXBsb3lUeCIsImFkZHJQcm9taXNlIiwiZGVwbG95VHgiLCJNYXAiLCJ0aGVuIiwiZmlsdGVycyIsIlByb3h5IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImFyZ3VtZW50IiwiaGFzIiwiaGFzRXZlbnQiLCJTdHJpbmciLCJoYXNGdW5jdGlvbiIsImNvbm5lY3QiLCJhdHRhY2giLCJnZXREZXBsb3llZENvZGUiLCJjb2RlIiwiZ2V0Q29kZSIsIndhaXRGb3JEZXBsb3ltZW50IiwiZGVwbG95bWVudFRyYW5zYWN0aW9uIiwid2FpdCIsInJlamVjdCIsImNoZWNrQ29kZSIsImZvcm1hdCIsImZ1bmMiLCJxdWVyeVRyYW5zYWN0aW9uIiwiaGFzaCIsInF1ZXJ5RmlsdGVyIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsImdldExvZ3MiLCJsaXN0ZW5lckNvdW50IiwidG90YWwiLCJjb25jYXQiLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYnVpbGRDbGFzcyIsIkN1c3RvbUNvbnRyYWN0IiwiX0NvbnRyYWN0QmFzZSIsIkNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            error\n        });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.EventPayload {\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            log\n        });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n} //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsc0VBQXNFO0FBQ3RFLHlCQUF5QjtBQUMrRDtBQUNyQjtBQUNuRTs7Q0FFQyxHQUNNLE1BQU1LLGlCQUFpQkwsdURBQUdBO0lBYTdCOztLQUVDLEdBQ0RNLFlBQVlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDOUIsS0FBSyxDQUFDRixLQUFLQSxJQUFJRyxRQUFRO1FBQ3ZCLE1BQU1DLE9BQU9ILE1BQU1JLGNBQWMsQ0FBQ0gsVUFBVUYsSUFBSU0sSUFBSSxFQUFFTixJQUFJTyxNQUFNO1FBQ2hFWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1lBQVVNLFdBQVdQO1FBQU07SUFDOUQ7SUFDQTs7S0FFQyxHQUNELElBQUlRLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQUU7SUFDN0M7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFBRSxPQUFPLElBQUksQ0FBQ1QsUUFBUSxDQUFDVSxNQUFNO0lBQUk7QUFDMUQ7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLDBCQUEwQnBCLHVEQUFHQTtJQUt0Qzs7S0FFQyxHQUNETSxZQUFZQyxHQUFHLEVBQUVjLEtBQUssQ0FBRTtRQUNwQixLQUFLLENBQUNkLEtBQUtBLElBQUlHLFFBQVE7UUFDdkJQLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWtCO1FBQU07SUFDbkM7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG1DQUFtQ3JCLHNFQUFrQkE7SUFDOUQsQ0FBQ08sS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREYsWUFBWUUsS0FBSyxFQUFFRSxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBQ1YsSUFBSSxDQUFDLENBQUNGLEtBQUssR0FBR0E7SUFDbEI7SUFDQTs7O0tBR0MsR0FDRCxJQUFJZ0IsT0FBTztRQUNQLE9BQU8sS0FBSyxDQUFDQSxLQUFLQyxHQUFHLENBQUMsQ0FBQ2xCO1lBQ25CLE1BQU1FLFdBQVdGLElBQUlPLE1BQU0sQ0FBQ1ksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDbEIsS0FBSyxDQUFDbUIsUUFBUSxDQUFDcEIsSUFBSU8sTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUMzRSxJQUFJTCxVQUFVO2dCQUNWLElBQUk7b0JBQ0EsT0FBTyxJQUFJSixTQUFTRSxLQUFLLElBQUksQ0FBQyxDQUFDQyxLQUFLLEVBQUVDO2dCQUMxQyxFQUNBLE9BQU9ZLE9BQU87b0JBQ1YsT0FBTyxJQUFJRCxrQkFBa0JiLEtBQUtjO2dCQUN0QztZQUNKO1lBQ0EsT0FBT2Q7UUFDWDtJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNcUIsb0NBQW9DMUIsdUVBQW1CQTtJQUNoRSxDQUFDTSxLQUFLLENBQUM7SUFDUDs7S0FFQyxHQUNERixZQUFZRSxLQUFLLEVBQUVFLFFBQVEsRUFBRWEsRUFBRSxDQUFFO1FBQzdCLEtBQUssQ0FBQ0EsSUFBSWI7UUFDVixJQUFJLENBQUMsQ0FBQ0YsS0FBSyxHQUFHQTtJQUNsQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTXFCLEtBQUtDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FBQzFCLE1BQU1DLFVBQVUsTUFBTSxLQUFLLENBQUNILEtBQUtDLFVBQVVDO1FBQzNDLElBQUlDLFdBQVcsTUFBTTtZQUNqQixPQUFPO1FBQ1g7UUFDQSxPQUFPLElBQUlWLDJCQUEyQixJQUFJLENBQUMsQ0FBQ2QsS0FBSyxFQUFFLElBQUksQ0FBQ0UsUUFBUSxFQUFFc0I7SUFDdEU7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG9DQUFvQzdCLHlEQUFZQTtJQUt6RDs7S0FFQyxHQUNERSxZQUFZNEIsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRTdCLEdBQUcsQ0FBRTtRQUN6QyxLQUFLLENBQUMyQixVQUFVQyxVQUFVQztRQUMxQmpDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRUk7UUFBSTtJQUNqQztJQUNBOztLQUVDLEdBQ0QsTUFBTThCLFdBQVc7UUFDYixPQUFPLE1BQU0sSUFBSSxDQUFDOUIsR0FBRyxDQUFDOEIsUUFBUTtJQUNsQztJQUNBOztLQUVDLEdBQ0QsTUFBTUMsaUJBQWlCO1FBQ25CLE9BQU8sTUFBTSxJQUFJLENBQUMvQixHQUFHLENBQUMrQixjQUFjO0lBQ3hDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyx3QkFBd0I7UUFDMUIsT0FBTyxNQUFNLElBQUksQ0FBQ2hDLEdBQUcsQ0FBQ2dDLHFCQUFxQjtJQUMvQztBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsNkJBQTZCUDtJQUN0Qzs7S0FFQyxHQUNEM0IsWUFBWTRCLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUUzQixRQUFRLEVBQUVnQyxJQUFJLENBQUU7UUFDcEQsS0FBSyxDQUFDUCxVQUFVQyxVQUFVQyxRQUFRLElBQUkvQixTQUFTb0MsTUFBTVAsU0FBU25CLFNBQVMsRUFBRU47UUFDekUsTUFBTUUsT0FBT3VCLFNBQVNuQixTQUFTLENBQUNILGNBQWMsQ0FBQ0gsVUFBVSxJQUFJLENBQUNGLEdBQUcsQ0FBQ00sSUFBSSxFQUFFLElBQUksQ0FBQ04sR0FBRyxDQUFDTyxNQUFNO1FBQ3ZGWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1FBQVM7SUFDNUM7SUFDQTs7S0FFQyxHQUNELElBQUlPLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNULFFBQVEsQ0FBQ1UsTUFBTTtJQUMvQjtBQUNKLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L3dyYXBwZXJzLmpzP2UwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpOyB9XG59XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxuICAgICAqL1xuICAgIGVycm9yO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGxvZ3MgZm9yIGFueSBbW0xvZ11dIHdoaWNoIGhhcyBhIG1hdGNoaW5nIGV2ZW50IGluIHRoZVxuICAgICAqICBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2c7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UqKiB3aWxsIHJldHVybiBhXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMsIHRpbWVvdXQpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2lmYWNlLCB0aGlzLnByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2cgd2l0aCBubyBtYXRjaGluZyBldmVudHMuXG4gICAgICovXG4gICAgbG9nO1xuICAgIC8qKlxuICAgICAqICBAX2V2ZW50OlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBsb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RFdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgaXMga25vd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEV2ZW50UGF5bG9hZCBleHRlbmRzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBmcmFnbWVudCwgX2xvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgdGhpcy5sb2cuZGF0YSwgdGhpcy5sb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwcGVycy5qcy5tYXAiXSwibmFtZXMiOlsiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJFdmVudExvZyIsImNvbnN0cnVjdG9yIiwibG9nIiwiaWZhY2UiLCJmcmFnbWVudCIsInByb3ZpZGVyIiwiYXJncyIsImRlY29kZUV2ZW50TG9nIiwiZGF0YSIsInRvcGljcyIsImludGVyZmFjZSIsImV2ZW50TmFtZSIsIm5hbWUiLCJldmVudFNpZ25hdHVyZSIsImZvcm1hdCIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiZXJyb3IiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsInR4IiwibG9ncyIsIm1hcCIsImxlbmd0aCIsImdldEV2ZW50IiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwid2FpdCIsImNvbmZpcm1zIiwidGltZW91dCIsInJlY2VpcHQiLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJjb250cmFjdCIsImxpc3RlbmVyIiwiZmlsdGVyIiwiZ2V0QmxvY2siLCJnZXRUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiX2xvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ \n\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBQytDO0FBQ007QUFDdEQsSUFBSUcsU0FBUztBQUNiLE1BQU1DLGFBQWEsU0FBVUMsSUFBSTtJQUM3QixPQUFPTCw4REFBVUEsQ0FBQ0s7QUFDdEI7QUFDQSxJQUFJQyxjQUFjRjtBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBU0csVUFBVUMsS0FBSztJQUMzQixNQUFNSCxPQUFPSix5REFBUUEsQ0FBQ08sT0FBTztJQUM3QixPQUFPTix3REFBT0EsQ0FBQ0ksWUFBWUQ7QUFDL0I7QUFDQUUsVUFBVUUsQ0FBQyxHQUFHTDtBQUNkRyxVQUFVRyxJQUFJLEdBQUc7SUFBY1AsU0FBUztBQUFNO0FBQzlDSSxVQUFVSSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUMvQixJQUFJVCxRQUFRO1FBQ1IsTUFBTSxJQUFJVSxVQUFVO0lBQ3hCO0lBQ0FQLGNBQWNNO0FBQ2xCO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1IsWUFDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcz8xMzgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zIFthYm91dC1jcnlwdG8taGFzaGluZ11cbiAqL1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfa2VjY2FrMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4ga2VjY2FrXzI1NihkYXRhKTtcbn07XG5sZXQgX19rZWNjYWsyNTYgPSBfa2VjY2FrMjU2O1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgVGhlICUlZGF0YSUlICoqbXVzdCoqIGJlIGEgZGF0YSByZXByZXNlbnRhdGlvbiwgdG8gY29tcHV0ZSB0aGVcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXG4gKlxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtlY2NhazI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBTdHJpbmdzIGFyZSBhc3N1bWVkIHRvIGJlIERhdGFIZXhTdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsXG4gKiAgICAvLyB0aHJvdy4gVG8gaGFzaCBVVEYtOCBkYXRhLCBzZWUgdGhlIG5vdGUgYWJvdmUuXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX2tlY2NhazI1NihkYXRhKSk7XG59XG5rZWNjYWsyNTYuXyA9IF9rZWNjYWsyNTY7XG5rZWNjYWsyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2VjY2FrMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19rZWNjYWsyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlY2Nhay5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrXzI1NiIsImdldEJ5dGVzIiwiaGV4bGlmeSIsImxvY2tlZCIsIl9rZWNjYWsyNTYiLCJkYXRhIiwiX19rZWNjYWsyNTYiLCJrZWNjYWsyNTYiLCJfZGF0YSIsIl8iLCJsb2NrIiwicmVnaXN0ZXIiLCJmdW5jIiwiVHlwZUVycm9yIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"crypto\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nconst _sha256 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function sha256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function() {\n    locked256 = true;\n};\nsha256.register = function(func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */ function sha512(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function() {\n    locked512 = true;\n};\nsha512.register = function(func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNhO0FBQ3RELE1BQU1HLFVBQVUsU0FBVUMsSUFBSTtJQUMxQixPQUFPSixzREFBVUEsQ0FBQyxVQUFVSyxNQUFNLENBQUNELE1BQU1FLE1BQU07QUFDbkQ7QUFDQSxNQUFNQyxVQUFVLFNBQVVILElBQUk7SUFDMUIsT0FBT0osc0RBQVVBLENBQUMsVUFBVUssTUFBTSxDQUFDRCxNQUFNRSxNQUFNO0FBQ25EO0FBQ0EsSUFBSUUsV0FBV0w7QUFDZixJQUFJTSxXQUFXRjtBQUNmLElBQUlHLFlBQVksT0FBT0MsWUFBWTtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVNDLE9BQU9DLEtBQUs7SUFDeEIsTUFBTVQsT0FBT0gseURBQVFBLENBQUNZLE9BQU87SUFDN0IsT0FBT1gsd0RBQU9BLENBQUNNLFNBQVNKO0FBQzVCO0FBQ0FRLE9BQU9FLENBQUMsR0FBR1g7QUFDWFMsT0FBT0csSUFBSSxHQUFHO0lBQWNMLFlBQVk7QUFBTTtBQUM5Q0UsT0FBT0ksUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSVAsV0FBVztRQUNYLE1BQU0sSUFBSVEsTUFBTTtJQUNwQjtJQUNBVixXQUFXUztBQUNmO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1I7QUFDZDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTUyxPQUFPUixLQUFLO0lBQ3hCLE1BQU1ULE9BQU9ILHlEQUFRQSxDQUFDWSxPQUFPO0lBQzdCLE9BQU9YLHdEQUFPQSxDQUFDTyxTQUFTTDtBQUM1QjtBQUNBaUIsT0FBT1AsQ0FBQyxHQUFHUDtBQUNYYyxPQUFPTixJQUFJLEdBQUc7SUFBY0osWUFBWTtBQUFNO0FBQzlDVSxPQUFPTCxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUM1QixJQUFJTixXQUFXO1FBQ1gsTUFBTSxJQUFJTyxNQUFNO0lBQ3BCO0lBQ0FULFdBQVdRO0FBQ2Y7QUFDQUUsT0FBT0MsTUFBTSxDQUFDUixTQUNkLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2hhMi5qcz8yZjVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfc2hhMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59O1xuY29uc3QgX3NoYTUxMiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGE1MTJcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmxldCBfX3NoYTI1NiA9IF9zaGEyNTY7XG5sZXQgX19zaGE1MTIgPSBfc2hhNTEyO1xubGV0IGxvY2tlZDI1NiA9IGZhbHNlLCBsb2NrZWQ1MTIgPSBmYWxzZTtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi0yNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgc2hhMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGEyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGEyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fc2hhMjU2KGRhdGEpKTtcbn1cbnNoYTI1Ni5fID0gX3NoYTI1NjtcbnNoYTI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQyNTYgPSB0cnVlOyB9O1xuc2hhMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkMjU2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2hhMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItNTEyIGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTUxMihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhNTEyKFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhNTEyKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYTUxMihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fc2hhNTEyKGRhdGEpKTtcbn1cbnNoYTUxMi5fID0gX3NoYTUxMjtcbnNoYTUxMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQ1MTIgPSB0cnVlOyB9O1xuc2hhNTEyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTUxMiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2hhNTEyID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVIYXNoIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiX3NoYTI1NiIsImRhdGEiLCJ1cGRhdGUiLCJkaWdlc3QiLCJfc2hhNTEyIiwiX19zaGEyNTYiLCJfX3NoYTUxMiIsImxvY2tlZDI1NiIsImxvY2tlZDUxMiIsInNoYTI1NiIsIl9kYXRhIiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJFcnJvciIsIk9iamVjdCIsImZyZWV6ZSIsInNoYTUxMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */ class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */ get r() {\n        return this.#r;\n    }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */ get s() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parseInt(this.#s.substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", this.#s);\n        return this.#s;\n    }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        this.#s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\n    }\n    /**\n     *  Return the s value, unchecked for EIP-2 compliance.\n     *\n     *  This should generally not be used and is for situations where\n     *  a non-canonical S value might be relevant, such as Frontier blocks\n     *  that were mined prior to EIP-2 or invalid Authorization List\n     *  signatures.\n     */ get _s() {\n        return this.#s;\n    }\n    /**\n     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\n     */ isValid() {\n        return parseInt(this.#s.substring(0, 3)) < 8;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */ get v() {\n        return this.#v;\n    }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get networkV() {\n        return this.#networkV;\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */ get yParity() {\n        return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */ get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */ get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.yParityAndS\n        ]);\n    }\n    /**\n     *  The serialized representation.\n     */ get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.s,\n            this.yParity ? \"0x1c\" : \"0x1b\"\n        ]);\n    }\n    /**\n     *  @private\n     */ constructor(guard, r, s, v){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return `Signature { r: \"${this.r}\", s: \"${this._s}\"${this.isValid() ? \"\" : ', valid: \"false\"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */ clone() {\n        const clone = new Signature(_guard, this.r, this._s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */ toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: networkV != null ? networkV.toString() : null,\n            r: this.r,\n            s: this._s,\n            v: this.v\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */ static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if (bv == BN_27 || bv == BN_28) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */ static getChainIdV(chainId, v) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */ static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */ static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, 27);\n        }\n        if (typeof sig === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = s[0] & 0x80 ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(32, 64));\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, s, v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = function(s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        }(sig.s, sig.yParityAndS);\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = function(_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_v);\n                return {\n                    networkV: v >= BN_35 ? v : undefined,\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return {\n                    v: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n                };\n            }\n            if (yParity != null) {\n                switch((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(yParity, \"sig.yParity\")){\n                    case 0:\n                        return {\n                            v: 27\n                        };\n                    case 1:\n                        return {\n                            v: 28\n                        };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n} //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNvSDtBQUNySyxZQUFZO0FBQ1osTUFBTVksT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsUUFBUUgsT0FBTztBQUNyQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLFFBQVFMLE9BQU87QUFDckIsTUFBTU0sU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLFVBQVVDLEtBQUs7SUFDcEIsT0FBT1osNkRBQVlBLENBQUNGLDBEQUFTQSxDQUFDYyxRQUFRO0FBQzFDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQztJQUNULENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7OztLQUtDLEdBQ0QsSUFBSUgsSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFBRTtJQUMxQixJQUFJQSxFQUFFRixLQUFLLEVBQUU7UUFDVFgsK0RBQWNBLENBQUNSLDJEQUFVQSxDQUFDbUIsV0FBVyxJQUFJLGFBQWEsU0FBU0E7UUFDL0QsSUFBSSxDQUFDLENBQUNFLENBQUMsR0FBR2pCLHdEQUFPQSxDQUFDZTtJQUN0QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUcsSUFBSTtRQUNKZCwrREFBY0EsQ0FBQ2lCLFNBQVMsSUFBSSxDQUFDLENBQUNILENBQUMsQ0FBQ0ksU0FBUyxDQUFDLEdBQUcsTUFBTSxHQUFHLDRCQUE0QixLQUFLLElBQUksQ0FBQyxDQUFDSixDQUFDO1FBQzlGLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFDbEI7SUFDQSxJQUFJQSxFQUFFSyxNQUFNLEVBQUU7UUFDVm5CLCtEQUFjQSxDQUFDUiwyREFBVUEsQ0FBQzJCLFlB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QzNCO2dCQUNBMkIsWUFBWSxPQUFPO1lBQ3ZCO1lBQ0FBLFlBQVksT0FBTztRQUN2QixFQUFHRCxJQUFJMUIsQ0FBQyxFQUFFMEIsSUFBSWhCLFdBQVcsRUFBRWdCLElBQUlqQixPQUFPO1FBQ3RDLE1BQU0yQixTQUFTLElBQUl2QyxVQUFVSCxRQUFRSSxHQUFHQyxHQUFHQztRQUMzQyxJQUFJQyxVQUFVO1lBQ1ZtQyxPQUFPLENBQUNuQyxRQUFRLEdBQUdBO1FBQ3ZCO1FBQ0Esb0VBQW9FO1FBQ3BFMEIsWUFBWUQsSUFBSWpCLE9BQU8sSUFBSSxRQUFRN0IsMERBQVNBLENBQUM4QyxJQUFJakIsT0FBTyxFQUFFLG1CQUFtQjJCLE9BQU8zQixPQUFPLEVBQUU7UUFDN0ZrQixZQUFZRCxJQUFJaEIsV0FBVyxJQUFJLFFBQVFnQixJQUFJaEIsV0FBVyxLQUFLMEIsT0FBTzFCLFdBQVcsRUFBRTtRQUMvRSxPQUFPMEI7SUFDWDtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanM/YzAxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBaZXJvSGFzaCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gdG9VaW50MjU2KHZhbHVlKSB7XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCAzMik7XG59XG4vKipcbiAqICBBIFNpZ25hdHVyZSAgQFRPRE9cbiAqXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlNpZ25pbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgI3I7XG4gICAgI3M7XG4gICAgI3Y7XG4gICAgI25ldHdvcmtWO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGByYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFRoaXMgcmVwcmVzZW50cyB0aGUgYGB4YGAgY29vcmRpbmF0ZSBvZiBhIFwicmVmZXJlbmNlXCIgb3JcbiAgICAgKiAgY2hhbGxlbmdlIHBvaW50LCBmcm9tIHdoaWNoIHRoZSBgYHlgYCBjYW4gYmUgY29tcHV0ZWQuXG4gICAgICovXG4gICAgZ2V0IHIoKSB7IHJldHVybiB0aGlzLiNyOyB9XG4gICAgc2V0IHIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aCh2YWx1ZSkgPT09IDMyLCBcImludmFsaWQgclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jciA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgc2BgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgcygpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyc2VJbnQodGhpcy4jcy5zdWJzdHJpbmcoMCwgMykpIDwgOCwgXCJub24tY2Fub25pY2FsIHM7IHVzZSAuX3NcIiwgXCJzXCIsIHRoaXMuI3MpO1xuICAgICAgICByZXR1cm4gdGhpcy4jcztcbiAgICB9XG4gICAgc2V0IHMoX3ZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoX3ZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCBzXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgdGhpcy4jcyA9IGhleGxpZnkoX3ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcyB2YWx1ZSwgdW5jaGVja2VkIGZvciBFSVAtMiBjb21wbGlhbmNlLlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBhbmQgaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmVcbiAgICAgKiAgYSBub24tY2Fub25pY2FsIFMgdmFsdWUgbWlnaHQgYmUgcmVsZXZhbnQsIHN1Y2ggYXMgRnJvbnRpZXIgYmxvY2tzXG4gICAgICogIHRoYXQgd2VyZSBtaW5lZCBwcmlvciB0byBFSVAtMiBvciBpbnZhbGlkIEF1dGhvcml6YXRpb24gTGlzdFxuICAgICAqICBzaWduYXR1cmVzLlxuICAgICAqL1xuICAgIGdldCBfcygpIHsgcmV0dXJuIHRoaXMuI3M7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSBTaWduYXR1cmUgaXMgdmFsaWQgZm9yIFtbbGluay1laXAtMl1dIHNpZ25hdHVyZXMuXG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIChwYXJzZUludCh0aGlzLiNzLnN1YnN0cmluZygwLCAzKSkgPCA4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxuICAgICAqICB2YWx1ZXMgdG8gdXNlLlxuICAgICAqXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcbiAgICAgKiAgcHVycG9zZXMuXG4gICAgICovXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XG4gICAgc2V0IHYodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9IGdldEJ5dGVzKHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnlQYXJpdHkpIHtcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoeVBhcml0eUFuZFMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IGNvbXBhY3RTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMucywgKHRoaXMueVBhcml0eSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJTaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMuI3IgPSByO1xuICAgICAgICB0aGlzLiNzID0gcztcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgICAgIHRoaXMuI25ldHdvcmtWID0gbnVsbDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6IFwiJHt0aGlzLnJ9XCIsIHM6IFwiJHt0aGlzLl9zfVwiJHt0aGlzLmlzVmFsaWQoKSA/IFwiXCIgOiAnLCB2YWxpZDogXCJmYWxzZVwiJ30sIHlQYXJpdHk6ICR7dGhpcy55UGFyaXR5fSwgbmV0d29ya1Y6ICR7dGhpcy5uZXR3b3JrVn0gfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IGlkZW50aWNhbCBbW1NpZ25hdHVyZV1dLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCB0aGlzLnIsIHRoaXMuX3MsIHRoaXMudik7XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmtWKSB7XG4gICAgICAgICAgICBjbG9uZS4jbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgYEpTT04uc3RyaW5naWZ5YGAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgICAgICAgIG5ldHdvcmtWOiAoKG5ldHdvcmtWICE9IG51bGwpID8gbmV0d29ya1YudG9TdHJpbmcoKSA6IG51bGwpLFxuICAgICAgICAgICAgcjogdGhpcy5yLCBzOiB0aGlzLl9zLCB2OiB0aGlzLnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBjaGFpbiBJRCBmcm9tIHRoZSBgYHZgYCBpbiBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZCg0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWQodikge1xuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2LCBcInZcIik7XG4gICAgICAgIC8vIFRoZSB2IGlzIG5vdCBhbiBFSVAtMTU1IHYsIHNvIGl0IGlzIHRoZSB1bnNwZWNpZmllZCBjaGFpbiBJRFxuICAgICAgICBpZiAoKGJ2ID09IEJOXzI3KSB8fCAoYnYgPT0gQk5fMjgpKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWQgdmFsdWUgZm9yIGFuIEVJUC0xNTUgdlxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIEVJUC0xNTUgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIHJldHVybiAoYnYgLSBCTl8zNSkgLyBCTl8yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgYGB2YGAgZm9yIGEgY2hhaW4gSUQgZm9yIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIExlZ2FjeSB0cmFuc2FjdGlvbnMgd2hpY2ggdXNlIFtbbGluay1laXAtMTU1XV0gaGlqYWNrIHRoZSBgYHZgYFxuICAgICAqICBwcm9wZXJ0eSB0byBpbmNsdWRlIHRoZSBjaGFpbiBJRC5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI4KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkVihjaGFpbklkLCB2KSB7XG4gICAgICAgIHJldHVybiAoZ2V0QmlnSW50KGNoYWluSWQpICogQk5fMikgKyBCaWdJbnQoMzUgKyB2IC0gMjcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgbm9ybWFsaXplZCBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgZnJvbSBhIGBgeVBhcmlydHlgYCxcbiAgICAgKiAgYSBsZWdhY3kgdHJhbnNhY3Rpb24gYGB2YGAgb3IgYSBsZWdhY3kgW1tsaW5rLWVpcC0xNTVdXSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICAvLyBUaGUgdmFsdWVzIDAgYW5kIDEgaW1wbHkgdiBpcyBhY3R1YWxseSB5UGFyaXR5XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDApXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IG5vbi1FSVAtMTU1OSB0cmFuc2FjdGlvbiAoaS5lLiAyNyBvciAyOClcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMjcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gTGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb24gKGkuZS4gPj0gMzUpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIEludmFsaWQgdmFsdWVzIHRocm93XG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDUpXG4gICAgICogICAgLy9fZXJyb3I6XG4gICAgICovXG4gICAgc3RhdGljIGdldE5vcm1hbGl6ZWRWKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodik7XG4gICAgICAgIGlmIChidiA9PT0gQk5fMCB8fCBidiA9PT0gQk5fMjcpIHtcbiAgICAgICAgICAgIHJldHVybiAyNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnYgPT09IEJOXzEgfHwgYnYgPT09IEJOXzI4KSB7XG4gICAgICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBFSVAtMTU1IHYgbWVhbnMgb2RkIGlzIDI3IGFuZCBldmVuIGlzIDI4XG4gICAgICAgIHJldHVybiAoYnYgJiBCTl8xKSA/IDI3IDogMjg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbU2lnbmF0dXJlXV0uXG4gICAgICpcbiAgICAgKiAgSWYgbm8gJSVzaWclJSBpcyBwcm92aWRlZCwgYSBuZXcgW1tTaWduYXR1cmVdXSBpcyBjcmVhdGVkXG4gICAgICogIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVzaWclJSBpcyBhIHN0cmluZywgaXQgaXMgcGFyc2VkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHNpZykge1xuICAgICAgICBmdW5jdGlvbiBhc3NlcnRFcnJvcihjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIFwic2lnbmF0dXJlXCIsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoc2lnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgWmVyb0hhc2gsIFplcm9IYXNoLCAyNyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoc2lnKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhzaWcsIFwic2lnbmF0dXJlXCIpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zbGljZSgzMiwgNjQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoc1swXSAmIDB4ODApID8gMjggOiAyNztcbiAgICAgICAgICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBoZXhsaWZ5KHMpLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKGJ5dGVzWzY0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgcmF3IHNpZ25hdHVyZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByXG4gICAgICAgIGNvbnN0IF9yID0gc2lnLnI7XG4gICAgICAgIGFzc2VydEVycm9yKF9yICE9IG51bGwsIFwibWlzc2luZyByXCIpO1xuICAgICAgICBjb25zdCByID0gdG9VaW50MjU2KF9yKTtcbiAgICAgICAgLy8gR2V0IHM7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCBzID0gKGZ1bmN0aW9uIChzLCB5UGFyaXR5QW5kUykge1xuICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQyNTYocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eUFuZFMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGlzSGV4U3RyaW5nKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHlQYXJpdHlBbmRTKTtcbiAgICAgICAgICAgICAgICBieXRlc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3Npbmcgc1wiKTtcbiAgICAgICAgfSkoc2lnLnMsIHNpZy55UGFyaXR5QW5kUyk7XG4gICAgICAgIC8vIEdldCB2OyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrViwgdiB9ID0gKGZ1bmN0aW9uIChfdiwgeVBhcml0eUFuZFMsIHlQYXJpdHkpIHtcbiAgICAgICAgICAgIGlmIChfdiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGdldEJpZ0ludChfdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Y6ICgodiA+PSBCTl8zNSkgPyB2IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKHYpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHY6ICgoZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpWzBdICYgMHg4MCkgPyAyOCA6IDI3KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2V0TnVtYmVyKHlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4geyB2OiAyNyB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB7IHY6IDI4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEVycm9yKGZhbHNlLCBcIm1pc3NpbmcgdlwiKTtcbiAgICAgICAgfSkoc2lnLnYsIHNpZy55UGFyaXR5QW5kUywgc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgcywgdik7XG4gICAgICAgIGlmIChuZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IG5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG9mIHYsIHlQYXJpdHksIHlQYXJpdHlBbmRTIHdlIGdpdmVuLCBjaGVjayB0aGV5IG1hdGNoXG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5ID09IG51bGwgfHwgZ2V0TnVtYmVyKHNpZy55UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpID09PSByZXN1bHQueVBhcml0eSwgXCJ5UGFyaXR5IG1pc21hdGNoXCIpO1xuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eUFuZFMgPT0gbnVsbCB8fCBzaWcueVBhcml0eUFuZFMgPT09IHJlc3VsdC55UGFyaXR5QW5kUywgXCJ5UGFyaXR5QW5kUyBtaXNtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbIlplcm9IYXNoIiwiY29uY2F0IiwiZGF0YUxlbmd0aCIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0TnVtYmVyIiwiaGV4bGlmeSIsInRvQmVBcnJheSIsImlzSGV4U3RyaW5nIiwiemVyb1BhZFZhbHVlIiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnRQcml2YXRlIiwiQk5fMCIsIkJpZ0ludCIsIkJOXzEiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwiX2d1YXJkIiwidG9VaW50MjU2IiwidmFsdWUiLCJTaWduYXR1cmUiLCJyIiwicyIsInYiLCJuZXR3b3JrViIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiX3ZhbHVlIiwiX3MiLCJpc1ZhbGlkIiwibGVnYWN5Q2hhaW5JZCIsImdldENoYWluSWQiLCJ5UGFyaXR5IiwieVBhcml0eUFuZFMiLCJjb21wYWN0U2VyaWFsaXplZCIsInNlcmlhbGl6ZWQiLCJjb25zdHJ1Y3RvciIsImd1YXJkIiwiU3ltYm9sIiwiZm9yIiwiY2xvbmUiLCJ0b0pTT04iLCJfdHlwZSIsInRvU3RyaW5nIiwiYnYiLCJnZXRDaGFpbklkViIsImNoYWluSWQiLCJnZXROb3JtYWxpemVkViIsImZyb20iLCJzaWciLCJhc3NlcnRFcnJvciIsImNoZWNrIiwibWVzc2FnZSIsImJ5dGVzIiwibGVuZ3RoIiwic2xpY2UiLCJfciIsIl92IiwidW5kZWZpbmVkIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signature.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */ \n\n\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */ class SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */ constructor(privateKey){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */ get privateKey() {\n        return this.#privateKey;\n    }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */ get publicKey() {\n        return SigningKey.computePublicKey(this.#privateKey);\n    }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */ get compressedPublicKey() {\n        return SigningKey.computePublicKey(this.#privateKey, true);\n    }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */ sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.r, 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.s, 32),\n            v: sig.recovery ? 0x1c : 0x1b\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */ computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */ static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */ static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(signature);\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            sig.r,\n            sig.s\n        ])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */ static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n} //# sourceMappingURL=signing-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDbUQ7QUFDNkQ7QUFDdEU7QUFDM0M7OztDQUdDLEdBQ00sTUFBTVM7SUFDVCxDQUFDQyxVQUFVLENBQUM7SUFDWjs7S0FFQyxHQUNEQyxZQUFZRCxVQUFVLENBQUU7UUFDcEJILCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ1EsZ0JBQWdCLElBQUksdUJBQXVCLGNBQWM7UUFDbkYsSUFBSSxDQUFDLENBQUNBLFVBQVUsR0FBR0wsd0RBQU9BLENBQUNLO0lBQy9CO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsVUFBVTtJQUFFO0lBQzVDOzs7OztLQUtDLEdBQ0QsSUFBSUUsWUFBWTtRQUFFLE9BQU9ILFdBQVdJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDSCxVQUFVO0lBQUc7SUFDeEU7Ozs7OztLQU1DLEdBQ0QsSUFBSUksc0JBQXNCO1FBQUUsT0FBT0wsV0FBV0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUNILFVBQVUsRUFBRTtJQUFPO0lBQ3hGOztLQUVDLEdBQ0RLLEtBQUtDLE1BQU0sRUFBRTtRQUNUVCwrREFBY0EsQ0FBQ0wsMkRBQVVBLENBQUNjLFlBQVksSUFBSSx5QkFBeUIsVUFBVUE7UUFDN0UsTUFBTUMsTUFBTWpCLDhEQUFTQSxDQUFDZSxJQUFJLENBQUNYLDZEQUFZQSxDQUFDWSxTQUFTWiw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sVUFBVSxHQUFHO1lBQzdFUSxNQUFNO1FBQ1Y7UUFDQSxPQUFPVixvREFBU0EsQ0FBQ1csSUFBSSxDQUFDO1lBQ2xCQyxHQUFHZCx3REFBT0EsQ0FBQ1csSUFBSUcsQ0FBQyxFQUFFO1lBQ2xCQyxHQUFHZix3REFBT0EsQ0FBQ1csSUFBSUksQ0FBQyxFQUFFO1lBQ2xCQyxHQUFJTCxJQUFJTSxRQUFRLEdBQUcsT0FBTztRQUM5QjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEQyxvQkFBb0JDLEtBQUssRUFBRTtRQUN2QixNQUFNQyxTQUFTakIsV0FBV0ksZ0JBQWdCLENBQUNZO1FBQzNDLE9BQU9wQix3REFBT0EsQ0FBQ0wsOERBQVNBLENBQUMyQixlQUFlLENBQUN2Qiw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sVUFBVSxHQUFHUCx5REFBUUEsQ0FBQ3VCLFNBQVM7SUFDL0Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBd0JDLEdBQ0QsT0FBT2IsaUJBQWlCZSxHQUFHLEVBQUVDLFVBQVUsRUFBRTtRQUNyQyxJQUFJQyxRQUFRM0IseURBQVFBLENBQUN5QixLQUFLO1FBQzFCLGNBQWM7UUFDZCxJQUFJRSxNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNTCxTQUFTMUIsOERBQVNBLENBQUNnQyxZQUFZLENBQUNGLE9BQU8sQ0FBQyxDQUFDRDtZQUMvQyxPQUFPeEIsd0RBQU9BLENBQUNxQjtRQUNuQjtRQUNBLHdEQUF3RDtRQUN4RCxJQUFJSSxNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNRSxNQUFNLElBQUlDLFdBQVc7WUFDM0JELEdBQUcsQ0FBQyxFQUFFLEdBQUc7WUFDVEEsSUFBSUUsR0FBRyxDQUFDTCxPQUFPO1lBQ2ZBLFFBQVFHO1FBQ1o7UUFDQSxNQUFNRyxRQUFRcEMsOERBQVNBLENBQUNxQyxlQUFlLENBQUNDLE9BQU8sQ0FBQ1I7UUFDaEQsT0FBT3pCLHdEQUFPQSxDQUFDK0IsTUFBTUcsVUFBVSxDQUFDVjtJQUNwQztJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztLQWlCQyxHQUNELE9BQU9XLGlCQUFpQnhCLE1BQU0sRUFBRXlCLFNBQVMsRUFBRTtRQUN2Q2xDLCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ2MsWUFBWSxJQUFJLHlCQUF5QixVQUFVQTtRQUM3RSxNQUFNQyxNQUFNVCxvREFBU0EsQ0FBQ1csSUFBSSxDQUFDc0I7UUFDM0IsSUFBSUMsVUFBVTFDLDhEQUFTQSxDQUFDUSxTQUFTLENBQUNtQyxXQUFXLENBQUN2Qyw2REFBWUEsQ0FBQ0gsdURBQU1BLENBQUM7WUFBQ2dCLElBQUlHLENBQUM7WUFBRUgsSUFBSUksQ0FBQztTQUFDO1FBQ2hGcUIsVUFBVUEsUUFBUUUsY0FBYyxDQUFDM0IsSUFBSTRCLE9BQU87UUFDNUMsTUFBTW5CLFNBQVNnQixRQUFRRixnQkFBZ0IsQ0FBQ3BDLDZEQUFZQSxDQUFDWTtRQUNyRFQsK0RBQWNBLENBQUNtQixVQUFVLE1BQU0sZ0NBQWdDLGFBQWFlO1FBQzVFLE9BQU8sT0FBT2YsT0FBT29CLEtBQUssQ0FBQztJQUMvQjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE9BQU9DLFVBQVVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFcEIsVUFBVSxFQUFFO1FBQ2pDLE1BQU1xQixPQUFPbEQsOERBQVNBLENBQUNxQyxlQUFlLENBQUNDLE9BQU8sQ0FBQzdCLFdBQVdJLGdCQUFnQixDQUFDbUMsSUFBSUcsU0FBUyxDQUFDO1FBQ3pGLE1BQU1DLE9BQU9wRCw4REFBU0EsQ0FBQ3FDLGVBQWUsQ0FBQ0MsT0FBTyxDQUFDN0IsV0FBV0ksZ0JBQWdCLENBQUNvQyxJQUFJRSxTQUFTLENBQUM7UUFDekYsT0FBTyxPQUFPRCxLQUFLRyxHQUFHLENBQUNELE1BQU1OLEtBQUssQ0FBQyxDQUFDLENBQUNqQjtJQUN6QztBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduaW5nLWtleS5qcz80OGVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEFkZCBkZXRhaWxzIGFib3V0IHNpZ25pbmcgaGVyZS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlNpZ25pbmcgIFthYm91dC1zaWduaW5nXVxuICovXG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgdG9CZUhleCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuL3NpZ25hdHVyZS5qc1wiO1xuLyoqXG4gKiAgQSAqKlNpZ25pbmdLZXkqKiBwcm92aWRlcyBoaWdoLWxldmVsIGFjY2VzcyB0byB0aGUgZWxsaXB0aWMgY3VydmVcbiAqICBjcnlwdG9ncmFwaHkgKEVDQykgb3BlcmF0aW9ucyBhbmQga2V5IG1hbmFnZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcbiAgICAjcHJpdmF0ZUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNpZ25pbmdLZXkqKiBmb3IgJSVwcml2YXRlS2V5JSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHByaXZhdGVLZXkpID09PSAzMiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI3ByaXZhdGVLZXkgPSBoZXhsaWZ5KHByaXZhdGVLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByaXZhdGUga2V5LlxuICAgICAqL1xuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy4jcHJpdmF0ZUtleTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYDB4MDRgYCBhbmQgYmUgMTMyXG4gICAgICogY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMTMwIGhleGFkZWNpbWFsIG5pYmJsZXMpLlxuICAgICAqL1xuICAgIGdldCBwdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYWx3YXlzIGJlZ2luIHdpdGggZWl0aGVyIHRoZSBwcmVmaXggYGAweDAyYGAgb3IgYGAweDAzYGBcbiAgICAgKiAgYW5kIGJlIDY4IGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDMzIGhleGFkZWNpbWFsXG4gICAgICogIG5pYmJsZXMpXG4gICAgICovXG4gICAgZ2V0IGNvbXByZXNzZWRQdWJsaWNLZXkoKSB7IHJldHVybiBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkodGhpcy4jcHJpdmF0ZUtleSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCAlJWRpZ2VzdCUlLlxuICAgICAqL1xuICAgIHNpZ24oZGlnZXN0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKGdldEJ5dGVzQ29weShkaWdlc3QpLCBnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIHtcbiAgICAgICAgICAgIGxvd1M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB0b0JlSGV4KHNpZy5yLCAzMiksXG4gICAgICAgICAgICBzOiB0b0JlSGV4KHNpZy5zLCAzMiksXG4gICAgICAgICAgICB2OiAoc2lnLnJlY292ZXJ5ID8gMHgxYyA6IDB4MWIpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgW1tsaW5rLXdpa2ktZWNkaF1dIHNoYXJlZCBzZWNyZXQgYmV0d2VlbiB0aGlzXG4gICAgICogIHByaXZhdGUga2V5IGFuZCB0aGUgJSVvdGhlciUlIGtleS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVvdGhlciUlIGtleSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LFxuICAgICAqICBhIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmljIGtleSBvciBhcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQmVzdCBwcmFjdGljZSBpcyB1c3VhbGx5IHRvIHVzZSBhIGNyeXB0b2dyYXBoaWMgaGFzaCBvbiB0aGVcbiAgICAgKiAgcmV0dXJuZWQgdmFsdWUgYmVmb3JlIHVzaW5nIGl0IGFzIGEgc3ltZXRyaWMgc2VjcmV0LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24xID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0xXCIpKVxuICAgICAqICAgIHNpZ24yID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldC0yXCIpKVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoYXQgcHJpdkEuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJCKS4uLlxuICAgICAqICAgIHNpZ24xLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjIucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHByaXZCLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQSkuXG4gICAgICogICAgc2lnbjIuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMS5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIGNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChnZXRCeXRlc0NvcHkodGhpcy4jcHJpdmF0ZUtleSksIGdldEJ5dGVzKHB1YktleSksIGZhbHNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciAlJWtleSUlLCBvcHRpb25hbGx5ICUlY29tcHJlc3NlZCUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJWtleSUlIG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksIGFcbiAgICAgKiAgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHVibGljIGtleSBvciBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSk7XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSwgdHJ1ZSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgZmFsc2UpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIENvbXByZXNzZWQgYSBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCB0cnVlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgc3RhdGljIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzKGtleSwgXCJrZXlcIik7XG4gICAgICAgIC8vIHByaXZhdGUga2V5XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwMjU2azEuZ2V0UHVibGljS2V5KGJ5dGVzLCAhIWNvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocHViS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByYXcgcHVibGljIGtleTsgdXNlIHVuY29tcHJlc3NlZCBrZXkgd2l0aCAweDA0IHByZWZpeFxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgY29uc3QgcHViID0gbmV3IFVpbnQ4QXJyYXkoNjUpO1xuICAgICAgICAgICAgcHViWzBdID0gMHgwNDtcbiAgICAgICAgICAgIHB1Yi5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgYnl0ZXMgPSBwdWI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShwb2ludC50b1Jhd0J5dGVzKGNvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBwcml2YXRlIGtleSB3aGljaCBwcm9kdWNlZCB0aGVcbiAgICAgKiAgJSVzaWduYXR1cmUlJSBmb3IgdGhlIGdpdmVuICUlZGlnZXN0JSUuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAga2V5ID0gbmV3IFNpZ25pbmdLZXkoaWQoXCJzb21lLXNlY3JldFwiKSlcbiAgICAgKiAgICBkaWdlc3QgPSBpZChcImhlbGxvIHdvcmxkXCIpXG4gICAgICogICAgc2lnID0ga2V5LnNpZ24oZGlnZXN0KVxuICAgICAqXG4gICAgICogICAgLy8gTm90aWNlIHRoZSBzaWduZXIgcHVibGljIGtleS4uLlxuICAgICAqICAgIGtleS5wdWJsaWNLZXlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byB0aGUgcmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWcpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgbGV0IHNlY3BTaWcgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KGdldEJ5dGVzQ29weShjb25jYXQoW3NpZy5yLCBzaWcuc10pKSk7XG4gICAgICAgIHNlY3BTaWcgPSBzZWNwU2lnLmFkZFJlY292ZXJ5Qml0KHNpZy55UGFyaXR5KTtcbiAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcFNpZy5yZWNvdmVyUHVibGljS2V5KGdldEJ5dGVzQ29weShkaWdlc3QpKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHViS2V5ICE9IG51bGwsIFwiaW52YWxpZCBzaWduYXR1cmUgZm9yIGRpZ2VzdFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViS2V5LnRvSGV4KGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHBvaW50IHJlc3VsdGluZyBmcm9tIGFkZGluZyB0aGUgZWxsaXBpYyBjdXJ2ZSBwb2ludHNcbiAgICAgKiAgJSVwMCUlIGFuZCAlJXAxJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgYSBjb21tb24gZnVuY3Rpb24gbW9zdCBkZXZlbG9wZXJzIHNob3VsZCByZXF1aXJlLCBidXRcbiAgICAgKiAgY2FuIGJlIHVzZWZ1bCBmb3IgY2VydGFpbiBwcml2YWN5LXNwZWNpZmljIHRlY2huaXF1ZXMuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgW1tIRE5vZGVXYWxsZXRdXSB0byBjb21wdXRlIGNoaWxkXG4gICAgICogIGFkZHJlc3NlcyBmcm9tIHBhcmVudCBwdWJsaWMga2V5cyBhbmQgY2hhaW4gY29kZXMuXG4gICAgICovXG4gICAgc3RhdGljIGFkZFBvaW50cyhwMCwgcDEsIGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgcHViMCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDApLnN1YnN0cmluZygyKSk7XG4gICAgICAgIGNvbnN0IHB1YjEgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAxKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcHViMC5hZGQocHViMSkudG9IZXgoISFjb21wcmVzc2VkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLWtleS5qcy5tYXAiXSwibmFtZXMiOlsic2VjcDI1NmsxIiwiY29uY2F0IiwiZGF0YUxlbmd0aCIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsInRvQmVIZXgiLCJhc3NlcnRBcmd1bWVudCIsIlNpZ25hdHVyZSIsIlNpZ25pbmdLZXkiLCJwcml2YXRlS2V5IiwiY29uc3RydWN0b3IiLCJwdWJsaWNLZXkiLCJjb21wdXRlUHVibGljS2V5IiwiY29tcHJlc3NlZFB1YmxpY0tleSIsInNpZ24iLCJkaWdlc3QiLCJzaWciLCJsb3dTIiwiZnJvbSIsInIiLCJzIiwidiIsInJlY292ZXJ5IiwiY29tcHV0ZVNoYXJlZFNlY3JldCIsIm90aGVyIiwicHViS2V5IiwiZ2V0U2hhcmVkU2VjcmV0Iiwia2V5IiwiY29tcHJlc3NlZCIsImJ5dGVzIiwibGVuZ3RoIiwiZ2V0UHVibGljS2V5IiwicHViIiwiVWludDhBcnJheSIsInNldCIsInBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiZnJvbUhleCIsInRvUmF3Qnl0ZXMiLCJyZWNvdmVyUHVibGljS2V5Iiwic2lnbmF0dXJlIiwic2VjcFNpZyIsImZyb21Db21wYWN0IiwiYWRkUmVjb3ZlcnlCaXQiLCJ5UGFyaXR5IiwidG9IZXgiLCJhZGRQb2ludHMiLCJwMCIsInAxIiwicHViMCIsInN1YnN0cmluZyIsInB1YjEiLCJhZGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/id.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/id.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDQztBQUNoRDs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0UsR0FBR0MsS0FBSztJQUNwQixPQUFPSCwyREFBU0EsQ0FBQ0MsNERBQVdBLENBQUNFO0FBQ2pDLEVBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaWQuanM/NTQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsImlkIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/namehash.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */ function ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */ function isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */ function namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)([\n            result,\n            (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */ function dnsEncode(name, _maxLength) {\n    const length = _maxLength != null ? _maxLength : 63;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)(ensNameSplit(name).map((comp)=>{\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, \"name\", name);\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0M7QUFDa0M7QUFDMUI7QUFDdkQsTUFBTU0sUUFBUSxJQUFJQyxXQUFXO0FBQzdCRCxNQUFNRSxJQUFJLENBQUM7QUFDWCxTQUFTQyxlQUFlQyxJQUFJO0lBQ3hCUCwrREFBY0EsQ0FBQ08sS0FBS0MsTUFBTSxLQUFLLEdBQUcscUNBQXFDLFFBQVFEO0lBQy9FLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRSxhQUFhQyxJQUFJO0lBQ3RCLE1BQU1DLFFBQVFWLDREQUFXQSxDQUFDVyxhQUFhRjtJQUN2QyxNQUFNRyxRQUFRLEVBQUU7SUFDaEIsSUFBSUgsS0FBS0YsTUFBTSxLQUFLLEdBQUc7UUFDbkIsT0FBT0s7SUFDWDtJQUNBLElBQUlDLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosTUFBTUgsTUFBTSxFQUFFTyxJQUFLO1FBQ25DLE1BQU1DLElBQUlMLEtBQUssQ0FBQ0ksRUFBRTtRQUNsQiw4Q0FBOEM7UUFDOUMsSUFBSUMsTUFBTSxNQUFNO1lBQ1pILE1BQU1JLElBQUksQ0FBQ1gsZUFBZUssTUFBTU8sS0FBSyxDQUFDSixNQUFNQztZQUM1Q0QsT0FBT0MsSUFBSTtRQUNmO0lBQ0o7SUFDQSxxREFBcUQ7SUFDckRmLCtEQUFjQSxDQUFDYyxPQUFPSCxNQUFNSCxNQUFNLEVBQUUscUNBQXFDLFFBQVFFO0lBQ2pGRyxNQUFNSSxJQUFJLENBQUNYLGVBQWVLLE1BQU1PLEtBQUssQ0FBQ0o7SUFDdEMsT0FBT0Q7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU0QsYUFBYUYsSUFBSTtJQUM3QixJQUFJO1FBQ0EsSUFBSUEsS0FBS0YsTUFBTSxLQUFLLEdBQUc7WUFDbkIsTUFBTSxJQUFJVyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT2pCLHFFQUFhQSxDQUFDUTtJQUN6QixFQUNBLE9BQU9VLE9BQU87UUFDVnBCLCtEQUFjQSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRW9CLE1BQU1DLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRWDtJQUN6RTtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxTQUFTWSxZQUFZWixJQUFJO0lBQzVCLElBQUk7UUFDQSxPQUFRRCxhQUFhQyxNQUFNRixNQUFNLEtBQUs7SUFDMUMsRUFDQSxPQUFPWSxPQUFPLENBQUU7SUFDaEIsT0FBTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRyxTQUFTYixJQUFJO0lBQ3pCViwrREFBY0EsQ0FBQyxPQUFRVSxTQUFVLFVBQVUsa0NBQWtDLFFBQVFBO0lBQ3JGViwrREFBY0EsQ0FBQ1UsS0FBS0YsTUFBTSxFQUFFLENBQUMsOEJBQThCLENBQUMsRUFBRSxRQUFRRTtJQUN0RSxJQUFJYyxTQUFTckI7SUFDYixNQUFNVSxRQUFRSixhQUFhQztJQUMzQixNQUFPRyxNQUFNTCxNQUFNLENBQUU7UUFDakJnQixTQUFTM0IsMkRBQVNBLENBQUNDLHVEQUFNQSxDQUFDO1lBQUMwQjtZQUFRM0IsMkRBQVNBLENBQUVnQixNQUFNWSxHQUFHO1NBQUs7SUFDaEU7SUFDQSxPQUFPMUIsd0RBQU9BLENBQUN5QjtBQUNuQjtBQUNBOzs7OztDQUtDLEdBQ00sU0FBU0UsVUFBVWhCLElBQUksRUFBRWlCLFVBQVU7SUFDdEMsTUFBTW5CLFNBQVMsY0FBZSxPQUFRbUIsYUFBYTtJQUNuRDNCLCtEQUFjQSxDQUFDUSxVQUFVLEtBQUssdUNBQXVDLFVBQVVBO0lBQy9FLE9BQU9ULHdEQUFPQSxDQUFDRCx1REFBTUEsQ0FBQ1csYUFBYUMsTUFBTWtCLEdBQUcsQ0FBQyxDQUFDckI7UUFDMUNQLCtEQUFjQSxDQUFDTyxLQUFLQyxNQUFNLElBQUlBLFFBQVEsQ0FBQyxNQUFNLEVBQUVxQixLQUFLQyxTQUFTLENBQUNwQixNQUFNLFNBQVMsRUFBRUYsT0FBTyxNQUFNLENBQUMsRUFBRSxRQUFRRTtRQUN2RyxNQUFNQyxRQUFRLElBQUlQLFdBQVdHLEtBQUtDLE1BQU0sR0FBRztRQUMzQ0csTUFBTW9CLEdBQUcsQ0FBQ3hCLE1BQU07UUFDaEJJLEtBQUssQ0FBQyxFQUFFLEdBQUdBLE1BQU1ILE1BQU0sR0FBRztRQUMxQixPQUFPRztJQUNYLE9BQU87QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL25hbWVoYXNoLmpzP2U1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zTm9ybWFsaXplKG5hbWUpKTtcbiAgICBjb25zdCBjb21wcyA9IFtdO1xuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcHM7XG4gICAgfVxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XG4gICAgICAgIGlmIChkID09PSAweDJlKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICBhc3NlcnRBcmd1bWVudChsYXN0IDwgYnl0ZXMubGVuZ3RoLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEVOUyBuYW1lICgke2Vycm9yLm1lc3NhZ2V9KWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG5hbWUubGVuZ3RoLCBgaW52YWxpZCBFTlMgbmFtZSAoZW1wdHkgbGFiZWwpYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRE5TIGVuY29kZWQgJSVuYW1lJSUuXG4gKlxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXG4gKiAgYXMgdGhlIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSwgX21heExlbmd0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IChfbWF4TGVuZ3RoICE9IG51bGwpID8gX21heExlbmd0aCA6IDYzO1xuICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCA8PSAyNTUsIFwiRE5TIGVuY29kZWQgbGFiZWwgY2Fubm90IGV4Y2VlZCAyNTVcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCA8PSBsZW5ndGgsIGBsYWJlbCAke0pTT04uc3RyaW5naWZ5KG5hbWUpfSBleGNlZWRzICR7bGVuZ3RofSBieXRlc2AsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiY29uY2F0IiwiaGV4bGlmeSIsImFzc2VydEFyZ3VtZW50IiwidG9VdGY4Qnl0ZXMiLCJlbnNfbm9ybWFsaXplIiwiWmVyb3MiLCJVaW50OEFycmF5IiwiZmlsbCIsImNoZWNrQ29tcG9uZW50IiwiY29tcCIsImxlbmd0aCIsImVuc05hbWVTcGxpdCIsIm5hbWUiLCJieXRlcyIsImVuc05vcm1hbGl6ZSIsImNvbXBzIiwibGFzdCIsImkiLCJkIiwicHVzaCIsInNsaWNlIiwiRXJyb3IiLCJlcnJvciIsIm1lc3NhZ2UiLCJpc1ZhbGlkTmFtZSIsIm5hbWVoYXNoIiwicmVzdWx0IiwicG9wIiwiZG5zRW5jb2RlIiwiX21heExlbmd0aCIsIm1hcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder),\n/* harmony export */   verifyTypedData: () => (/* binding */ verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n            return function(_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function(value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: match[2] + match[4],\n            array: {\n                base: match[1],\n                prefix: match[1] + match[2],\n                count: match[5] ? parseInt(match[5]) : -1\n            }\n        };\n    }\n    return {\n        base: type\n    };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */ class TypedDataEncoder {\n    #types;\n    /**\n     *  The types.\n     */ get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */ constructor(_types){\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types).forEach((type)=>{\n            types[type] = _types[type].map(({ name, type })=>{\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return {\n                    name,\n                    type: base + (index || \"\")\n                };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        this.#types = JSON.stringify(types);\n        for(const name in types){\n            const uniqueNames = new Set();\n            for (const field of types[name]){\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n)=>parents.get(n).length === 0);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            primaryType: primaryTypes[0]\n        });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n            found.add(type);\n            for (const child of links.get(type)){\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found){\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes){\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */ getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            const subtype = array.prefix;\n            const subEncoder = this.getEncoder(subtype);\n            return (value)=>{\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256);\n                }\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(this.#fullTypes.get(type));\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n            };\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */ encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */ encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */ hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */ encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */ hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */ _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n            return value.map((v)=>this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */ visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */ static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */ static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */ static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */ static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */ static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for(const key in domain){\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for(const name in ensCache){\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return {\n            domain,\n            value\n        };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */ static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */ function verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_7__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSwyRkFBMkY7QUFDMUM7QUFDRjtBQUNVO0FBQ2dIO0FBQzVJO0FBQzdCLE1BQU1nQixVQUFVLElBQUlDLFdBQVc7QUFDL0JELFFBQVFFLElBQUksQ0FBQztBQUNiLE1BQU1DLFFBQVFDLE9BQU8sQ0FBQztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsaUJBQWlCSCxPQUFPOzs7QUFHOUIsU0FBU0ksWUFBWUMsS0FBSztJQUN0QixNQUFNQyxRQUFRcEIseURBQVFBLENBQUNtQjtJQUN2QixNQUFNRSxZQUFZRCxNQUFNRSxNQUFNLEdBQUc7SUFDakMsSUFBSUQsV0FBVztRQUNYLE9BQU94Qix1REFBTUEsQ0FBQztZQUFDdUI7WUFBT1YsUUFBUWEsS0FBSyxDQUFDRjtTQUFXO0lBQ25EO0lBQ0EsT0FBT3BCLHdEQUFPQSxDQUFDbUI7QUFDbkI7QUFDQSxNQUFNSSxVQUFVcEIsd0RBQU9BLENBQUNZLE1BQU07QUFDOUIsTUFBTVMsV0FBV3JCLHdEQUFPQSxDQUFDVyxNQUFNO0FBQy9CLE1BQU1XLG1CQUFtQjtJQUNyQkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsbUJBQW1CO0lBQ25CQyxNQUFNO0FBQ1Y7QUFDQSxNQUFNQyxtQkFBbUI7SUFDckI7SUFBUTtJQUFXO0lBQVc7SUFBcUI7Q0FDdEQ7QUFDRCxTQUFTQyxZQUFZQyxHQUFHO0lBQ3BCLE9BQU8sU0FBVWYsS0FBSztRQUNsQlgsK0RBQWNBLENBQUMsT0FBUVcsVUFBVyxVQUFVLENBQUMseUJBQXlCLEVBQUVnQixLQUFLQyxTQUFTLENBQUNGLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFQSxJQUFJLENBQUMsRUFBRWY7UUFDaEgsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWtC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QVFvSDtBQUN2RSxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanM/MjFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXRCeXRlcywgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIG1hc2ssIHRvQmVIZXgsIHRvUXVhbnRpdHksIHRvVHdvcywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi9pZC5qc1wiO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IEJOX18xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG47XG47XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gdG9CZUhleChCTl8xLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IHRvQmVIZXgoQk5fMCwgMzIpO1xuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcbiAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IFwiYWRkcmVzc1wiLFxuICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG59O1xuY29uc3QgZG9tYWluRmllbGROYW1lcyA9IFtcbiAgICBcIm5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwiY2hhaW5JZFwiLCBcInZlcmlmeWluZ0NvbnRyYWN0XCIsIFwic2FsdFwiXG5dO1xuZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwiZG9tYWluLmNoYWluSWRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IDAsIFwiaW52YWxpZCBjaGFpbiBJRFwiLCBcImRvbWFpbi5jaGFpbklkXCIsIF92YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1F1YW50aXR5KHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJ2ZXJpZnlpbmdDb250cmFjdFwiYCwgXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2FsdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUsIFwiZG9tYWluLnNhbHRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14odT8paW50KFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHdpZHRoICUgOCA9PT0gMCAmJiB3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAyNTYgJiYgbWF0Y2hbMl0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gbWFzayhCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/ICgoYm91bmRzVXBwZXIgKyBCTl8xKSAqIEJOX18xKSA6IEJOXzA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSBib3VuZHNMb3dlciAmJiB2YWx1ZSA8PSBib3VuZHNVcHBlciwgYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9CZUhleChzaWduZWQgPyB0b1R3b3ModmFsdWUsIDI1NikgOiB2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBieXRlc1hYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDMyICYmIG1hdGNoWzFdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gd2lkdGgsIGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuLy8gZm9vW11bM10gPT4geyBiYXNlOiBcImZvb1wiLCBpbmRleDogXCJbXVszXVwiLCBhcnJheToge1xuLy8gICAgIGJhc2U6IFwiZm9vXCIsIHByZWZpeDogXCJmb29bXVwiLCBjb3VudDogMyB9IH1cbmZ1bmN0aW9uIHNwbGl0QXJyYXkodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXihbXlxceDViXSopKChcXHg1YlxcZCpcXHg1ZCkqKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgaW5kZXg6IChtYXRjaFsyXSArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGFycmF5OiB7XG4gICAgICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgcHJlZml4OiAobWF0Y2hbMV0gKyBtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgY291bnQ6IChtYXRjaFs1XSA/IHBhcnNlSW50KG1hdGNoWzVdKSA6IC0xKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYmFzZTogdHlwZSB9O1xufVxuLyoqXG4gKiAgQSAqKlR5cGVkRGF0YUVuY29kZSoqIHByZXBhcmVzIGFuZCBlbmNvZGVzIFtbbGluay1laXAtNzEyXV0gcGF5bG9hZHNcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXG4gKlxuICogIFRoaXMgaXMgdXNlZnVsIGZvciB0aG9zZSB0aGF0IHdpc2ggdG8gY29tcHV0ZSB2YXJpb3VzIGNvbXBvbmVudHMgb2YgYVxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXG4gKiAgaGlnaGVyIGxldmVsIFtbU2lnbmVyLXNpZ25UeXBlZERhdGFdXSBpcyBtb3JlIHVzZWZ1bC5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpbWFyeSB0eXBlIGZvciB0aGUgc3RydWN0dXJlZCBbW3R5cGVzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBkZXJpdmVkIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgW1t0eXBlc11dLCBzaW5jZSBub1xuICAgICAqICByZWN1cnNpb24gaXMgcG9zc2libGUsIG9uY2UgdGhlIERBRyBmb3IgdGhlIHR5cGVzIGlzIGNvbnN0dXJjdGVkXG4gICAgICogIGludGVybmFsbHksIHRoZSBwcmltYXJ5IHR5cGUgbXVzdCBiZSB0aGUgb25seSByZW1haW5pbmcgdHlwZSB3aXRoXG4gICAgICogIG5vIHBhcmVudCBub2Rlcy5cbiAgICAgKi9cbiAgICBwcmltYXJ5VHlwZTtcbiAgICAjdHlwZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuI3R5cGVzKTtcbiAgICB9XG4gICAgI2Z1bGxUeXBlcztcbiAgICAjZW5jb2RlckNhY2hlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHBlcmZvcm1zIGFsbCBuZWNlc3NhcnkgY2hlY2tpbmcgdGhhdCB0eXBlcyBhcmUgdmFsaWQgYW5kXG4gICAgICogIGRvIG5vdCB2aW9sYXRlIHRoZSBbW2xpbmstZWlwLTcxMl1dIHN0cnVjdHVyYWwgY29uc3RyYWludHMgYXNcbiAgICAgKiAgd2VsbCBhcyBjb21wdXRlcyB0aGUgW1twcmltYXJ5VHlwZV1dLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF90eXBlcykge1xuICAgICAgICB0aGlzLiNmdWxsVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcbiAgICAgICAgY29uc3QgbGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0cyB0byBzdHJ1Y3RzIHdoaWNoIGNvbnRhaW4gdGhlbSBhcyBhIGNoaWxkXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IF90eXBlc1t0eXBlXS5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBiYXNlIHR5cGUgKHVubGVzcyBuYW1lIGNvbmZsaWN0KVxuICAgICAgICAgICAgICAgIGxldCB7IGJhc2UsIGluZGV4IH0gPSBzcGxpdEFycmF5KHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSBcImludFwiICYmICFfdHlwZXNbXCJpbnRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwiaW50MjU2XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSBcInVpbnRcIiAmJiAhX3R5cGVzW1widWludFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gXCJ1aW50MjU2XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHR5cGU6IChiYXNlICsgKGluZGV4IHx8IFwiXCIpKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaW5rcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgIHBhcmVudHMuc2V0KHR5cGUsIFtdKTtcbiAgICAgICAgICAgIHN1YnR5cGVzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdHlwZXMgPSBKU09OLnN0cmluZ2lmeSh0eXBlcyk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBzcGxpdEFycmF5KGZpZWxkLnR5cGUpLmJhc2U7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYmFzZVR5cGUgIT09IG5hbWUsIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGJhc2UgZW5jb2RpbmcgdHlwZT9cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJlbnRzLmhhcyhiYXNlVHlwZSksIGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgcGFyZW50cy5nZXQoYmFzZVR5cGUpLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgbGlua3MuZ2V0KG5hbWUpLmFkZChiYXNlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdWNlIHRoZSBwcmltYXJ5IHR5cGVcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGVzID0gQXJyYXkuZnJvbShwYXJlbnRzLmtleXMoKSkuZmlsdGVyKChuKSA9PiAocGFyZW50cy5nZXQobikubGVuZ3RoID09PSAwKSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAxLCBgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcmltYXJ5VHlwZTogcHJpbWFyeVR5cGVzWzBdIH0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSwgZm91bmQpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFmb3VuZC5oYXModHlwZSksIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbGlua3MuZ2V0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2V0XSBvZiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLiNmdWxsVHlwZXMuc2V0KG5hbWUsIGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnRoZSBlbmNvZGVyIGZvciB0aGUgc3BlY2lmaWMgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy4jZW5jb2RlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy4jZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZS5zZXQodHlwZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBhcnJheS5wcmVmaXg7XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHN1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoa2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVHlwZSA9IGlkKHRoaXMuI2Z1bGxUeXBlcy5nZXQodHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbCB0eXBlIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVsbFR5cGVzLmdldChuYW1lKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgaGFzaCBvZiAlJXZhbHVlJSUgZm9yIHRoZSB0eXBlIG9mICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbGVkIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYXJyYXkuY291bnQgPT09IC0xIHx8IGFycmF5LmNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke2FycmF5LmNvdW50fWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoYXJyYXkucHJlZml4LCB2LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZSgoYWNjdW0sIHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGwgJSVjYWxiYWNrJSUgZm9yIGVhY2ggdmFsdWUgaW4gJSV2YWx1ZSUlLCBwYXNzaW5nIHRoZSB0eXBlIGFuZFxuICAgICAqICBjb21wb25lbnQgd2l0aGluICUldmFsdWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgcmVwbGFjaW5nIGFkZHJlc3NlcyBvciBvdGhlciB0cmFuc2Zvcm1hdGlvbiB0aGF0XG4gICAgICogIG1heSBiZSBkZXNpcmVkIG9uIGVhY2ggY29tcG9uZW50LCBiYXNlZCBvbiBpdHMgdHlwZS5cbiAgICAgKi9cbiAgICB2aXNpdCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkRGF0YUVuY29kZXIodHlwZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBwcmltYXJ5IHR5cGUgZm9yICUldHlwZXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJpbWFyeVR5cGUodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2hlZCBzdHJ1Y3QgZm9yICUldmFsdWUlJSB1c2luZyAlJXR5cGVzJSUgYW5kICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoU3RydWN0KG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZG9tYWluIGhhc2ggZm9yICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hEb21haW4oZG9tYWluKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbkZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb21haW5GaWVsZFR5cGVzW25hbWVdO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZSwgYGludmFsaWQgdHlwZWQtZGF0YSBkb21haW4ga2V5OiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwiZG9tYWluXCIsIGRvbWFpbik7XG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlcyBhbGwgYWRkcmVzcyB0eXBlcyB3aXRoIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGxvb2tlZCB1cCBhZGRyZXNzXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gdGhlIHZhbHVlIGZyb20gcmVzb2x2aW5nIGFsbCBhZGRyZXNzZXMgaW4gJSV2YWx1ZSUlIGZvclxuICAgICAqICUldHlwZXMlJSBhbmQgdGhlICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgcmVzb2x2ZU5hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgIGRvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIGRvbWFpbik7XG4gICAgICAgIC8vIEFsbG93IHBhc3NpbmcgbnVsbCB0byBpZ25vcmUgdmFsdWVcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIGFsbCBFTlMgbmFtZXNcbiAgICAgICAgY29uc3QgZW5zQ2FjaGUgPSB7fTtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhaXNIZXhTdHJpbmcoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0gPSBcIjB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZW5jb2RlciB0byB2aXNpdCBhbGwgdGhlIGJhc2UgdmFsdWVzXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXG4gICAgICAgIGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmICFpc0hleFN0cmluZyh2YWx1ZSwgMjApKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTG9va3VwIGVhY2ggbmFtZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZW5zQ2FjaGUpIHtcbiAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0gYXdhaXQgcmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZG9tYWluIHZlcmlmeWluZ0NvbnRyYWN0IGlmIG5lZWRlZFxuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcbiAgICAgICAgICAgIGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCA9IGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xuICAgICAgICB2YWx1ZSA9IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmIGVuc0NhY2hlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBkb21haW4sIHZhbHVlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBKU09OLWVuY29kZWQgcGF5bG9hZCBleHBlY3RlZCBieSBub2RlcyB3aGljaCBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIEpTT04tUlBDIFtbbGluay1laXAtNzEyXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYXlsb2FkKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkb21haW4gZmllbGRzXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgY29uc3QgZG9tYWluVmFsdWVzID0ge307XG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XG4gICAgICAgIGRvbWFpbkZpZWxkTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb21haW5bbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgdHlwZXNcbiAgICAgICAgdHlwZXMgPSBlbmNvZGVyLnR5cGVzO1xuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPT0gbnVsbCwgXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcbiAgICAgICAgdHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9IGRvbWFpblR5cGVzO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xuICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxuICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogZW5jb2Rlci5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL15ieXRlcyhcXGQqKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGdldEJ5dGVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgb3IgaW50XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBDb21wdXRlIHRoZSBhZGRyZXNzIHVzZWQgdG8gc2lnbiB0aGUgdHlwZWQgZGF0YSBmb3IgdGhlICUlc2lnbmF0dXJlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlUeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhUeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpLCBzaWduYXR1cmUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQtZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImtlY2NhazI1NiIsInJlY292ZXJBZGRyZXNzIiwiY29uY2F0IiwiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiaGV4bGlmeSIsImlzSGV4U3RyaW5nIiwibWFzayIsInRvQmVIZXgiLCJ0b1F1YW50aXR5IiwidG9Ud29zIiwiemVyb1BhZFZhbHVlIiwiYXNzZXJ0QXJndW1lbnQiLCJpZCIsInBhZGRpbmciLCJVaW50OEFycmF5IiwiZmlsbCIsIkJOX18xIiwiQmlnSW50IiwiQk5fMCIsIkJOXzEiLCJCTl9NQVhfVUlOVDI1NiIsImhleFBhZFJpZ2h0IiwidmFsdWUiLCJieXRlcyIsInBhZE9mZnNldCIsImxlbmd0aCIsInNsaWNlIiwiaGV4VHJ1ZSIsImhleEZhbHNlIiwiZG9tYWluRmllbGRUeXBlcyIsIm5hbWUiLCJ2ZXJzaW9uIiwiY2hhaW5JZCIsInZlcmlmeWluZ0NvbnRyYWN0Iiwic2FsdCIsImRvbWFpbkZpZWxkTmFtZXMiLCJjaGVja1N0cmluZyIsImtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkb21haW5DaGVja3MiLCJfdmFsdWUiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwidG9Mb3dlckNhc2UiLCJlcnJvciIsImdldEJhc2VFbmNvZGVyIiwidHlwZSIsIm1hdGNoIiwic2lnbmVkIiwid2lkdGgiLCJwYXJzZUludCIsIlN0cmluZyIsImJvdW5kc1VwcGVyIiwiYm91bmRzTG93ZXIiLCJlbmNvZGVUeXBlIiwiZmllbGRzIiwibWFwIiwiam9pbiIsInNwbGl0QXJyYXkiLCJiYXNlIiwiaW5kZXgiLCJhcnJheSIsInByZWZpeCIsImNvdW50IiwiVHlwZWREYXRhRW5jb2RlciIsInR5cGVzIiwicGFyc2UiLCJmdWxsVHlwZXMiLCJlbmNvZGVyQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIl90eXBlcyIsIk1hcCIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzZXQiLCJTZXQiLCJ1bmlxdWVOYW1lcyIsImZpZWxkIiwiaGFzIiwiYWRkIiwiYmFzZVR5cGUiLCJlbmNvZGVyIiwiZ2V0IiwicHVzaCIsInByaW1hcnlUeXBlcyIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIm4iLCJ0IiwicHJpbWFyeVR5cGUiLCJjaGVja0NpcmN1bGFyIiwiZm91bmQiLCJjaGlsZCIsInN1YnR5cGUiLCJkZWxldGUiLCJzdCIsInNvcnQiLCJnZXRFbmNvZGVyIiwic3ViRW5jb2RlciIsInJlc3VsdCIsImVuY29kZWRUeXBlIiwidmFsdWVzIiwidW5zaGlmdCIsImVuY29kZURhdGEiLCJoYXNoU3RydWN0IiwiZW5jb2RlIiwiaGFzaCIsIl92aXNpdCIsImNhbGxiYWNrIiwidiIsInJlZHVjZSIsImFjY3VtIiwidmlzaXQiLCJnZXRQcmltYXJ5VHlwZSIsImhhc2hEb21haW4iLCJkb21haW4iLCJkb21haW5GaWVsZHMiLCJhIiwiYiIsImluZGV4T2YiLCJFSVA3MTJEb21haW4iLCJyZXNvbHZlTmFtZXMiLCJyZXNvbHZlTmFtZSIsImFzc2lnbiIsImVuc0NhY2hlIiwiZ2V0UGF5bG9hZCIsImRvbWFpblZhbHVlcyIsImRvbWFpblR5cGVzIiwidHlwZXNXaXRoRG9tYWluIiwibWVzc2FnZSIsInRvU3RyaW5nIiwidmVyaWZ5VHlwZWREYXRhIiwic2lnbmF0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* binding */ AbstractProvider),\n/* harmony export */   UnmanagedSubscriber: () => (/* binding */ UnmanagedSubscriber)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ens-resolver.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */ // @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v)=>{\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof v === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof v === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key)=>{\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */ class UnmanagedSubscriber {\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    start() {}\n    stop() {}\n    pause(dropWhilePaused) {}\n    resume() {}\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from(new Set(items).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = {\n            topics: _event\n        };\n    }\n    if (typeof _event === \"string\") {\n        switch(_event){\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\":\n                {\n                    return {\n                        type: _event,\n                        tag: _event\n                    };\n                }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n                hash\n            }),\n            hash\n        };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n        };\n    }\n    if (_event.address || _event.topics) {\n        const event = _event;\n        const filter = {\n            topics: (event.topics || []).map((t)=>{\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t)=>t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            })\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr)=>{\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async ()=>{\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a)=>a.toLowerCase()));\n        }\n        return {\n            filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n        };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */ class AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */ constructor(_network, options){\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_4__.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(()=>{\n                this.emit(\"network\", network, null);\n            }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() {\n        return this.#options.pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */ get provider() {\n        return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */ get disableCcipRead() {\n        return this.#disableCcipRead;\n    }\n    set disableCcipRead(value) {\n        this.#disableCcipRead = !!value;\n    }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(()=>{\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */ async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for(let i = 0; i < urls.length; i++){\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                    data,\n                    sender\n                };\n            }\n            this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request,\n                index: i,\n                urls\n            });\n            let errorMessage = \"unknown error\";\n            // Fetch the resource...\n            let resp;\n            try {\n                resp = await request.send();\n            } catch (error) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result: {\n                        error\n                    }\n                });\n                continue;\n            }\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadFetchResult\",\n                        request,\n                        result\n                    });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result\n                });\n            } catch (error) {}\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                    url,\n                    errorMessage\n                }\n            });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx,\n            info: {\n                urls,\n                errorMessages\n            }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */ _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */ _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */ _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */ _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */ _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */ async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#perform({\n            method: \"getBlockNumber\"\n        }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */ _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */ _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n        }\n        if (typeof blockTag === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof blockTag === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b)=>(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */ _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t)=>{\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t)=>t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock)=>{\n            let address = undefined;\n            switch(_address.length){\n                case 0:\n                    break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address){\n                    address.push(this._getAddress(addr));\n                }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a)=>typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n            return Promise.all([\n                Promise.all(address),\n                fromBlock,\n                toBlock\n            ]).then((result)=>{\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */ _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(_request);\n        const promises = [];\n        [\n            \"to\",\n            \"from\"\n        ].forEach((key)=>{\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push(async function() {\n                    request[key] = await addr;\n                }());\n            } else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push(async function() {\n                    request.blockTag = await blockTag;\n                }());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return async function() {\n                await Promise.all(promises);\n                return request;\n            }();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async ()=>{\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                } catch (error) {\n                    if (this.#networkPromise === detectNetwork) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async ()=>{\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: (async ()=>{\n                    try {\n                        const value = await this.#perform({\n                            method: \"getGasPrice\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })(),\n                priorityFee: (async ()=>{\n                    try {\n                        const value = await this.#perform({\n                            method: \"getPriorityFee\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })()\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#perform({\n            method: \"estimateGas\",\n            transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n                blockTag,\n                enableCcipRead: true\n            })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(tx);\n        try {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this._perform({\n                method: \"call\",\n                transaction,\n                blockTag\n            }));\n        } catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 4));\n                } catch (error) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\",\n                        transaction,\n                        info: {\n                            data\n                        }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\",\n                    transaction,\n                    info: {\n                        data: error.data,\n                        errorArgs: ccipArgs.errorArgs\n                    }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n                        ccipArgs.selector,\n                        encodeBytes([\n                            ccipResult,\n                            ccipArgs.extraData\n                        ])\n                    ])\n                };\n                this.emit(\"debug\", {\n                    action: \"sendCcipReadCall\",\n                    transaction: tx\n                });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallResult\",\n                        transaction: Object.assign({}, tx),\n                        result\n                    });\n                    return result;\n                } catch (error) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallError\",\n                        transaction: Object.assign({}, tx),\n                        error\n                    });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n            [address, blockTag] = await Promise.all([\n                address,\n                blockTag\n            ]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, {\n            address,\n            blockTag\n        })));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#getAccountValue({\n            method: \"getBalance\"\n        }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#getAccountValue({\n            method: \"getTransactionCount\"\n        }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getCode\"\n        }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getStorage\",\n            position\n        }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\",\n                blockHash: block,\n                includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof blockTag !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\",\n            blockTag,\n            includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransaction\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransactionReceipt\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({\n                method: \"getTransaction\",\n                hash\n            });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({\n                method: \"getTransactionResult\",\n                hash\n            })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getLogs\",\n                filter\n            })\n        });\n        return params.map((p)=>this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_11__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_12__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_14__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = _confirms != null ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject)=>{\n            let timer = null;\n            const listener = async (blockNumber)=>{\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            };\n            if (timeout != null) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"timeout\", \"TIMEOUT\", {\n                        reason: \"timeout\"\n                    }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */ _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */ _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = ()=>{\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, {\n                timer: null,\n                func,\n                time: timeout\n            });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, {\n                timer,\n                func,\n                time: getTime()\n            });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */ _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()){\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                {\n                    const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockSubscriber(this);\n                    subscriber.pollingInterval = this.pollingInterval;\n                    return subscriber;\n                }\n            case \"safe\":\n            case \"finalized\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */ _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()){\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({\n                orphan: \"drop-log\",\n                log: emitArgs[0]\n            }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = {\n                subscriber,\n                tag,\n                addressableMap,\n                nameMap,\n                started: false,\n                listeners: []\n            };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once })=>{\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.EventPayload(this, once ? null : listener, event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch (error) {}\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return count > 0;\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        } else {\n            for (const [tag, { started, subscriber }] of this.#subs){\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */ get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */ destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()){\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */ get paused() {\n        return this.#pausedState != null;\n    }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */ pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s)=>s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()){\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */ resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s)=>s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()){\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.toUtf8String)(bytes);\n        }\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset + 32, offset + 32 + length);\n    } catch (error) {}\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(empty);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\",\n        urls: [],\n        calldata: \"\",\n        selector: \"\",\n        extraData: \"\",\n        errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset + 32);\n        for(let u = 0; u < urlsLength; u++){\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k)=>result[k]);\n    return result;\n} //# sourceMappingURL=abstract-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ0QsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQiw0RUFBNEU7QUFDNUUsNEVBQTRFO0FBQzVFLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQ1Y7QUFDYjtBQUNKO0FBQ0o7QUFDVTtBQUNxTztBQUMzTztBQUMwRDtBQUNuRTtBQUNtRTtBQUNpRTtBQUMzSyxZQUFZO0FBQ1osTUFBTTJDLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMscUJBQXFCO0FBQzNCLFNBQVNDLFVBQVVDLEtBQUs7SUFDcEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVILEtBQUs7SUFDekIsT0FBT0csU0FBUyxNQUFNQyxLQUFLQyxTQUFTLENBQUNMLE9BQU8sQ0FBQ00sR0FBR0M7UUFDNUMsSUFBSUEsS0FBSyxNQUFNO1lBQ1gsT0FBTztRQUNYO1FBQ0EsSUFBSSxPQUFRQSxNQUFPLFVBQVU7WUFDekIsT0FBTyxDQUFDLE9BQU8sRUFBRUEsRUFBRUMsUUFBUSxHQUFHLENBQUM7UUFDbkM7UUFDQSxJQUFJLE9BQVFELE1BQU8sVUFBVTtZQUN6QixPQUFPQSxFQUFFRSxXQUFXO1FBQ3hCO1FBQ0EsbUJBQW1CO1FBQ25CLElBQUksT0FBUUYsTUFBTyxZQUFZLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0osSUFBSTtZQUM5QyxNQUFNSyxPQUFPQyxPQUFPRCxJQUFJLENBQUNMO1lBQ3pCSyxLQUFLRSxJQUFJO1lBQ1QsT0FBT0YsS0FBS0csTUFBTSxDQUFDLENBQUNDLE9BQU9DO2dCQUN2QkQsS0FBSyxDQUFDQyxJQUFJLEdBQUdWLENBQUMsQ0FBQ1UsSUFBSTtnQkFDbkIsT0FBT0Q7WUFDWCxHQUFHLENB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QSxtQ0FBbUM7SUFDbkMsSUFBSTtRQUNBLE1BQU12QixXQUFXMkssWUFBWXZLLE1BQU07UUFDbkMsSUFBSUosWUFBWSxNQUFNO1lBQ2xCLE1BQU0sSUFBSTVELE1BQU07UUFDcEI7UUFDQWdGLE9BQU9wQixRQUFRLEdBQUdBO0lBQ3RCLEVBQ0EsT0FBT2tCLE9BQU87UUFDVmhKLHVEQUFNQSxDQUFDLE9BQU8sbUNBQW1DLGtCQUFrQjtZQUMvRHFKLFFBQVE7UUFDWjtJQUNKO0lBQ0Esb0NBQW9DO0lBQ3BDckosdURBQU1BLENBQUNULDBEQUFTQSxDQUFDMkksTUFBTSxLQUFLLFNBQVMzSSwwREFBU0EsQ0FBQzZULE9BQU8sR0FBRyxLQUFLLDRDQUE0QyxrQkFBa0I7UUFDeEgvSixRQUFRO0lBQ1o7SUFDQUgsT0FBTzRELFFBQVEsR0FBR3ZOLDBEQUFTQSxDQUFDMkksTUFBTSxJQUFJO0lBQ3RDLDZEQUE2RDtJQUM3RCxJQUFJO1FBQ0EsTUFBTThFLFlBQVl5RixZQUFZdkssTUFBTTtRQUNwQyxJQUFJOEUsYUFBYSxNQUFNO1lBQ25CLE1BQU0sSUFBSTlJLE1BQU07UUFDcEI7UUFDQWdGLE9BQU84RCxTQUFTLEdBQUdBO0lBQ3ZCLEVBQ0EsT0FBT2hFLE9BQU87UUFDVmhKLHVEQUFNQSxDQUFDLE9BQU8sb0NBQW9DLGtCQUFrQjtZQUNoRXFKLFFBQVE7UUFDWjtJQUNKO0lBQ0FILE9BQU8wRCxTQUFTLEdBQUcsMENBQTBDNkcsS0FBSyxDQUFDLEtBQUs5TyxHQUFHLENBQUMsQ0FBQ3ZDLElBQU04RyxNQUFNLENBQUM5RyxFQUFFO0lBQzVGLE9BQU84RztBQUNYLEVBQ0EsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlci5qcz8xZWE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBhdmFpbGFibGUgcHJvdmlkZXJzIHNob3VsZCBzdWZmaWNlIGZvciBtb3N0IGRldmVsb3BlcnMgcHVycG9zZXMsXG4gKiAgYnV0IHRoZSBbW0Fic3RyYWN0UHJvdmlkZXJdXSBjbGFzcyBoYXMgbWFueSBmZWF0dXJlcyB3aGljaCBlbmFibGVcbiAqICBzdWItY2xhc3NpbmcgaXQgZm9yIHNwZWNpZmljIHB1cnBvc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6IFN1YmNsYXNzaW5nIFByb3ZpZGVyICBbYWJzdHJhY3QtcHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPXG4vLyBFdmVudCBjb2FsZXNjZW5jZVxuLy8gICBXaGVuIHdlIHJlZ2lzdGVyIGFuIGV2ZW50IHdpdGggYW4gYXN5bmMgdmFsdWUgKGUuZy4gYWRkcmVzcyBpcyBhIFNpZ25lclxuLy8gICBvciBFTlMgbmFtZSksIHdlIG5lZWQgdG8gYWRkIGl0IGltbWVpZGF0ZWx5IGZvciB0aGUgRXZlbnQgQVBJLCBidXQgYWxzb1xuLy8gICBuZWVkIHRpbWUgdG8gcmVzb2x2ZSB0aGUgYWRkcmVzcy4gVXBvbiByZXNvbHZpbmcgdGhlIGFkZHJlc3MsIHdlIG5lZWQgdG9cbi8vICAgbWlncmF0ZSB0aGUgbGlzdGVuZXIgdG8gdGhlIHN0YXRpYyBldmVudC4gV2UgYWxzbyBuZWVkIHRvIG1haW50YWluIGEgbWFwXG4vLyAgIG9mIFNpZ25lci9FTlMgbmFtZSB0byBhZGRyZXNzIHNvIHdlIGNhbiBzeW5jIHJlc3BvbmQgdG8gbGlzdGVuZXJDb3VudC5cbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGRhdGFTbGljZSwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaXNDYWxsRXhjZXB0aW9uLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgdG9CZUFycmF5LCB0b1F1YW50aXR5LCBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQsIHJlc29sdmVQcm9wZXJ0aWVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1Jlc29sdmVyIH0gZnJvbSBcIi4vZW5zLXJlc29sdmVyLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRCbG9jaywgZm9ybWF0TG9nLCBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQsIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgQmxvY2ssIEZlZURhdGEsIExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIsIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIsIFBvbGxpbmdFdmVudFN1YnNjcmliZXIsIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyLCBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhZyhwcmVmaXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrLCB2KSA9PiB7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGBiaWdpbnQ6JHt2LnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IG9iamVjdCBrZXlzXG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModik7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2W2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuLyoqXG4gKiAgQW4gKipVbm1hbmFnZWRTdWJzY3JpYmVyKiogaXMgdXNlZnVsIGZvciBldmVudHMgd2hpY2ggZG8gbm90IHJlcXVpcmVcbiAqICBhbnkgYWRkaXRpb25hbCBtYW5hZ2VtZW50LCBzdWNoIGFzIGBgXCJkZWJ1Z1wiYGAgd2hpY2ggb25seSByZXF1aXJlc1xuICogIGVtaXQgaW4gc3luY2hyb25vdXMgZXZlbnQgbG9vcCB0cmlnZ2VyZWQgY2FsbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgZm9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7IH1cbiAgICBzdGFydCgpIHsgfVxuICAgIHN0b3AoKSB7IH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgfVxuICAgIHJlc3VtZSgpIHsgfVxufVxuZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjb25jaXNpZnkoaXRlbXMpIHtcbiAgICBpdGVtcyA9IEFycmF5LmZyb20oKG5ldyBTZXQoaXRlbXMpKS52YWx1ZXMoKSk7XG4gICAgaXRlbXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbihfZXZlbnQsIHByb3ZpZGVyKSB7XG4gICAgaWYgKF9ldmVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnRcIik7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpYyBhcnJheSBpbmZvIGFuIEV2ZW50RmlsdGVyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2V2ZW50KSkge1xuICAgICAgICBfZXZlbnQgPSB7IHRvcGljczogX2V2ZW50IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKF9ldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChfZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IF9ldmVudCwgdGFnOiBfZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoX2V2ZW50LCAzMikpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IF9ldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRyYW5zYWN0aW9uXCIsIHRhZzogZ2V0VGFnKFwidHhcIiwgeyBoYXNoIH0pLCBoYXNoIH07XG4gICAgfVxuICAgIGlmIChfZXZlbnQub3JwaGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICAvLyBAVE9ETzogU2hvdWxkIGxvd2VyY2FzZSBhbmQgd2hhdG5vdCB0aGluZ3MgaGVyZSBpbnN0ZWFkIG9mIGNvcHkuLi5cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvcnBoYW5cIiwgdGFnOiBnZXRUYWcoXCJvcnBoYW5cIiwgZXZlbnQpLCBmaWx0ZXI6IGNvcHkoZXZlbnQpIH07XG4gICAgfVxuICAgIGlmICgoX2V2ZW50LmFkZHJlc3MgfHwgX2V2ZW50LnRvcGljcykpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIHRvcGljczogKChldmVudC50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRBZGRyZXNzID0gKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYWRkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhd2FpdCByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBldmVudC5hZGRyZXNzLmZvckVhY2goYWRkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRBZGRyZXNzKGV2ZW50LmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gY29uY2lzaWZ5KGFkZHJlc3Nlcy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpbHRlciwgdGFnOiBnZXRUYWcoXCJldmVudFwiLCBmaWx0ZXIpLCB0eXBlOiBcImV2ZW50XCIgfTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBQcm92aWRlckV2ZW50XCIsIFwiZXZlbnRcIiwgX2V2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vKipcbiAqICBBbiAqKkFic3RyYWN0UHJvdmlkZXIqKiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIG90aGVyIHN1Yi1jbGFzc2VzIHRvXG4gKiAgaW1wbGVtZW50IHRoZSBbW1Byb3ZpZGVyXV0gQVBJIGJ5IG5vcm1hbGl6aW5nIGlucHV0IGFyZ3VtZW50cyBhbmRcbiAqICBmb3JtYXR0aW5nIG91dHB1dCByZXN1bHRzIGFzIHdlbGwgYXMgdHJhY2tpbmcgZXZlbnRzIGZvciBjb25zaXN0ZW50XG4gKiAgYmVoYXZpb3VyIG9uIGFuIGV2ZW50dWFsbHktY29uc2lzdGVudCBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI3N1YnM7XG4gICAgI3BsdWdpbnM7XG4gICAgLy8gbnVsbD11bnBhdXNlZCwgdHJ1ZT1wYXVzZWQrZHJvcFdoaWxlUGF1c2VkLCBmYWxzZT1wYXVzZWRcbiAgICAjcGF1c2VkU3RhdGU7XG4gICAgI2Rlc3Ryb3llZDtcbiAgICAjbmV0d29ya1Byb21pc2U7XG4gICAgI2FueU5ldHdvcms7XG4gICAgI3BlcmZvcm1DYWNoZTtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgbnVtYmVyIGlmIHJ1bm5pbmcgYW4gZXZlbnQgb3IgLTEgaWYgbm8gXCJibG9ja1wiIGV2ZW50XG4gICAgI2xhc3RCbG9ja051bWJlcjtcbiAgICAjbmV4dFRpbWVyO1xuICAgICN0aW1lcnM7XG4gICAgI2Rpc2FibGVDY2lwUmVhZDtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQWJzdHJhY3RQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJSwgb3JcbiAgICAgKiAgdXNlIHRoZSB2YXJpb3VzIG5ldHdvcmsgZGV0ZWN0aW9uIGNhcGFiaWxpdGllcyB0byBkaXNjb3ZlciB0aGVcbiAgICAgKiAgW1tOZXR3b3JrXV0gaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChfbmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX25ldHdvcmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV4dFRpbWVyID0gMTtcbiAgICAgICAgdGhpcy4jdGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI29wdGlvbnMucG9sbGluZ0ludGVydmFsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0aGlzYGAsIHRvIGFsbG93IGFuICoqQWJzdHJhY3RQcm92aWRlcioqIHRvIGltcGxlbWVudFxuICAgICAqICB0aGUgW1tDb250cmFjdFJ1bm5lcl1dIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBnZXQgcHJvdmlkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHBsdWctaW5zLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyBwbHVnLWluLlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY29ubmVjdCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IGEgcGx1Z2luIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByZXZlbnQgYW55IENDSVAtcmVhZCBvcGVyYXRpb24sIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciByZXF1ZXN0ZWRcbiAgICAgKiAgaW4gYSBbW2NhbGxdXSB1c2luZyBgYGVuYWJsZUNjaXBSZWFkYGAuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVDY2lwUmVhZCgpIHsgcmV0dXJuIHRoaXMuI2Rpc2FibGVDY2lwUmVhZDsgfVxuICAgIHNldCBkaXNhYmxlQ2NpcFJlYWQodmFsdWUpIHsgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gISF2YWx1ZTsgfVxuICAgIC8vIFNoYXJlcyBtdWx0aXBsZSBpZGVudGljYWwgcmVxdWVzdHMgbWFkZSBkdXJpbmcgdGhlIHNhbWUgMjUwbXNcbiAgICBhc3luYyAjcGVyZm9ybShyZXEpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuI29wdGlvbnMuY2FjaGVUaW1lb3V0O1xuICAgICAgICAvLyBDYWNoaW5nIGRpc2FibGVkXG4gICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0YWdcbiAgICAgICAgY29uc3QgdGFnID0gZ2V0VGFnKHJlcS5tZXRob2QsIHJlcSk7XG4gICAgICAgIGxldCBwZXJmb3JtID0gdGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXBlcmZvcm0pIHtcbiAgICAgICAgICAgIHBlcmZvcm0gPSB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuc2V0KHRhZywgcGVyZm9ybSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpID09PSBwZXJmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5kZWxldGUodGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkYXRhIGZvciBleGVjdXRpbmcgdGhlIENDSVAtcmVhZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDY2lwUmVhZCB8fCB1cmxzLmxlbmd0aCA9PT0gMCB8fCB0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXG4gICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgIC8vY29uc3QganNvbjogc3RyaW5nIHwgbnVsbCA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGw6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgLy9jb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChocmVmKTtcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSB7IGRhdGEsIHNlbmRlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkRmV0Y2hSZXF1ZXN0XCIsIHJlcXVlc3QsIGluZGV4OiBpLCB1cmxzIH0pO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHJlc291cmNlLi4uXG4gICAgICAgICAgICBsZXQgcmVzcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4ubG93LWxldmVsIGZldGNoIGVycm9yIChtaXNzaW5nIGhvc3QsIGJhZCBTU0wsIGV0Yy4pLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRyeSBuZXh0IFVSTFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdDogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaFJlc3VsdFwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgIGFzc2VydChyZXNwLnN0YXR1c0NvZGUgPCA0MDAgfHwgcmVzcC5zdGF0dXNDb2RlID49IDUwMCwgYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7IHJlYXNvbjogXCI0MDRfTUlTU0lOR19SRVNPVVJDRVwiLCB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJsLCBlcnJvck1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2VzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oXCIsIFwiKX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCI1MDBfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJscywgZXJyb3JNZXNzYWdlcyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgYmxvY2sgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBfd3JhcEJsb2NrKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2soZm9ybWF0QmxvY2sodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGxvZyBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tMb2ddXS5cbiAgICAgKi9cbiAgICBfd3JhcExvZyh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IExvZyhmb3JtYXRMb2codmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlY2VpcHQgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlY2VpcHQoZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZShmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgTmV0d29yaywgZm9yY2luZyBhIG5ldHdvcmsgZGV0ZWN0aW9uIHVzaW5nIHdoYXRldmVyXG4gICAgICogIHRlY2huaXF1ZSB0aGUgc3ViLWNsYXNzIHJlcXVpcmVzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgc2hvdWxkIHVzZSB0aGlzIHRvIHBlcmZvcm0gYWxsIGJ1aWx0LWluIG9wZXJhdGlvbnMuIEFsbFxuICAgICAqICBtZXRob2RzIHNhbml0aXplcyBhbmQgbm9ybWFsaXplcyB0aGUgdmFsdWVzIHBhc3NlZCBpbnRvIHRoaXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgbWV0aG9kOiAke3JlcS5tZXRob2R9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgaW5mbzogcmVxXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTdGF0ZVxuICAgIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGdldE51bWJlcihhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEJsb2NrTnVtYmVyXCIgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLCByZXNvbHZpbmcgRU5TXG4gICAgICogIG5hbWVzIGFuZCBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0cyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYW5cbiAgICAgKiAgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyhhZGRyZXNzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB2YWxpZCBibG9jayB0YWcgZm9yICUlYmxvY2tUYWclJSwgcmVzb2x2aW5nXG4gICAgICogIG5lZ2F0aXZlIHZhbHVlcyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZCBibG9jayB0YWcuXG4gICAgICovXG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gZ2V0TnVtYmVyKGJsb2NrVGFnLCBcImJsb2NrVGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFnID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgKyBibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGIpID0+IHRvUXVhbnRpdHkoYiArIGJsb2NrVGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBibG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSBmaWx0ZXIgZm9yICUlZmlsdGVyJSUsIHJlc29sdmluZyBhbnkgRU5TXG4gICAgICogIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBvYmplY3QgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgZmlsdGVyLlxuICAgICAqL1xuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9waWNzXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IChmaWx0ZXIudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gKFwiYmxvY2tIYXNoXCIgaW4gZmlsdGVyKSA/IGZpbHRlci5ibG9ja0hhc2ggOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoX2FkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9hZGRyZXNzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2sgIT0gbnVsbCB8fCB0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZnJvbUJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IHRvQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZHJlc3NlcyBjb3VsZCBiZSBhc3luYyAoRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlcylcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBbXTtcbiAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgb2YgZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoYWRkcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb21CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiZnJvbUJsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwidG9CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgdG9CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcy5maWx0ZXIoKGEpID0+ICh0eXBlb2YgKGEpICE9PSBcInN0cmluZ1wiKSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAoZnJvbUJsb2NrICE9IG51bGwgJiYgdHlwZW9mIChmcm9tQmxvY2spICE9PSBcInN0cmluZ1wiKSB8fFxuICAgICAgICAgICAgKHRvQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKHRvQmxvY2spICE9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChhZGRyZXNzKSwgZnJvbUJsb2NrLCB0b0Jsb2NrXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHRyYW5zYWN0aW9uIGZvciAlJXJlcXVlc3QlJSwgcmVzb2x2aW5nXG4gICAgICogIGFueSBFTlMgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3JlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNvcHlSZXF1ZXN0KF9yZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgW1widG9cIiwgXCJmcm9tXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkciA9IHJlc29sdmVBZGRyZXNzKHJlcXVlc3Rba2V5XSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0W2tleV0gPSBhd2FpdCBhZGRyOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rba2V5XSA9IGFkZHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVxdWVzdC5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKHJlcXVlc3QuYmxvY2tUYWcpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3QuYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZzsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJsb2NrVGFnID0gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgbmV0d29yayB3YXMgc2V0IGFuZCB0aGlzIGlzIG91ciBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGN1cnJlbnQgbmV0d29yayAoc2hhcmVkIHdpdGggYWxsIGNhbGxzKVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IGRldGVjdE5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBkZXRlY3ROZXR3b3JrO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBkZXRlY3ROZXR3b3JrKS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlID0gdGhpcy4jbmV0d29ya1Byb21pc2U7XG4gICAgICAgIGNvbnN0IFtleHBlY3RlZCwgYWN0dWFsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG5ldHdvcmtQcm9taXNlLFxuICAgICAgICAgICAgdGhpcy5fZGV0ZWN0TmV0d29yaygpIC8vIFRoZSBhY3R1YWwgY29ubmVjdGVkIG5ldHdvcmtcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChleHBlY3RlZC5jaGFpbklkICE9PSBhY3R1YWwuY2hhaW5JZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJhbnlcIiBuZXR3b3JrIGNhbiBjaGFuZ2UsIHNvIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbmV0d29yayBpZiBzb21ldGhpbmcgZWxzZSBoYXNuJ3QgYWxyZWFkeSBjaGFuZ2VkIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBuZXR3b3JrUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGFsbG93IGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2Jsb2NrLCBnYXNQcmljZSwgcHJpb3JpdHlGZWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBfYmxvY2s6IHRoaXMuI2dldEJsb2NrKFwibGF0ZXN0XCIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUsIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pKCkpLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5RmVlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRQcmlvcml0eUZlZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSByZWNvbW1lbmRlZCBFSVAtMTU1OSBoZXVyaXN0aWNzIGZvciBmZWUgZGF0YVxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl93cmFwQmxvY2soX2Jsb2NrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAocHJpb3JpdHlGZWUgIT0gbnVsbCkgPyBwcmlvcml0eUZlZSA6IEJpZ0ludChcIjEwMDAwMDAwMDBcIik7XG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gKGJsb2NrLmJhc2VGZWVQZXJHYXMgKiBCTl8yKSArIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgRmVlRGF0YU5ldFdvcmtQbHVnaW5cbiAgICAgICAgY29uc3QgcGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QocGx1Z2luLnVybCk7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcGx1Z2luLnByb2Nlc3NGdW5jKGdldEZlZURhdGFGdW5jLCB0aGlzLCByZXEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhKGZlZURhdGEuZ2FzUHJpY2UsIGZlZURhdGEubWF4RmVlUGVyR2FzLCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RmVlRGF0YUZ1bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXMoX3R4KSB7XG4gICAgICAgIGxldCB0eCA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHR4KSkge1xuICAgICAgICAgICAgdHggPSBhd2FpdCB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsIHRyYW5zYWN0aW9uOiB0eFxuICAgICAgICB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jICNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCkge1xuICAgICAgICBhc3NlcnQoYXR0ZW1wdCA8IE1BWF9DQ0lQX1JFRElSRUNUUywgXCJDQ0lQIHJlYWQgZXhjZWVkZWQgbWF4aW11bSByZWRpcmVjdGlvbnNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiVE9PX01BTllfUkVESVJFQ1RTXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgsIHsgYmxvY2tUYWcsIGVuYWJsZUNjaXBSZWFkOiB0cnVlIH0pXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGNhbWUgaW4gYXMgYSBQZXJmb3JtQWN0aW9uVHJhbnNhY3Rpb24sIHNvIHRvL2Zyb20gYXJlIHNhZmU7IHdlIGNhbiBjYXN0XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY29weVJlcXVlc3QodHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy5fcGVyZm9ybSh7IG1ldGhvZDogXCJjYWxsXCIsIHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgT2ZmY2hhaW5Mb29rdXBcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ2NpcFJlYWQgJiYgaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhICYmIGF0dGVtcHQgPj0gMCAmJiBibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiAmJiB0cmFuc2FjdGlvbi50byAhPSBudWxsICYmIGRhdGFTbGljZShlcnJvci5kYXRhLCAwLCA0KSA9PT0gXCIweDU1NmYxODMwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFNlbmRlciA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHRyYW5zYWN0aW9uLnRvLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgQ0NJUCBSZWFkIEFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGxldCBjY2lwQXJncztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjY2lwQXJncyA9IHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YVNsaWNlKGVycm9yLmRhdGEsIDQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyb3IubWVzc2FnZSwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiQkFEX0RBVEFcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGFzc2VydChjY2lwQXJncy5zZW5kZXIudG9Mb3dlckNhc2UoKSA9PT0gdHhTZW5kZXIudG9Mb3dlckNhc2UoKSwgXCJDQ0lQIFJlYWQgc2VuZGVyIG1pc21hdGNoXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNjaXBBcmdzLmVycm9yQXJnc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IGF3YWl0IHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2NpcEFyZ3MuY2FsbGRhdGEsIGNjaXBBcmdzLnVybHMpO1xuICAgICAgICAgICAgICAgIGFzc2VydChjY2lwUmVzdWx0ICE9IG51bGwsIFwiQ0NJUCBSZWFkIGZhaWxlZCB0byBmZXRjaCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiRkVUQ0hfRkFJTEVEXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGE6IGVycm9yLmRhdGEsIGVycm9yQXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHR4U2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb25jYXQoW2NjaXBBcmdzLnNlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgY2NpcEFyZ3MuZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkQ2FsbFwiLCB0cmFuc2FjdGlvbjogdHggfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbFJlc3VsdFwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsRXJyb3JcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNjaGVja05ldHdvcmsocHJvbWlzZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwoX3R4KSB7XG4gICAgICAgIGNvbnN0IHsgdHgsIGJsb2NrVGFnIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICB0eDogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCksXG4gICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoX3R4LmJsb2NrVGFnKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgX3R4LmVuYWJsZUNjaXBSZWFkID8gMCA6IC0xKSk7XG4gICAgfVxuICAgIC8vIEFjY291bnRcbiAgICBhc3luYyAjZ2V0QWNjb3VudFZhbHVlKHJlcXVlc3QsIF9hZGRyZXNzLCBfYmxvY2tUYWcpIHtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKF9hZGRyZXNzKTtcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoX2Jsb2NrVGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIFthZGRyZXNzLCBibG9ja1RhZ10gPSBhd2FpdCBQcm9taXNlLmFsbChbYWRkcmVzcywgYmxvY2tUYWddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI3BlcmZvcm0oT2JqZWN0LmFzc2lnbihyZXF1ZXN0LCB7IGFkZHJlc3MsIGJsb2NrVGFnIH0pKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEJhbGFuY2UoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGdldE51bWJlcihhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldENvZGUoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldENvZGVcIiB9LCBhZGRyZXNzLCBibG9ja1RhZykpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdG9yYWdlKGFkZHJlc3MsIF9wb3NpdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRCaWdJbnQoX3Bvc2l0aW9uLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0U3RvcmFnZVwiLCBwb3NpdGlvbiB9LCBhZGRyZXNzLCBibG9ja1RhZykpO1xuICAgIH1cbiAgICAvLyBXcml0ZVxuICAgIGFzeW5jIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHNpZ25lZFR4KSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGhhc2gsIG5ldHdvcmsgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICBoYXNoOiB0aGlzLl9wZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBzaWduZWRUcmFuc2FjdGlvbjogc2lnbmVkVHhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gVHJhbnNhY3Rpb24uZnJvbShzaWduZWRUeCk7XG4gICAgICAgIGlmICh0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ETzogdGhlIHJldHVybmVkIGhhc2ggZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspLnJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oYmxvY2tOdW1iZXIpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0QmxvY2soYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgLy8gQFRPRE86IEFkZCBDdXN0b21CbG9ja1BsdWdpbiBjaGVja1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2ssIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja0hhc2g6IGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhibG9jayk7XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRCbG9jayhibG9jaywgcHJlZmV0Y2hUeHMpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNnZXRCbG9jayhibG9jaywgISFwcmVmZXRjaFR4cylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBCbG9jayhwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZShwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBiYWNrZW5kcyBkaWQgbm90IGJhY2tmaWxsIHRoZSBlZmZlY3RpdmVHYXNQcmljZSBpbnRvIG9sZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgLy8gaW4gdGhlIHJlY2VpcHQsIHNvIHdlIGxvb2sgaXQgdXAgbWFudWFsbHkgYW5kIGluamVjdCBpdC5cbiAgICAgICAgaWYgKHBhcmFtcy5nYXNQcmljZSA9PSBudWxsICYmIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KTtcbiAgICAgICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVwb3J0IHRoaXM7IGNvdWxkIG5vdCBmaW5kIHR4IG9yIGVmZmVjdGl2ZUdhc1ByaWNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZXN1bHQoaGFzaCkge1xuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBCbG9vbS1maWx0ZXIgUXVlcmllc1xuICAgIGFzeW5jIGdldExvZ3MoX2ZpbHRlcikge1xuICAgICAgICBsZXQgZmlsdGVyID0gdGhpcy5fZ2V0RmlsdGVyKF9maWx0ZXIpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKGZpbHRlcikpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IGF3YWl0IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0TG9nc1wiLCBmaWx0ZXIgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKChwKSA9PiB0aGlzLl93cmFwTG9nKHAsIG5ldHdvcmspKTtcbiAgICB9XG4gICAgLy8gRU5TXG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInByb3ZpZGVyIGNhbm5vdCBjb25uZWN0IHRvIHRhcmdldCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZ2V0UHJvdmlkZXIoKVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBFbnNSZXNvbHZlci5mcm9tTmFtZSh0aGlzLCBuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXZhdGFyKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2goYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuc0FkZHIgPSBhd2FpdCBFbnNSZXNvbHZlci5nZXRFbnNBZGRyZXNzKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZW5zQ29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgZW5zQ29udHJhY3QucmVzb2x2ZXIobm9kZSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCB8fCByZXNvbHZlciA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQ29udHJhY3QgPSBuZXcgQ29udHJhY3QocmVzb2x2ZXIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG5hbWUoYnl0ZXMzMikgdmlldyByZXR1cm5zIChzdHJpbmcpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IHJlc29sdmVyQ29udHJhY3QubmFtZShub2RlKTtcbiAgICAgICAgICAgIC8vIEZhaWxlZCBmb3J3YXJkIHJlc29sdXRpb25cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gYXdhaXQgdGhpcy5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyBkYXRhIHdhcyByZXR1cm5lZCBmcm9tIHRoZSByZXNvbHZlclxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQkFEX0RBVEFcIikgJiYgZXJyb3IudmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHJlZXJ0ZWRcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKGhhc2gsIF9jb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IChfY29uZmlybXMgIT0gbnVsbCkgPyBfY29uZmlybXMgOiAxO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGFzeW5jIChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDEgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVFRVwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHsgcmVhc29uOiBcInRpbWVvdXRcIiB9KSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcihhd2FpdCB0aGlzLmdldEJsb2NrTnVtYmVyKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckJsb2NrKGJsb2NrVGFnKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIsIFwiTk9UX0lNUExFTUVOVEVEXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ3YWl0Rm9yQmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGEgdGltZXIgY3JlYXRlZCB1c2luZyB0aGUgW1tfc2V0VGltZW91dF1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLiN0aW1lcnMuZ2V0KHRpbWVySWQpO1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSB0aW1lciB0aGF0IHdpbGwgZXhlY3V0ZSAlJWZ1bmMlJSBhZnRlciBhdCBsZWFzdCAlJXRpbWVvdXQlJVxuICAgICAqICAoaW4gbXMpLiBJZiAlJXRpbWVvdXQlJSBpcyB1bnNwZWNpZmllZCwgdGhlbiAlJWZ1bmMlJSB3aWxsIGV4ZWN1dGVcbiAgICAgKiAgaW4gdGhlIG5leHQgZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqICBbUGF1c2luZ10oQWJzdHJhY3RQcm92aWRlci1wYXVzZWQpIHRoZSBwcm92aWRlciB3aWxsIHBhdXNlIGFueVxuICAgICAqICBhc3NvY2lhdGVkIHRpbWVycy5cbiAgICAgKi9cbiAgICBfc2V0VGltZW91dChfZnVuYywgdGltZW91dCkge1xuICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lcklkID0gdGhpcy4jbmV4dFRpbWVyKys7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgICAgICAgICAgX2Z1bmMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXI6IG51bGwsIGZ1bmMsIHRpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoZnVuYywgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXIsIGZ1bmMsIHRpbWU6IGdldFRpbWUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBlcmZvcm0gJSVmdW5jJSUgb24gZWFjaCBzdWJzY3JpYmVyLlxuICAgICAqL1xuICAgIF9mb3JFYWNoU3Vic2NyaWJlcihmdW5jKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZ1bmMoc3ViLnN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBjdXN0b21pemUgc3Vic2NyaXB0aW9uXG4gICAgICogIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgc3dpdGNoIChzdWIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlcih0aGlzLCBzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIodGhpcywgc3ViLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ09ycGhhblN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBldmVudDogJHtzdWIudHlwZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgW1tTdWJzY3JpYmVyXV0gZmFpbHMgYW5kIG5lZWRzIHRvIHJlcGxhY2UgaXRzZWxmLCB0aGlzXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgdGhpcyBpcyB1c2VkIGZvciBwcm92aWRlcnMgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAgYGBldGhfZ2V0RmlsdGVyQ2hhbmdlc2BgIG1ldGhvZCwgd2hpY2ggY2FuIHJldHVybiBudWxsIGlmIHN0YXRlXG4gICAgICogIGZpbHRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJhY2tlbmQsIGFsbG93aW5nIHRoZSBTdWJzY3JpYmVyXG4gICAgICogIHRvIHN3YXAgaW4gYSBbW1BvbGxpbmdFdmVudFN1YnNjcmliZXJdXS5cbiAgICAgKi9cbiAgICBfcmVjb3ZlclN1YnNjcmliZXIob2xkU3ViLCBuZXdTdWIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVyID09PSBvbGRTdWIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlciA9IG5ld1N1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNoYXNTdWIoZXZlbnQsIGVtaXRBcmdzKSB7XG4gICAgICAgIGxldCBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbG9nIHRoYXQgaXMgcmVtb3ZpbmcgYW4gZXhpc3RpbmcgbG9nOyB3ZSBhY3R1YWxseSB3YW50XG4gICAgICAgIC8vIHRvIGVtaXQgYW4gb3JwaGFuIGV2ZW50IGZvciB0aGUgcmVtb3ZlZCBsb2dcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIgJiYgZW1pdEFyZ3MgJiYgZW1pdEFyZ3MubGVuZ3RoID4gMCAmJiBlbWl0QXJnc1swXS5yZW1vdmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oeyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiBlbWl0QXJnc1swXSB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jc3Vicy5nZXQoc3ViLnRhZykgfHwgbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgI2dldFN1YihldmVudCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBQcmV2ZW50IHRhbXBlcmluZyB3aXRoIG91ciB0YWcgaW4gYW55IHN1YmNsYXNzJyBfZ2V0U3Vic2NyaWJlclxuICAgICAgICBjb25zdCB0YWcgPSBzdWJzY3JpcHRpb24udGFnO1xuICAgICAgICBsZXQgc3ViID0gdGhpcy4jc3Vicy5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLl9nZXRTdWJzY3JpYmVyKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzYWJsZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgc3ViID0geyBzdWJzY3JpYmVyLCB0YWcsIGFkZHJlc3NhYmxlTWFwLCBuYW1lTWFwLCBzdGFydGVkOiBmYWxzZSwgbGlzdGVuZXJzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy4jc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQsIGFyZ3MpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3Qgc3Vic2NyaXB0aW9uIG9yIGlmIGEgcmVjZW50IGVtaXQgcmVtb3ZlZFxuICAgICAgICAvLyB0aGUgbGFzdCBvZiB0aGVtICh3aGljaCBhbHNvIGRlbGV0ZWQgdGhlIHN1YikgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXN1YiB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgRXZlbnRQYXlsb2FkKHRoaXMsIChvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSwgZXZlbnQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIC4uLmFyZ3MsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAhb25jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjb3VudCA+IDApO1xuICAgIH1cbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpc3RlbmVyIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyB0YWcsIHN0YXJ0ZWQsIHN1YnNjcmliZXIgfSA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3RhZywgeyBzdGFydGVkLCBzdWJzY3JpYmVyIH1dIG9mIHRoaXMuI3N1YnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib25cIlxuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRoaXMgcHJvdmlkZXIgaGFzIGJlZW4gZGVzdHJveWVkIHVzaW5nIHRoZSBbW2Rlc3Ryb3ldXSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAgT25jZSBkZXN0cm95ZWQsIGFsbCByZXNvdXJjZXMgYXJlIHJlY2xhaW1lZCwgaW50ZXJuYWwgZXZlbnQgbG9vcHNcbiAgICAgKiAgYW5kIHRpbWVycyBhcmUgY2xlYW5lZCB1cCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBtYXkgYmUgc2VudCB0b1xuICAgICAqICB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rlc3Ryb3llZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSB1c2UgdGhpcyB0byBzaHV0ZG93biBhbnkgc29ja2V0cyBvciByZWxlYXNlIHRoZWlyXG4gICAgICogIHJlc291cmNlcyBhbmQgcmVqZWN0IGFueSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIGNhbGwgYGBzdXBlci5kZXN0cm95KClgYC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBTdG9wIGFsbCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgLy8gU2h1dCBkb3duIGFsbCB0aWVtcnNcbiAgICAgICAgZm9yIChjb25zdCB0aW1lcklkIG9mIHRoaXMuI3RpbWVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgcHJvdmlkZXIgaXMgY3VycmVudGx5IHBhdXNlZC5cbiAgICAgKlxuICAgICAqICBBIHBhdXNlZCBwcm92aWRlciB3aWxsIG5vdCBlbWl0IGFueSBldmVudHMsIGFuZCBnZW5lcmFsbHkgc2hvdWxkXG4gICAgICogIG5vdCBtYWtlIGFueSByZXF1ZXN0cyB0byB0aGUgbmV0d29yaywgYnV0IHRoYXQgaXMgdXAgdG8gc3ViLWNsYXNzZXNcbiAgICAgKiAgdG8gbWFuYWdlLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgYGBwYXVzZWQgPSB0cnVlYGAgaXMgaWRlbnRpY2FsIHRvIGNhbGxpbmcgYGAucGF1c2UoZmFsc2UpYGAsXG4gICAgICogIHdoaWNoIHdpbGwgYnVmZmVyIGFueSBldmVudHMgdGhhdCBvY2N1ciB3aGlsZSBwYXVzZWQgdW50aWwgdGhlXG4gICAgICogIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7IHJldHVybiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCk7IH1cbiAgICBzZXQgcGF1c2VkKHBhdXNlKSB7XG4gICAgICAgIGlmICghIXBhdXNlID09PSB0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXVzZSB0aGUgcHJvdmlkZXIuIElmICUlZHJvcFdoaWxlUGF1c2VkJSUsIGFueSBldmVudHMgdGhhdCBvY2N1clxuICAgICAqICB3aGlsZSBwYXVzZWQgYXJlIGRyb3BwZWQsIG90aGVyd2lzZSBhbGwgZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBvbmNlXG4gICAgICogIHRoZSBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gISFkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IGNoYW5nZSBwYXVzZSB0eXBlOyByZXN1bWUgZmlyc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwYXVzZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5wYXVzZShkcm9wV2hpbGVQYXVzZWQpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSAhIWRyb3BXaGlsZVBhdXNlZDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lclxuICAgICAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIG5lZWRlZCBmb3Igd2hlbiB3ZSBiZWNvbWUgdW5wYXVzZWRcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCkgLSB0aW1lci50aW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXN1bWUgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5yZXN1bWUoKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIHdoZW4gd2Ugd2VyZSBwYXVzZWRcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gdGltZXIudGltZTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgdGltZSAoaW4gY2F1c2UgcGF1c2VkLCBzbyB3ZSBjb24gY29tcHV0ZSByZW1haW5pbmYgdGltZSlcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdGltZXJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZXIuZnVuYywgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBfcGFyc2VTdHJpbmcocmVzdWx0LCBzdGFydCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCk7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBzdGFydCwgc3RhcnQgKyAzMikpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xuICAgICAgICByZXR1cm4gZGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICBwYWRkZWQuc2V0KHJlc3VsdCwgMzIgLSByZXN1bHQubGVuZ3RoKTtcbiAgICByZXR1cm4gcGFkZGVkO1xufVxuZnVuY3Rpb24gYnl0ZXNQYWQodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAzMikgKiAzMik7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoW10pO1xuLy8gQUJJIEVuY29kZXMgYSBzZXJpZXMgb2YgKGJ5dGVzLCBieXRlcywgLi4uKVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChlbXB0eSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoZGF0YXNbaV0pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGJ5dGVzIG9mZnNldFxuICAgICAgICByZXN1bHRbaV0gPSBudW1QYWQoYnl0ZUNvdW50KTtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBhbmQgcGFkZGVkIHZhbHVlIG9mIGRhdGFcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtUGFkKGRhdGEubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGVzUGFkKGRhdGEpKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyICsgTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gMzIpICogMzI7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQocmVzdWx0KTtcbn1cbmNvbnN0IHplcm9zID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbmZ1bmN0aW9uIHBhcnNlT2ZmY2hhaW5Mb29rdXAoZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VuZGVyOiBcIlwiLCB1cmxzOiBbXSwgY2FsbGRhdGE6IFwiXCIsIHNlbGVjdG9yOiBcIlwiLCBleHRyYURhdGE6IFwiXCIsIGVycm9yQXJnczogW11cbiAgICB9O1xuICAgIGFzc2VydChkYXRhTGVuZ3RoKGRhdGEpID49IDUgKiAzMiwgXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCJcbiAgICB9KTtcbiAgICBjb25zdCBzZW5kZXIgPSBkYXRhU2xpY2UoZGF0YSwgMCwgMzIpO1xuICAgIGFzc2VydChkYXRhU2xpY2Uoc2VuZGVyLCAwLCAxMikgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMTIpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZW5kZXIgPSBkYXRhU2xpY2Uoc2VuZGVyLCAxMik7XG4gICAgLy8gUmVhZCB0aGUgVVJMcyBmcm9tIHRoZSByZXNwb25zZVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybHMgPSBbXTtcbiAgICAgICAgY29uc3QgdXJsc09mZnNldCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpO1xuICAgICAgICBjb25zdCB1cmxzRGF0YSA9IGRhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0ICsgMzIpO1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVybHNMZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gX3BhcnNlU3RyaW5nKHVybHNEYXRhLCB1ICogMzIpO1xuICAgICAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmxzLnB1c2godXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudXJscyA9IHVybHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIENDSVAgY2FsbGRhdGEgdG8gZm9yd2FyZFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xuICAgICAgICBpZiAoY2FsbGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmNhbGxkYXRhID0gY2FsbGRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgIGFzc2VydChkYXRhU2xpY2UoZGF0YSwgMTAwLCAxMjgpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDI4KSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbGVjdG9yID0gZGF0YVNsaWNlKGRhdGEsIDk2LCAxMDApO1xuICAgIC8vIEdldCB0aGUgZXh0cmEgZGF0YSB0byBzZW5kIGJhY2sgdG8gdGhlIGNvbnRyYWN0IGFzIGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBleHRyYURhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCAxMjgpO1xuICAgICAgICBpZiAoZXh0cmFEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5leHRyYURhdGEgPSBleHRyYURhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBleHRyYURhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBleHRyYURhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzdWx0LmVycm9yQXJncyA9IFwic2VuZGVyLHVybHMsY2FsbGRhdGEsc2VsZWN0b3IsZXh0cmFEYXRhXCIuc3BsaXQoLywvKS5tYXAoKGspID0+IHJlc3VsdFtrXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwicmVzb2x2ZUFkZHJlc3MiLCJaZXJvQWRkcmVzcyIsIkNvbnRyYWN0IiwibmFtZWhhc2giLCJUcmFuc2FjdGlvbiIsImNvbmNhdCIsImRhdGFMZW5ndGgiLCJkYXRhU2xpY2UiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJnZXRCaWdJbnQiLCJnZXRCeXRlcyIsImdldE51bWJlciIsImlzQ2FsbEV4Y2VwdGlvbiIsImlzRXJyb3IiLCJtYWtlRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkZldGNoUmVxdWVzdCIsInRvQmVBcnJheSIsInRvUXVhbnRpdHkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiRXZlbnRQYXlsb2FkIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJ0b1V0ZjhTdHJpbmciLCJFbnNSZXNvbHZlciIsImZvcm1hdEJsb2NrIiwiZm9ybWF0TG9nIiwiZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwiZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSIsIk5ldHdvcmsiLCJjb3B5UmVxdWVzdCIsIkJsb2NrIiwiRmVlRGF0YSIsIkxvZyIsIlRyYW5zYWN0aW9uUmVjZWlwdCIsIlRyYW5zYWN0aW9uUmVzcG9uc2UiLCJQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIiwiUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciIsIlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIiLCJCTl8yIiwiQmlnSW50IiwiTUFYX0NDSVBfUkVESVJFQ1RTIiwiaXNQcm9taXNlIiwidmFsdWUiLCJ0aGVuIiwiZ2V0VGFnIiwicHJlZml4IiwiSlNPTiIsInN0cmluZ2lmeSIsImsiLCJ2IiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwicmVkdWNlIiwiYWNjdW0iLCJrZXkiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwic3RhcnQiLCJzdG9wIiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJjb3B5IiwicGFyc2UiLCJjb25jaXNpZnkiLCJpdGVtcyIsImZyb20iLCJTZXQiLCJ2YWx1ZXMiLCJnZXRTdWJzY3JpcHRpb24iLCJfZXZlbnQiLCJwcm92aWRlciIsIkVycm9yIiwidG9waWNzIiwidHlwZSIsInRhZyIsImhhc2giLCJvcnBoYW4iLCJldmVudCIsImZpbHRlciIsImFkZHJlc3MiLCJtYXAiLCJ0IiwiYWRkcmVzc2VzIiwicHJvbWlzZXMiLCJhZGRBZGRyZXNzIiwiYWRkciIsInB1c2giLCJmb3JFYWNoIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsImEiLCJnZXRUaW1lIiwiRGF0ZSIsImRlZmF1bHRPcHRpb25zIiwiY2FjaGVUaW1lb3V0IiwicG9sbGluZ0ludGVydmFsIiwiQWJzdHJhY3RQcm92aWRlciIsInN1YnMiLCJwbHVnaW5zIiwicGF1c2VkU3RhdGUiLCJkZXN0cm95ZWQiLCJuZXR3b3JrUHJvbWlzZSIsImFueU5ldHdvcmsiLCJwZXJmb3JtQ2FjaGUiLCJsYXN0QmxvY2tOdW1iZXIiLCJuZXh0VGltZXIiLCJ0aW1lcnMiLCJkaXNhYmxlQ2NpcFJlYWQiLCJvcHRpb25zIiwiX25ldHdvcmsiLCJhc3NpZ24iLCJuZXR3b3JrIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlbWl0IiwiTWFwIiwiYXR0YWNoUGx1Z2luIiwicGx1Z2luIiwiZ2V0Iiwic2V0IiwiY29ubmVjdCIsImdldFBsdWdpbiIsInBlcmZvcm0iLCJyZXEiLCJ0aW1lb3V0IiwiX3BlcmZvcm0iLCJtZXRob2QiLCJkZWxldGUiLCJjY2lwUmVhZEZldGNoIiwidHgiLCJjYWxsZGF0YSIsInVybHMiLCJ0byIsInNlbmRlciIsImRhdGEiLCJlcnJvck1lc3NhZ2VzIiwiaSIsInVybCIsImhyZWYiLCJyZXBsYWNlIiwicmVxdWVzdCIsImluZGV4T2YiLCJib2R5IiwiYWN0aW9uIiwiaW5kZXgiLCJlcnJvck1lc3NhZ2UiLCJyZXNwIiwic2VuZCIsImVycm9yIiwibWVzc2FnZSIsInJlc3VsdCIsImJvZHlKc29uIiwic3RhdHVzQ29kZSIsInJlYXNvbiIsInRyYW5zYWN0aW9uIiwiaW5mbyIsIm0iLCJqb2luIiwiX3dyYXBCbG9jayIsIl93cmFwTG9nIiwiX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQiLCJfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZGV0ZWN0TmV0d29yayIsIm9wZXJhdGlvbiIsImdldEJsb2NrTnVtYmVyIiwiYmxvY2tOdW1iZXIiLCJfZ2V0QWRkcmVzcyIsIl9nZXRCbG9ja1RhZyIsImJsb2NrVGFnIiwiYiIsIl9nZXRGaWx0ZXIiLCJibG9ja0hhc2giLCJ1bmRlZmluZWQiLCJfYWRkcmVzcyIsImZyb21CbG9jayIsInRvQmxvY2siLCJfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0IiwiX3JlcXVlc3QiLCJnZXROZXR3b3JrIiwiZGV0ZWN0TmV0d29yayIsImNsb25lIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGFpbklkIiwiZ2V0RmVlRGF0YSIsImdldEZlZURhdGFGdW5jIiwiX2Jsb2NrIiwiZ2FzUHJpY2UiLCJwcmlvcml0eUZlZSIsImdldEJsb2NrIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJibG9jayIsImJhc2VGZWVQZXJHYXMiLCJmZWVEYXRhIiwicHJvY2Vzc0Z1bmMiLCJlc3RpbWF0ZUdhcyIsIl90eCIsImNhbGwiLCJhdHRlbXB0IiwiZW5hYmxlQ2NpcFJlYWQiLCJ0eFNlbmRlciIsImNjaXBBcmdzIiwicGFyc2VPZmZjaGFpbkxvb2t1cCIsImludm9jYXRpb24iLCJyZXZlcnQiLCJzaWduYXR1cmUiLCJhcmdzIiwiZXJyb3JBcmdzIiwiY2NpcFJlc3VsdCIsInNlbGVjdG9yIiwiZW5jb2RlQnl0ZXMiLCJleHRyYURhdGEiLCJjaGVja05ldHdvcmsiLCJwcm9taXNlIiwiZ2V0QWNjb3VudFZhbHVlIiwiX2Jsb2NrVGFnIiwiZ2V0QmFsYW5jZSIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRDb2RlIiwiZ2V0U3RvcmFnZSIsIl9wb3NpdGlvbiIsInBvc2l0aW9uIiwiYnJvYWRjYXN0VHJhbnNhY3Rpb24iLCJzaWduZWRUeCIsInNpZ25lZFRyYW5zYWN0aW9uIiwicmVwbGFjZWFibGVUcmFuc2FjdGlvbiIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJwcmVmZXRjaFR4cyIsInBhcmFtcyIsImdldFRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiZWZmZWN0aXZlR2FzUHJpY2UiLCJnZXRUcmFuc2FjdGlvblJlc3VsdCIsImdldExvZ3MiLCJfZmlsdGVyIiwicCIsIl9nZXRQcm92aWRlciIsImdldFJlc29sdmVyIiwiZnJvbU5hbWUiLCJnZXRBdmF0YXIiLCJyZXNvbHZlciIsInJlc29sdmVOYW1lIiwibG9va3VwQWRkcmVzcyIsIm5vZGUiLCJzdWJzdHJpbmciLCJlbnNBZGRyIiwiZ2V0RW5zQWRkcmVzcyIsImVuc0NvbnRyYWN0IiwicmVzb2x2ZXJDb250cmFjdCIsImNoZWNrIiwid2FpdEZvclRyYW5zYWN0aW9uIiwiX2NvbmZpcm1zIiwiY29uZmlybXMiLCJyZWplY3QiLCJ0aW1lciIsImxpc3RlbmVyIiwicmVjZWlwdCIsImNsZWFyVGltZW91dCIsImNvbnNvbGUiLCJsb2ciLCJvbmNlIiwib2ZmIiwid2FpdEZvckJsb2NrIiwiX2NsZWFyVGltZW91dCIsInRpbWVySWQiLCJfc2V0VGltZW91dCIsIl9mdW5jIiwiZnVuYyIsInBhdXNlZCIsInRpbWUiLCJfZm9yRWFjaFN1YnNjcmliZXIiLCJzdWIiLCJzdWJzY3JpYmVyIiwiX2dldFN1YnNjcmliZXIiLCJfcmVjb3ZlclN1YnNjcmliZXIiLCJvbGRTdWIiLCJuZXdTdWIiLCJzdGFydGVkIiwiaGFzU3ViIiwiZW1pdEFyZ3MiLCJyZW1vdmVkIiwiZ2V0U3ViIiwic3Vic2NyaXB0aW9uIiwiYWRkcmVzc2FibGVNYXAiLCJXZWFrTWFwIiwibmFtZU1hcCIsImxpc3RlbmVycyIsIm9uIiwiY291bnQiLCJwYXlsb2FkIiwibGlzdGVuZXJDb3VudCIsInRvdGFsIiwic3BsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsImRlc3Ryb3kiLCJzIiwiX3BhcnNlU3RyaW5nIiwiYnl0ZXMiLCJfcGFyc2VCeXRlcyIsIm9mZnNldCIsIm51bVBhZCIsInBhZGRlZCIsIlVpbnQ4QXJyYXkiLCJieXRlc1BhZCIsIk1hdGgiLCJjZWlsIiwiZW1wdHkiLCJkYXRhcyIsImJ5dGVDb3VudCIsInplcm9zIiwidXJsc09mZnNldCIsInVybHNMZW5ndGgiLCJ1cmxzRGF0YSIsInUiLCJzcGxpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: () => (/* binding */ AbstractSigner),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */ \n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then(([address, from])=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */ class AbstractSigner {\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */ constructor(provider){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            provider: provider || null\n        });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await this.provider.getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        } else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    if (pop.authorizationList && pop.authorizationList.length) {\n                        pop.type = 4;\n                    } else {\n                        pop.type = 2;\n                    }\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    } else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                } else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n                // Explicitly using EIP-1559 or EIP-4844\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n    }\n    async populateAuthorization(_auth) {\n        const auth = Object.assign({}, _auth);\n        // Add a chain ID if not explicitly set to 0\n        if (auth.chainId == null) {\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n        }\n        // @TODO: Take chain ID into account when populating noce?\n        if (auth.nonce == null) {\n            auth.nonce = await this.getNonce();\n        }\n        return auth;\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n    // @TODO: in v7 move this to be abstract\n    authorize(authorization) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"authorize\"\n        });\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */ class VoidSigner extends AbstractSigner {\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */ constructor(address, provider){\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            address\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n} //# sourceMappingURL=abstract-signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNvRDtBQUNDO0FBQ3FEO0FBQy9EO0FBQzVDLFNBQVNRLGNBQWNDLE1BQU0sRUFBRUMsU0FBUztJQUNwQyxJQUFJRCxPQUFPRSxRQUFRLEVBQUU7UUFDakIsT0FBT0YsT0FBT0UsUUFBUTtJQUMxQjtJQUNBTix1REFBTUEsQ0FBQyxPQUFPLG9CQUFvQix5QkFBeUI7UUFBRUs7SUFBVTtBQUMzRTtBQUNBLGVBQWVFLFNBQVNILE1BQU0sRUFBRUksRUFBRTtJQUM5QixJQUFJQyxNQUFNUCx5REFBV0EsQ0FBQ007SUFDdEIsSUFBSUMsSUFBSUMsRUFBRSxJQUFJLE1BQU07UUFDaEJELElBQUlDLEVBQUUsR0FBR2YsaUVBQWNBLENBQUNjLElBQUlDLEVBQUUsRUFBRU47SUFDcEM7SUFDQSxJQUFJSyxJQUFJRSxJQUFJLElBQUksTUFBTTtRQUNsQixNQUFNQSxPQUFPRixJQUFJRSxJQUFJO1FBQ3JCRixJQUFJRSxJQUFJLEdBQUdDLFFBQVFDLEdBQUcsQ0FBQztZQUNuQlQsT0FBT1UsVUFBVTtZQUNqQm5CLGlFQUFjQSxDQUFDZ0IsTUFBTVA7U0FDeEIsRUFBRVcsSUFBSSxDQUFDLENBQUMsQ0FBQ0MsU0FBU0wsS0FBSztZQUNwQlYsK0RBQWNBLENBQUNlLFFBQVFDLFdBQVcsT0FBT04sS0FBS00sV0FBVyxJQUFJLDZCQUE2QixXQUFXTjtZQUNyRyxPQUFPSztRQUNYO0lBQ0osT0FDSztRQUNEUCxJQUFJRSxJQUFJLEdBQUdQLE9BQU9VLFVBQVU7SUFDaEM7SUFDQSxPQUFPLE1BQU1mLGtFQUFpQkEsQ0FBQ1U7QUFDbkM7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1TO0lBS1Q7O0tBRUMsR0FDREMsWUFBWWIsUUFBUSxDQUFFO1FBQ2xCVCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lB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QUssRUFBRUMsS0FBSyxFQUFFO1FBQ3RDLElBQUksQ0FBQyxDQUFDUCxnQkFBZ0IsQ0FBQyxjQUFjO0lBQ3pDO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcz85NDRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEdlbmVyYWxseSB0aGUgW1tXYWxsZXRdXSBhbmQgW1tKc29uUnBjU2lnbmVyXV0gYW5kIHRoZWlyIHN1Yi1jbGFzc2VzXG4gKiAgYXJlIHN1ZmZpY2VudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9IHJlc29sdmVBZGRyZXNzKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICByZXNvbHZlQWRkcmVzcyhmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gZ2V0QmlnSW50KHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBhc3NlcnQoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5hdXRob3JpemF0aW9uTGlzdCAmJiBwb3AuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IE1heWJlIHRoaXMgc2hvbGQgYWxsb3cgdHlwZSAxP1xuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMgfHwgcG9wLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5IG9yIEVJUC00ODQ0XG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9AVE9PRDogRG9uJ3QgYXdhaXQgYWxsIG92ZXIgdGhlIHBsYWNlOyBzYXZlIHRoZW0gdXAgZm9yXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVBdXRob3JpemF0aW9uKF9hdXRoKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBfYXV0aCk7XG4gICAgICAgIC8vIEFkZCBhIGNoYWluIElEIGlmIG5vdCBleHBsaWNpdGx5IHNldCB0byAwXG4gICAgICAgIGlmIChhdXRoLmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXV0aC5jaGFpbklkID0gKGF3YWl0IGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXROZXR3b3JrXCIpLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVGFrZSBjaGFpbiBJRCBpbnRvIGFjY291bnQgd2hlbiBwb3B1bGF0aW5nIG5vY2U/XG4gICAgICAgIGlmIChhdXRoLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGgubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZXN0aW1hdGVHYXNcIikuZXN0aW1hdGVHYXMoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbCh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImNhbGxcIikuY2FsbChhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGRlbGV0ZSBwb3AuZnJvbTtcbiAgICAgICAgY29uc3QgdHhPYmogPSBUcmFuc2FjdGlvbi5mcm9tKHBvcCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogaW4gdjcgbW92ZSB0aGlzIHRvIGJlIGFic3RyYWN0XG4gICAgYXV0aG9yaXplKGF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImF1dGhvcml6YXRpb24gbm90IGltcGxlbWVudGVkIGZvciB0aGlzIHNpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJhdXRob3JpemVcIiB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVpc2duZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVBZGRyZXNzIiwiVHJhbnNhY3Rpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImNvcHlSZXF1ZXN0IiwiY2hlY2tQcm92aWRlciIsInNpZ25lciIsIm9wZXJhdGlvbiIsInByb3ZpZGVyIiwicG9wdWxhdGUiLCJ0eCIsInBvcCIsInRvIiwiZnJvbSIsIlByb21pc2UiLCJhbGwiLCJnZXRBZGRyZXNzIiwidGhlbiIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsIkFic3RyYWN0U2lnbmVyIiwiY29uc3RydWN0b3IiLCJnZXROb25jZSIsImJsb2NrVGFnIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsInBvcHVsYXRlQ2FsbCIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJub25jZSIsImdhc0xpbWl0IiwiZXN0aW1hdGVHYXMiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJoYXNFaXAxNTU5IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJnYXNQcmljZSIsInR5cGUiLCJmZWVEYXRhIiwiZ2V0RmVlRGF0YSIsImF1dGhvcml6YXRpb25MaXN0IiwibGVuZ3RoIiwicG9wdWxhdGVBdXRob3JpemF0aW9uIiwiX2F1dGgiLCJhdXRoIiwiT2JqZWN0IiwiYXNzaWduIiwiY2FsbCIsInJlc29sdmVOYW1lIiwibmFtZSIsInNlbmRUcmFuc2FjdGlvbiIsInR4T2JqIiwiYnJvYWRjYXN0VHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJhdXRob3JpemUiLCJhdXRob3JpemF0aW9uIiwiVm9pZFNpZ25lciIsImNvbm5lY3QiLCJ0aHJvd1Vuc3VwcG9ydGVkIiwic3VmZml4Iiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnblR5cGVkRGF0YSIsImRvbWFpbiIsInR5cGVzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: () => (/* binding */ BasicMulticoinProviderPlugin),\n/* harmony export */   EnsResolver: () => (/* binding */ EnsResolver),\n/* harmony export */   MulticoinProviderPlugin: () => (/* binding */ MulticoinProviderPlugin)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */ \n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */ class MulticoinProviderPlugin {\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            name\n        });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */ supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resolves to the encoded %%address%% for %%coinType%%.\n     */ async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resolves to the decoded %%data%% for %%coinType%%.\n     */ async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */ class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */ constructor(){\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */ class EnsResolver {\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            provider,\n            address,\n            name\n        });\n        this.#supports2544 = null;\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\"\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */ async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async ()=>{\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: {\n                    funcName\n                }\n            });\n            params = [\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.dnsEncode)(this.name, 255),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        } catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */ async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            } catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [\n                ethCoinType\n            ]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins){\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [\n            coinType\n        ]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: {\n                coinType,\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */ async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [\n            key\n        ]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */ async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: {\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */ async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */ async _getAvatar() {\n        const linkage = [\n            {\n                type: \"name\",\n                value: this.name\n            }\n        ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({\n                    type: \"!avatar\",\n                    value: \"\"\n                });\n                return {\n                    url: null,\n                    linkage\n                };\n            }\n            linkage.push({\n                type: \"avatar\",\n                value: avatar\n            });\n            for(let i = 0; i < matchers.length; i++){\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch(scheme){\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({\n                            type: \"url\",\n                            value: avatar\n                        });\n                        return {\n                            linkage,\n                            url: avatar\n                        };\n                    case \"ipfs\":\n                        {\n                            const url = getIpfsLink(avatar);\n                            linkage.push({\n                                type: \"ipfs\",\n                                value: avatar\n                            });\n                            linkage.push({\n                                type: \"url\",\n                                value: url\n                            });\n                            return {\n                                linkage,\n                                url\n                            };\n                        }\n                    case \"erc721\":\n                    case \"erc1155\":\n                        {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                            linkage.push({\n                                type: scheme,\n                                value: avatar\n                            });\n                            // The owner of this name\n                            const owner = await this.getAddress();\n                            if (owner == null) {\n                                linkage.push({\n                                    type: \"!owner\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                linkage.push({\n                                    type: `!${scheme}caip`,\n                                    value: match[2] || \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const tokenId = comps[1];\n                            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(comps[0], [\n                                // ERC-721\n                                \"function tokenURI(uint) view returns (string)\",\n                                \"function ownerOf(uint) view returns (address)\",\n                                // ERC-1155\n                                \"function uri(uint) view returns (string)\",\n                                \"function balanceOf(address, uint256) view returns (uint)\"\n                            ], this.provider);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                const tokenOwner = await contract.ownerOf(tokenId);\n                                if (owner !== tokenOwner) {\n                                    linkage.push({\n                                        type: \"!owner\",\n                                        value: tokenOwner\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"owner\",\n                                    value: tokenOwner\n                                });\n                            } else if (scheme === \"erc1155\") {\n                                const balance = await contract.balanceOf(owner, tokenId);\n                                if (!balance) {\n                                    linkage.push({\n                                        type: \"!balance\",\n                                        value: \"0\"\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"balance\",\n                                    value: balance.toString()\n                                });\n                            }\n                            // Call the token contract for the metadata URL\n                            let metadataUrl = await contract[selector](tokenId);\n                            if (metadataUrl == null || metadataUrl === \"0x\") {\n                                linkage.push({\n                                    type: \"!metadata-url\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata-url-base\",\n                                value: metadataUrl\n                            });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeHex)(tokenId, 32).substring(2));\n                                linkage.push({\n                                    type: \"metadata-url-expanded\",\n                                    value: metadataUrl\n                                });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({\n                                type: \"metadata-url\",\n                                value: metadataUrl\n                            });\n                            // Get the token metadata\n                            let metadata = {};\n                            const response = await new _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest(metadataUrl).send();\n                            response.assertOk();\n                            try {\n                                metadata = response.bodyJson;\n                            } catch (error) {\n                                try {\n                                    linkage.push({\n                                        type: \"!metadata\",\n                                        value: response.bodyText\n                                    });\n                                } catch (error) {\n                                    const bytes = response.body;\n                                    if (bytes) {\n                                        linkage.push({\n                                            type: \"!metadata\",\n                                            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes)\n                                        });\n                                    }\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (!metadata) {\n                                linkage.push({\n                                    type: \"!metadata\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata\",\n                                value: JSON.stringify(metadata)\n                            });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof imageUrl !== \"string\") {\n                                linkage.push({\n                                    type: \"!imageUrl\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                            } else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    linkage.push({\n                                        type: \"!imageUrl-ipfs\",\n                                        value: imageUrl\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"imageUrl-ipfs\",\n                                    value: imageUrl\n                                });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({\n                                type: \"url\",\n                                value: imageUrl\n                            });\n                            return {\n                                linkage,\n                                url: imageUrl\n                            };\n                        }\n                }\n            }\n        } catch (error) {}\n        return {\n            linkage,\n            url: null\n        };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\",\n            info: {\n                network\n            }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */ static async fromName(provider, name) {\n        let currentName = name;\n        while(true){\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !await resolver.supportsWildcard()) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n} //# sourceMappingURL=ens-resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDZ0Q7QUFDRztBQUNKO0FBQ087QUFDMEY7QUFDakoscURBQXFEO0FBQ3JELGlFQUFpRTtBQUNqRSxTQUFTYyxZQUFZQyxJQUFJO0lBQ3JCLElBQUlBLEtBQUtDLEtBQUssQ0FBQyxzQkFBc0I7UUFDakNELE9BQU9BLEtBQUtFLFNBQVMsQ0FBQztJQUMxQixPQUNLLElBQUlGLEtBQUtDLEtBQUssQ0FBQyxnQkFBZ0I7UUFDaENELE9BQU9BLEtBQUtFLFNBQVMsQ0FBQztJQUMxQixPQUNLO1FBQ0ROLCtEQUFjQSxDQUFDLE9BQU8sMkJBQTJCLFFBQVFJO0lBQzdEO0lBQ0EsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLENBQUM7QUFDbEQ7OztBQUdBOztDQUVDLEdBQ00sTUFBTUc7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDZFosaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFWTtRQUFLO0lBQ2xDO0lBQ0FDLFFBQVFDLFFBQVEsRUFBRTtRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREMsaUJBQWlCQyxRQUFRLEVBQUU7UUFDdkIsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxjQUFjRCxRQUFRLEVBQUVFLE9BQU8sRUFBRTtRQUNuQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGNBQWNKLFFBQVEsRUFBRUssSUFBSSxFQUFFO1FBQ2hDLE1BQU0sSUFBSUYsTUFBTTtJQUNwQjtBQUNKO0FBQ0EsTUFBTUcseUJBQXlCO0FBQy9COzs7O0NBSUMsR0FDTSxNQUFNQyxxQ0FBcUNiO0lBQzlDOztLQUVDLEdBQ0RDLGFBQWM7UUFDVixLQUFLLENBQUNXO0lBQ1Y7QUFDSjtBQUNBLE1BQU1FLGNB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QUFHcUUsSUFBSSxDQUFDO1FBQ3ZEO0lBQ0o7QUFDSixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzPzQyMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRU5TIGlzIGEgc2VydmljZSB3aGljaCBhbGxvd3MgZWFzeS10by1yZW1lbWJlciBuYW1lcyB0byBtYXAgdG9cbiAqICBuZXR3b3JrIGFkZHJlc3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Vucy1yZXNvbHZlcjpFTlMgUmVzb2x2ZXIgIFthYm91dC1lbnMtcnNvbHZlcl1cbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b0JlSGV4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIEZldGNoUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIHVzZSB0aGUgZmV0Y2gtZGF0YTppcGZzIGdhdGV3YXlcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIGBodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvJHtsaW5rfWA7XG59XG47XG47XG4vKipcbiAqICBBIHByb3ZpZGVyIHBsdWdpbiBzdXBlci1jbGFzcyBmb3IgcHJvY2Vzc2luZyBtdWx0aWNvaW4gYWRkcmVzcyB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvaXZkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZUFkZHJlc3MoY29pblR5cGUsIGFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xuLyoqXG4gKiAgQSAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKiBwcm92aWRlcyBzZXJ2aWNlIGZvciBjb21tb25cbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcbiAqICBkZWNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihCYXNpY011bHRpY29pblBsdWdpbklkKTtcbiAgICB9XG59XG5jb25zdCBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG5jb25zdCBtYXRjaGVycyA9IFtcbiAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihkYXRhKTooLiopJFwiLCBcImlcIiksXG4gICAgbWF0Y2hlcklwZnMsXG4gICAgbmV3IFJlZ0V4cChcIl5laXAxNTU6WzAtOV0rLyhlcmNbMC05XSspOiguKikkXCIsIFwiaVwiKSxcbl07XG4vKipcbiAqICBBIGNvbm5lY3RlZCBvYmplY3QgdG8gYSByZXNvbHZlZCBFTlMgbmFtZSByZXNvbHZlciwgd2hpY2ggY2FuIGJlXG4gKiAgdXNlZCB0byBxdWVyeSBhZGRpdGlvbmFsIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSByZXNvbHZlci5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSB0aGlzIHJlc29sdmVyIHdhcyByZXNvbHZlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLy8gRm9yIEVJUC0yNTQ0IG5hbWVzLCB0aGUgYW5jZXN0b3IgdGhhdCBwcm92aWRlZCB0aGUgcmVzb2x2ZXJcbiAgICAjc3VwcG9ydHMyNTQ0O1xuICAgICNyZXNvbHZlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XG4gICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVyID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIFtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmUoYnl0ZXMsIGJ5dGVzKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiB0ZXh0KGJ5dGVzMzIsIHN0cmluZykgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGNvbnRlbnRoYXNoKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQgZnV0dXJlIGF0dGVtcHRzIHRyeSBhZ2Fpbi4uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzdXBwb3J0czI1NDQ7XG4gICAgfVxuICAgIGFzeW5jICNmZXRjaChmdW5jTmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVycyBpcyBhbHdheXMgdGhlIG5vZGVoYXNoXG4gICAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWVoYXNoKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGZ1bmNOYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGRuc0VuY29kZSh0aGlzLm5hbWUsIDI1NSksXG4gICAgICAgICAgICAgICAgaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBwYXJhbXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXNvbHZlcltmdW5jTmFtZV0oLi4ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWNvaW5UeXBlJSUgb3IgbnVsbCBpZiB0aGVcbiAgICAgKiAgcHJvdmlkZWQgJSVjb2luVHlwZSUlIGhhcyBub3QgYmVlbiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvaW5UeXBlID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMilcIik7XG4gICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkZWNvZGluZyBpdHMgRVZNIGNhbm9uaWNhbCBjaGFpbiBhcyBhbiBFVk0gY2hhaW4gYWRkcmVzcyBmaXJzdFxuICAgICAgICBpZiAoY29pblR5cGUgPj0gMCAmJiBjb2luVHlwZSA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIGxldCBldGhDb2luVHlwZSA9IGNvaW5UeXBlICsgMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImFkZHIoYnl0ZXMzMix1aW50KVwiLCBbZXRoQ29pblR5cGVdKTtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCAyMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29pblBsdWdpbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucHJvdmlkZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29pblBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblBsdWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XG4gICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgY29pbiBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgaW5mbzogeyBjb2luVHlwZSwgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIEVJUC02MzQgdGV4dCByZWNvcmQgZm9yICUla2V5JSUsIG9yIGBgbnVsbGBgXG4gICAgICogIGlmIHVuY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUZXh0KGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJ0ZXh0KGJ5dGVzMzIsc3RyaW5nKVwiLCBba2V5XSk7XG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJzb2x2ZXMgdG8gdGhlIGNvbnRlbnQtaGFzaCBvciBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiY29udGVudGhhc2goYnl0ZXMzMilcIik7XG4gICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJUEZTIChDSUQ6IDEsIFR5cGU6IDcwPURBRy1QQiwgNzI9bGlicDJwLWtleSlcbiAgICAgICAgY29uc3QgaXBmcyA9IGRhdGEubWF0Y2goL14weChlMzAxMDE3MHxlNTAxMDE3MikoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gKGlwZnNbMV0gPT09IFwiZTMwMTAxNzBcIikgPyBcImlwZnNcIiA6IFwiaXBuc1wiO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1s0XSwgMTYpO1xuICAgICAgICAgICAgaWYgKGlwZnNbNV0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NjaGVtZX06L1xcLyR7ZW5jb2RlQmFzZTU4KFwiMHhcIiArIGlwZnNbMl0pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICBjb25zdCBzd2FybSA9IGRhdGEubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG4gICAgICAgIGlmIChzd2FybSAmJiBzd2FybVsxXS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICByZXR1cm4gYGJ6ejovXFwvJHtzd2FybVsxXX1gO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYXZhdGFyIHVybCBvciBgYG51bGxgYCBpZiB0aGUgYXZhdGFyIGlzIGVpdGhlclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxuICAgICAqICBub3Qgb3duZWQgYnkgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWZ1bC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuX2dldEF2YXRhcigpO1xuICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZW4gcmVzb2x2aW5nIGFuIGF2YXRhciwgdGhlcmUgYXJlIG1hbnkgc3RlcHMgaW52b2x2ZWQsIHN1Y2hcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXG4gICAgICogIE5GVC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XG4gICAgICogIHdhcyB3b3JraW5nIGZyb20uXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdGhpcy5uYW1lIH1dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYXZhdGFyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJhdmF0YXJcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZ2V0SXBmc0xpbmsoYXZhdGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IHVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwidG9rZW5VUkkodWludDI1NilcIiA6IFwidXJpKHVpbnQyNTYpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBgISR7c2NoZW1lfWNhaXBgLCB2YWx1ZTogKG1hdGNoWzJdIHx8IFwiXCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGNvbXBzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoY29tcHNbMF0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtNzIxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB0b2tlblVSSSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG93bmVyT2YodWludCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB1cmkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcywgdWludDI1NikgdmlldyByZXR1cm5zICh1aW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzcyMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IGF3YWl0IGNvbnRyYWN0Lm93bmVyT2YodG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKG93bmVyLCB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYmFsYW5jZVwiLCB2YWx1ZTogXCIwXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImJhbGFuY2VcIiwgdmFsdWU6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBhd2FpdCBjb250cmFjdFtzZWxlY3Rvcl0odG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCB8fCBtZXRhZGF0YVVybCA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGEtdXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRvQmVIZXgodG9rZW5JZCwgMzIpLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG5ldyBGZXRjaFJlcXVlc3QobWV0YWRhdGFVcmwpKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IHJlc3BvbnNlLmJvZHlUZXh0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBoZXhsaWZ5KGJ5dGVzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VVcmwgPSBtZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGdldEVuc0FkZHJlc3MocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZW5zUGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICBhc3NlcnQoZW5zUGx1Z2luLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEVuc0FkZHJlc3NcIiwgaW5mbzogeyBuZXR3b3JrIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnNQbHVnaW4uYWRkcmVzcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jICNnZXRSZXNvbHZlcihwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyhwcm92aWRlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBjb250cmFjdC5yZXNvbHZlcihuYW1laGFzaChuYW1lKSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKSxcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxuICAgICAqICBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50TmFtZSA9IG5hbWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoYXdhaXQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJaZXJvQWRkcmVzcyIsIkNvbnRyYWN0IiwiZG5zRW5jb2RlIiwibmFtZWhhc2giLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ0b0JlSGV4IiwiZGVmaW5lUHJvcGVydGllcyIsImVuY29kZUJhc2U1OCIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiaXNFcnJvciIsIkZldGNoUmVxdWVzdCIsImdldElwZnNMaW5rIiwibGluayIsIm1hdGNoIiwic3Vic3RyaW5nIiwiTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjb25uZWN0IiwicHJvaXZkZXIiLCJzdXBwb3J0c0NvaW5UeXBlIiwiY29pblR5cGUiLCJlbmNvZGVBZGRyZXNzIiwiYWRkcmVzcyIsIkVycm9yIiwiZGVjb2RlQWRkcmVzcyIsImRhdGEiLCJCYXNpY011bHRpY29pblBsdWdpbklkIiwiQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiIsIm1hdGNoZXJJcGZzIiwiUmVnRXhwIiwibWF0Y2hlcnMiLCJFbnNSZXNvbHZlciIsInN1cHBvcnRzMjU0NCIsInJlc29sdmVyIiwicHJvdmlkZXIiLCJzdXBwb3J0c1dpbGRjYXJkIiwic3VwcG9ydHNJbnRlcmZhY2UiLCJlcnJvciIsImZldGNoIiwiZnVuY05hbWUiLCJwYXJhbXMiLCJzbGljZSIsImlmYWNlIiwiaW50ZXJmYWNlIiwidW5zaGlmdCIsImZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJpbmZvIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwicHVzaCIsImVuYWJsZUNjaXBSZWFkIiwicmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJldGhDb2luVHlwZSIsImNvaW5QbHVnaW4iLCJwbHVnaW4iLCJwbHVnaW5zIiwib3BlcmF0aW9uIiwiZ2V0VGV4dCIsImtleSIsImdldENvbnRlbnRIYXNoIiwiaXBmcyIsInNjaGVtZSIsImxlbmd0aCIsInBhcnNlSW50Iiwic3dhcm0iLCJnZXRBdmF0YXIiLCJhdmF0YXIiLCJfZ2V0QXZhdGFyIiwidXJsIiwibGlua2FnZSIsInR5cGUiLCJ2YWx1ZSIsImkiLCJ0b0xvd2VyQ2FzZSIsInNlbGVjdG9yIiwib3duZXIiLCJjb21wcyIsInNwbGl0IiwidG9rZW5JZCIsImNvbnRyYWN0IiwidG9rZW5Pd25lciIsIm93bmVyT2YiLCJiYWxhbmNlIiwiYmFsYW5jZU9mIiwidG9TdHJpbmciLCJtZXRhZGF0YVVybCIsInJlcGxhY2UiLCJtZXRhZGF0YSIsInJlc3BvbnNlIiwic2VuZCIsImFzc2VydE9rIiwiYm9keUpzb24iLCJib2R5VGV4dCIsImJ5dGVzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbWFnZVVybCIsImltYWdlIiwiZ2V0RW5zQWRkcmVzcyIsIm5ldHdvcmsiLCJnZXROZXR3b3JrIiwiZW5zUGx1Z2luIiwiZ2V0UGx1Z2luIiwiZ2V0UmVzb2x2ZXIiLCJlbnNBZGRyIiwiYWRkciIsImZyb21OYW1lIiwiY3VycmVudE5hbWUiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: () => (/* binding */ allowNull),\n/* harmony export */   arrayOf: () => (/* binding */ arrayOf),\n/* harmony export */   formatBlock: () => (/* binding */ formatBlock),\n/* harmony export */   formatBoolean: () => (/* binding */ formatBoolean),\n/* harmony export */   formatData: () => (/* binding */ formatData),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   formatLog: () => (/* binding */ formatLog),\n/* harmony export */   formatReceiptLog: () => (/* binding */ formatReceiptLog),\n/* harmony export */   formatTransactionReceipt: () => (/* binding */ formatTransactionReceipt),\n/* harmony export */   formatTransactionResponse: () => (/* binding */ formatTransactionResponse),\n/* harmony export */   formatUint256: () => (/* binding */ formatUint256),\n/* harmony export */   object: () => (/* binding */ object)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  @_ignore\n */ \n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return function(value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    };\n}\nfunction arrayOf(format, allowNull) {\n    return (array)=>{\n        if (allowNull && array == null) {\n            return null;\n        }\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i)=>format(i));\n    };\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return (value)=>{\n        const result = {};\n        for(const key in format){\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]){\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            } catch (error) {\n                const message = error instanceof Error ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", {\n                    value\n                });\n            }\n        }\n        return result;\n    };\n}\nfunction formatBoolean(value) {\n    switch(value){\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    excessBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n    prevRandao: allowNull(formatHash, null),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)\n}, {\n    prevRandao: [\n        \"mixHash\"\n    ]\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx)=>{\n        if (typeof tx === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockHash: formatHash\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n    blobGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\n        \"gasPrice\"\n    ],\n    hash: [\n        \"transactionHash\"\n    ],\n    index: [\n        \"transactionIndex\"\n    ]\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, undefined),\n        type: (value)=>{\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n        authorizationList: allowNull(arrayOf((v)=>{\n            let sig;\n            if (v.signature) {\n                sig = v.signature;\n            } else {\n                let yParity = v.yParity;\n                if (yParity === \"0x1b\") {\n                    yParity = 0;\n                } else if (yParity === \"0x1c\") {\n                    yParity = 1;\n                }\n                sig = Object.assign({}, v, {\n                    yParity\n                });\n            }\n            return {\n                address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(v.address),\n                chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.chainId),\n                nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.nonce),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(sig)\n            };\n        }, false), null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null)\n    }, {\n        data: [\n            \"input\"\n        ],\n        gasLimit: [\n            \"gas\"\n        ],\n        index: [\n            \"transactionIndex\"\n        ]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value.signature);\n    } else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */ // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n} //# sourceMappingURL=format.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDa0U7QUFDcEI7QUFDUztBQUM2RDtBQUNySCxNQUFNVyxPQUFPQyxPQUFPO0FBQ2IsU0FBU0MsVUFBVUMsTUFBTSxFQUFFQyxTQUFTO0lBQ3ZDLE9BQVEsU0FBVUMsS0FBSztRQUNuQixJQUFJQSxTQUFTLE1BQU07WUFDZixPQUFPRDtRQUNYO1FBQ0EsT0FBT0QsT0FBT0U7SUFDbEI7QUFDSjtBQUNPLFNBQVNDLFFBQVFILE1BQU0sRUFBRUQsU0FBUztJQUNyQyxPQUFRLENBQUNLO1FBQ0wsSUFBSUwsYUFBYUssU0FBUyxNQUFNO1lBQzVCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1lBQ3ZCLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLE9BQU9ILE1BQU1JLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxPQUFPUztJQUNuQztBQUNKO0FBQ0EsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSxpREFBaUQ7QUFDMUMsU0FBU0MsT0FBT1YsTUFBTSxFQUFFVyxRQUFRO0lBQ25DLE9BQVEsQ0FBQ1Q7UUFDTCxNQUFNVSxTQUFTLENBQUM7UUFDaEIsSUFBSyxNQUFNQyxPQUFPYixPQUFRO1lBQ3RCLElBQUljLFNBQVNEO1lBQ2IsSUFBSUYsWUFBWUUsT0FBT0YsWUFBWSxDQUFFRyxDQUFBQSxVQUFVWixLQUFJLEdBQUk7Z0JBQ25ELEtBQUssTUFBTWEsVUFBVUosUUFBUSxDQUFDRSxJQUFJLENBQUU7b0JBQ2hDLElBQUlFLFVBQVViLE9BQU87d0JBQ2pCWSxTQUFTQzt3QkFDVDtvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsSUFBSTtnQkFDQSxNQUFNQyxLQUFLaEIsTUFBTSxDQUFDYSxJQUFJLENBQUNYLEtBQUssQ0FBQ1ksT0FBTztnQkFDcEMsSUFB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SSxNQUFNO1FBQ3hCLE1BQU1BLFVBQVV2RSxPQUFPbUUsU0FBUyxDQUFDVSxhQUFhO1FBQzlDLElBQUlOLFdBQVcsTUFBTTtZQUNqQnZFLE9BQU91RSxPQUFPLEdBQUdBO1FBQ3JCO0lBQ0o7SUFDQSx1QkFBdUI7SUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZ0NBLEdBQ0Esb0NBQW9DO0lBQ3BDLElBQUl2RSxPQUFPZ0IsU0FBUyxJQUFJdEMsMERBQVNBLENBQUNzQixPQUFPZ0IsU0FBUyxNQUFNL0IsTUFBTTtRQUMxRGUsT0FBT2dCLFNBQVMsR0FBRztJQUN2QjtJQUNBLE9BQU9oQjtBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9mb3JtYXQuanM/N2M0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBAX2lnbm9yZVxuICovXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDcmVhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgemVyb1BhZFZhbHVlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5T2YoZm9ybWF0LCBhbGxvd051bGwpIHtcbiAgICByZXR1cm4gKChhcnJheSkgPT4ge1xuICAgICAgICBpZiAoYWxsb3dOdWxsICYmIGFycmF5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpKSA9PiBmb3JtYXQoaSkpO1xuICAgIH0pO1xufVxuLy8gUmVxdWlyZXMgYW4gb2JqZWN0IHdoaWNoIG1hdGNoZXMgYSBmbGVldCBvZiBvdGhlciBmb3JtYXR0ZXJzXG4vLyBBbnkgRm9ybWF0RnVuYyBtYXkgcmV0dXJuIGB1bmRlZmluZWRgIHRvIGhhdmUgdGhlIHZhbHVlIG9taXR0ZWRcbi8vIGZyb20gdGhlIHJlc3VsdCBvYmplY3QuIENhbGxzIHByZXNlcnZlIGB0aGlzYC5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QoZm9ybWF0LCBhbHROYW1lcykge1xuICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIGxldCBzcmNLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoYWx0TmFtZXMgJiYga2V5IGluIGFsdE5hbWVzICYmICEoc3JjS2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWx0S2V5IG9mIGFsdE5hbWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjS2V5ID0gYWx0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG52ID0gZm9ybWF0W2tleV0odmFsdWVbc3JjS2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKG52ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFwibm90LWFuLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgaW52YWxpZCB2YWx1ZSBmb3IgdmFsdWUuJHtrZXl9ICgke21lc3NhZ2V9KWAsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJvb2xlYW4odmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGJvb2xlYW47ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGEodmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSksIFwiaW52YWxpZCBkYXRhXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRIYXNoKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIDMyKSwgXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVpbnQyNTYodmFsdWUpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XG4gICAgfVxuICAgIHJldHVybiB6ZXJvUGFkVmFsdWUodmFsdWUsIDMyKTtcbn1cbmNvbnN0IF9mb3JtYXRMb2cgPSBvYmplY3Qoe1xuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIHJlbW92ZWQ6IGFsbG93TnVsbChmb3JtYXRCb29sZWFuLCBmYWxzZSksXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdExvZyh2YWx1ZSk7XG59XG5jb25zdCBfZm9ybWF0QmxvY2sgPSBvYmplY3Qoe1xuICAgIGhhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoKSxcbiAgICBwYXJlbnRIYXNoOiBmb3JtYXRIYXNoLFxuICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIG51bWJlcjogZ2V0TnVtYmVyLFxuICAgIHRpbWVzdGFtcDogZ2V0TnVtYmVyLFxuICAgIG5vbmNlOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgZGlmZmljdWx0eTogZ2V0QmlnSW50LFxuICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIHN0YXRlUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIHJlY2VpcHRzUm9vdDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIGJsb2JHYXNVc2VkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBleGNlc3NCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBtaW5lcjogYWxsb3dOdWxsKGdldEFkZHJlc3MpLFxuICAgIHByZXZSYW5kYW86IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBleHRyYURhdGE6IGZvcm1hdERhdGEsXG4gICAgYmFzZUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludClcbn0sIHtcbiAgICBwcmV2UmFuZGFvOiBbXCJtaXhIYXNoXCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCbG9jayh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF9mb3JtYXRCbG9jayh2YWx1ZSk7XG4gICAgcmVzdWx0LnRyYW5zYWN0aW9ucyA9IHZhbHVlLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgX2Zvcm1hdFJlY2VpcHRMb2cgPSBvYmplY3Qoe1xuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSk7XG59XG5jb25zdCBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0ID0gb2JqZWN0KHtcbiAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGZyb206IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBjb250cmFjdEFkZHJlc3M6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIHJvb3Q6IGFsbG93TnVsbChoZXhsaWZ5KSxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIGxvZ3NCbG9vbTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgIGxvZ3M6IGFycmF5T2YoZm9ybWF0UmVjZWlwdExvZyksXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgIGJsb2JHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgc3RhdHVzOiBhbGxvd051bGwoZ2V0TnVtYmVyKSxcbiAgICB0eXBlOiBhbGxvd051bGwoZ2V0TnVtYmVyLCAwKVxufSwge1xuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBbXCJnYXNQcmljZVwiXSxcbiAgICBoYXNoOiBbXCJ0cmFuc2FjdGlvbkhhc2hcIl0sXG4gICAgaW5kZXg6IFtcInRyYW5zYWN0aW9uSW5kZXhcIl0sXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh2YWx1ZSkge1xuICAgIC8vIFNvbWUgY2xpZW50cyAoVGVzdFJQQykgZG8gc3RyYW5nZSB0aGluZ3MgbGlrZSByZXR1cm4gMHgwIGZvciB0aGVcbiAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgIGlmICh2YWx1ZS50byAmJiBnZXRCaWdJbnQodmFsdWUudG8pID09PSBCTl8wKSB7XG4gICAgICAgIHZhbHVlLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0KHtcbiAgICAgICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICAgICAgLy8gU29tZSBub2RlcyBkbyBub3QgcmV0dXJuIHRoaXMsIHVzdWFsbHkgdGVzdCBub2RlcyAobGlrZSBHYW5hY2hlKVxuICAgICAgICBpbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgdW5kZWZpbmVkKSxcbiAgICAgICAgdHlwZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiMHhcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWxsb3dOdWxsKGFjY2Vzc0xpc3RpZnksIG51bGwpLFxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBhbGxvd051bGwoYXJyYXlPZihmb3JtYXRIYXNoLCB0cnVlKSwgbnVsbCksXG4gICAgICAgIGF1dGhvcml6YXRpb25MaXN0OiBhbGxvd051bGwoYXJyYXlPZigodikgPT4ge1xuICAgICAgICAgICAgbGV0IHNpZztcbiAgICAgICAgICAgIGlmICh2LnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIHNpZyA9IHYuc2lnbmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHlQYXJpdHkgPSB2LnlQYXJpdHk7XG4gICAgICAgICAgICAgICAgaWYgKHlQYXJpdHkgPT09IFwiMHgxYlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5UGFyaXR5ID09PSBcIjB4MWNcIikge1xuICAgICAgICAgICAgICAgICAgICB5UGFyaXR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnID0gT2JqZWN0LmFzc2lnbih7fSwgdiwgeyB5UGFyaXR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKHYuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KHYuY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IGdldEJpZ0ludCh2Lm5vbmNlKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHNpZylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIGZhbHNlKSwgbnVsbCksXG4gICAgICAgIGJsb2NrSGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgICAgICBibG9ja051bWJlcjogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICBmcm9tOiBnZXRBZGRyZXNzLFxuICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpIG11c3QgYmUgc2V0XG4gICAgICAgIGdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICAgICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICAgICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgdmFsdWU6IGdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGdldE51bWJlcixcbiAgICAgICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICAgICAgY3JlYXRlczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICBjaGFpbklkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl0sXG4gICAgICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9IGdldENyZWF0ZUFkZHJlc3MocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICgodmFsdWUudHlwZSA9PT0gMSB8fCB2YWx1ZS50eXBlID09PSAyKSAmJiB2YWx1ZS5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgc2lnbmF0dXJlXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNvbWUgYmFja2VuZHMgb21pdCBDaGFpbklkIG9uIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGJ1dCB3ZSBjYW4gY29tcHV0ZSBpdFxuICAgIGlmIChyZXN1bHQuY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSByZXN1bHQuc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogY2hlY2sgY2hhaW5JRFxuICAgIC8qXG4gICAgaWYgKHZhbHVlLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUubmV0d29ya0lkO1xuXG4gICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHsgY2hhaW5JZCA9IDA7IH1cbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHsgY2hhaW5JZCA9IDA7IH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICAgICovXG4gICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgZ2V0QmlnSW50KHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsIlNpZ25hdHVyZSIsImFjY2Vzc0xpc3RpZnkiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJhbGxvd051bGwiLCJmb3JtYXQiLCJudWxsVmFsdWUiLCJ2YWx1ZSIsImFycmF5T2YiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwibWFwIiwiaSIsIm9iamVjdCIsImFsdE5hbWVzIiwicmVzdWx0Iiwia2V5Iiwic3JjS2V5IiwiYWx0S2V5IiwibnYiLCJ1bmRlZmluZWQiLCJlcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXRCb29sZWFuIiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdERhdGEiLCJmb3JtYXRIYXNoIiwiZm9ybWF0VWludDI1NiIsIl9mb3JtYXRMb2ciLCJhZGRyZXNzIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJkYXRhIiwiaW5kZXgiLCJyZW1vdmVkIiwidG9waWNzIiwidHJhbnNhY3Rpb25IYXNoIiwidHJhbnNhY3Rpb25JbmRleCIsImZvcm1hdExvZyIsIl9mb3JtYXRCbG9jayIsImhhc2giLCJwYXJlbnRIYXNoIiwicGFyZW50QmVhY29uQmxvY2tSb290IiwibnVtYmVyIiwidGltZXN0YW1wIiwibm9uY2UiLCJkaWZmaWN1bHR5IiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwic3RhdGVSb290IiwicmVjZWlwdHNSb290IiwiYmxvYkdhc1VzZWQiLCJleGNlc3NCbG9iR2FzIiwibWluZXIiLCJwcmV2UmFuZGFvIiwiZXh0cmFEYXRhIiwiYmFzZUZlZVBlckdhcyIsImZvcm1hdEJsb2NrIiwidHJhbnNhY3Rpb25zIiwidHgiLCJmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiX2Zvcm1hdFJlY2VpcHRMb2ciLCJmb3JtYXRSZWNlaXB0TG9nIiwiX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsInRvIiwiZnJvbSIsImNvbnRyYWN0QWRkcmVzcyIsInJvb3QiLCJsb2dzQmxvb20iLCJsb2dzIiwiY3VtdWxhdGl2ZUdhc1VzZWQiLCJlZmZlY3RpdmVHYXNQcmljZSIsImJsb2JHYXNQcmljZSIsInN0YXR1cyIsInR5cGUiLCJmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQiLCJhY2Nlc3NMaXN0IiwiYmxvYlZlcnNpb25lZEhhc2hlcyIsImF1dGhvcml6YXRpb25MaXN0IiwidiIsInNpZyIsInNpZ25hdHVyZSIsInlQYXJpdHkiLCJPYmplY3QiLCJhc3NpZ24iLCJjaGFpbklkIiwiZ2FzUHJpY2UiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsIm1heEZlZVBlckJsb2JHYXMiLCJjcmVhdGVzIiwibGVnYWN5Q2hhaW5JZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/network.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */ \n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/ const Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */ class Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */ constructor(name, chainId){\n        this.#name = name;\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */ toJSON() {\n        return {\n            name: this.name,\n            chainId: String(this.chainId)\n        };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */ get name() {\n        return this.#name;\n    }\n    set name(value) {\n        this.#name = value;\n    }\n    /**\n     *  The network chain ID.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\");\n    }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */ matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof other === \"string\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return this.name === other;\n        }\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return false;\n        }\n        if (typeof other === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId);\n                } catch (error) {}\n                return false;\n            }\n            if (other.name != null) {\n                return this.name === other.name;\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */ getPlugins(basename) {\n        return this.plugins.filter((p)=>p.name.split(\"#\")[0] === basename);\n    }\n    /**\n     *  Create a copy of this Network.\n     */ clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin)=>{\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */ computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin();\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for(let i = 2; i < tx.data.length; i += 2){\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\n            for(const addr in accessList){\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */ static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof network === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof network === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof network.clone === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof network === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network(network.name, network.chainId);\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */ static register(nameOrChainId, networkFunc) {\n        if (typeof nameOrChainId === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while(comps[1].length < decimals){\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request)=>{\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(),\n                fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n            };\n            return feeData;\n        } catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", {\n                request,\n                response,\n                error\n            });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function() {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin)=>{\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name)=>{\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, {\n        ensNetwork: 1,\n        altNames: [\n            \"homestead\"\n        ]\n    });\n    registerEth(\"ropsten\", 3, {\n        ensNetwork: 3\n    });\n    registerEth(\"rinkeby\", 4, {\n        ensNetwork: 4\n    });\n    registerEth(\"goerli\", 5, {\n        ensNetwork: 5\n    });\n    registerEth(\"kovan\", 42, {\n        ensNetwork: 42\n    });\n    registerEth(\"sepolia\", 11155111, {\n        ensNetwork: 11155111\n    });\n    registerEth(\"holesky\", 17000, {\n        ensNetwork: 17000\n    });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"arbitrum-sepolia\", 421614, {});\n    registerEth(\"base\", 8453, {\n        ensNetwork: 1\n    });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, {\n        ensNetwork: 1\n    });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, {\n        ensNetwork: 1\n    });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"linea-sepolia\", 59141, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-amoy\", 80002, {});\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\n            \"maticMumbai\",\n            \"maticmum\"\n        ],\n        plugins: [\n            getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"optimism-sepolia\", 11155420, {});\n    registerEth(\"xdai\", 100, {\n        ensNetwork: 1\n    });\n} //# sourceMappingURL=network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUN1RDtBQUNjO0FBQ3dCO0FBQzlGOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLEdBQ0EsTUFBTU8sV0FBVyxJQUFJQztBQUNyQjs7O0NBR0MsR0FDTSxNQUFNQztJQUNULENBQUNDLElBQUksQ0FBQztJQUNOLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNUOztLQUVDLEdBQ0RDLFlBQVlILElBQUksRUFBRUMsT0FBTyxDQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDRCxJQUFJLEdBQUdBO1FBQ2IsSUFBSSxDQUFDLENBQUNDLE9BQU8sR0FBR1YsMERBQVNBLENBQUNVO1FBQzFCLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUcsSUFBSUo7SUFDeEI7SUFDQTs7S0FFQyxHQUNETSxTQUFTO1FBQ0wsT0FBTztZQUFFSixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUFFQyxTQUFTSSxPQUFPLElBQUksQ0FBQ0osT0FBTztRQUFFO0lBQzVEO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJRCxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUFFO0lBQ2hDLElBQUlBLEtBQUtNLEtBQUssRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDTixJQUFJLEdBQUdNO0lBQU87SUFDdEM7O0tBRUMsR0FDRCxJQUFJTCxVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsT0FBTztJQUFFO0lBQ3RDLElBQUlBLFFBQVFLLEtBQUssRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDTCxPQUFPLEdBQUdWLDBEQUFTQSxDQUFDZSxPQUFPO0lBQVk7SUFDbEU7Ozs7OztLQU1DLEdBQ0RDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUlBLFNBQVMsTUFBTTtZQUNmLE9BQU87UUFDWDtRQUNBLElBQUksT0FB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QW1CLEtBQUssQ0FBQztJQUNyQ0EsWUFBWSxvQkFBb0IsVUFBVSxDQUFDO0lBQzNDQSxZQUFZLFFBQVEsS0FBSztRQUFFcEMsWUFBWTtJQUFFO0FBQzdDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9uZXR3b3JrLmpzPzM4MWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgcHJvcGVydGllcyByZXF1aXJlZCB0b1xuICogIGludGVyYWN0IHdpdGggYSBzcGVjaWZpYyBjaGFpbi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzOk5ldHdvcmtzICBbbmV0d29ya3NdXG4gKi9cbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUGx1Z2luLCBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luLCBHYXNDb3N0UGx1Z2luIH0gZnJvbSBcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCI7XG4vKiAqICogKlxuLy8gTmV0d29ya3Mgd2hpY2ggb3BlcmF0aW9uIGFnYWluc3QgYW4gTDIgY2FuIHVzZSB0aGlzIHBsdWdpbiB0b1xuLy8gc3BlY2lmeSBob3cgdG8gYWNjZXNzIEwxLCBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVzb2x2aW5nIEVOUyxcbi8vIGZvciBleGFtcGxlLlxuZXhwb3J0IGNsYXNzIExheWVyT25lQ29ubmVjdGlvblBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5IHByb3ZpZGVyITogUHJvdmlkZXI7XG4vLyBAVE9ETzogUmVuYW1lIHRvIENoYWluQWNjZXNzIGFuZCBhbGxvdyBmb3IgY29ubmVjdGluZyB0byBhbnkgY2hhaW5cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogUHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubGF5ZXItb25lLWNvbm5lY3Rpb25cIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXM8TGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luPih0aGlzLCB7IHByb3ZpZGVyIH0pO1xuICAgIH1cblxuICAgIGNsb25lKCk6IExheWVyT25lQ29ubmVjdGlvblBsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbn1cbiovXG5jb25zdCBOZXR3b3JrcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogIEEgKipOZXR3b3JrKiogcHJvdmlkZXMgYWNjZXNzIHRvIGEgY2hhaW4ncyBwcm9wZXJ0aWVzIGFuZCBhbGxvd3NcbiAqICBmb3IgcGx1Zy1pbnMgdG8gZXh0ZW5kIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrIHtcbiAgICAjbmFtZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjcGx1Z2lucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmsqKiBmb3IgJSVuYW1lJSUgYW5kICUlY2hhaW5JZCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcbiAgICAgICAgdGhpcy4jbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQoY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgTmV0d29yay5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMubmFtZSwgY2hhaW5JZDogU3RyaW5nKHRoaXMuY2hhaW5JZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNvbW1vbiBuYW1lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGNhbm9uaWNhbCBuYW1lLCBhcyBuZXR3b3JrcyBtaWdoIGhhdmUgbXVsdGlwbGVcbiAgICAgKiAgbmFtZXMuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLiNuYW1lOyB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHsgdGhpcy4jbmFtZSA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuZXR3b3JrIGNoYWluIElELlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUsIFwiY2hhaW5JZFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIG1hdGNoZXMgdGhpcyBuZXR3b3JrLiBBbnkgY2hhaW4gSURcbiAgICAgKiAgbXVzdCBtYXRjaCwgYW5kIGlmIG5vIGNoYWluIElEIGlzIHByZXNlbnQsIHRoZSBuYW1lIG11c3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgZG9lcyBub3QgY3VycmVudGx5IGNoZWNrIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMsXG4gICAgICogIHN1Y2ggYXMgRU5TIGFkZHJlc3Mgb3IgcGx1Zy1pbiBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIG1hdGNoZXMob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlci5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHBsdWdpbnMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgJSVwbHVnaW4lJSB0byB0aGlzIE5ldHdvcmsuIFRoZSBuZXR3b3JrIG5hbWVcbiAgICAgKiAgbXVzdCBiZSB1bmlxdWUsIGV4Y2x1ZGluZyBhbnkgZnJhZ21lbnQuXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHBsdWdpbiwgaWYgYW55LCBtYXRjaGluZyAlJW5hbWUlJSBleGFjdGx5LiBQbHVnaW5zXG4gICAgICogIHdpdGggZnJhZ21lbnRzIHdpbGwgbm90IGJlIHJldHVybmVkIHVubGVzcyAlJW5hbWUlJSBpbmNsdWRlc1xuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXRzIGEgbGlzdCBvZiBhbGwgcGx1Z2lucyB0aGF0IG1hdGNoICUlbmFtZSUlLCB3aXRoIG90ciB3aXRob3V0XG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2lucyhiYXNlbmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IChwLm5hbWUuc3BsaXQoXCIjXCIpWzBdID09PSBiYXNlbmFtZSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBOZXR3b3JrKHRoaXMubmFtZSwgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgY2xvbmUuYXR0YWNoUGx1Z2luKHBsdWdpbi5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQSBHYXNDb3N0UGx1Z2luIGNhbiBiZSBhdHRhY2hlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICB2YWx1ZXMuXG4gICAgICovXG4gICAgY29tcHV0ZUludHJpbnNpY0dhcyh0eCkge1xuICAgICAgICBjb25zdCBjb3N0cyA9IHRoaXMuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuR2FzQ29zdFwiKSB8fCAobmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgIGxldCBnYXMgPSBjb3N0cy50eEJhc2U7XG4gICAgICAgIGlmICh0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICBnYXMgKz0gY29zdHMudHhDcmVhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdHguZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhLnN1YnN0cmluZyhpLCBpICsgMikgPT09IFwiMDBcIikge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhWmVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFOb256ZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgaW4gYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20obmV0d29yaykge1xuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2Fub25pY2FsIG5hbWUgb3IgY2hhaW4gSURcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobmV0d29ya0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvbmFibGUgd2l0aCBuZXR3b3JrLWxpa2UgYWJpbGl0aWVzXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gbmV0d29yay5jbG9uZSgpO1xuICAgICAgICAgICAgLy9pZiAodHlwZW9mKG5ldHdvcmsubmFtZSkgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldHdvcmtpc2hcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmV0d29yay5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBuZXR3b3JrIG9iamVjdCBuYW1lIG9yIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tID0gbmV3IE5ldHdvcmsoKG5ldHdvcmsubmFtZSksIChuZXR3b3JrLmNoYWluSWQpKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgbmV0d29yay5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obmV0d29yay5lbnNBZGRyZXNzLCBuZXR3b3JrLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luKCg8YW55Pm5ldHdvcmspLmxheWVyT25lQ29ubmVjdGlvbikpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciAlJW5hbWVPckNoYWluSWQlJSB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgY29uZmxpY3RpbmcgbmV0d29yayBmb3IgJHtKU09OLnN0cmluZ2lmeShleGlzdGluZy5uYW1lKX1gLCBcIm5hbWVPckNoYWluSWRcIiwgbmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmV0d29ya3Muc2V0KG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKTtcbiAgICB9XG59XG4vLyBXZSBkb24ndCB3YW50IHRvIGJyaW5nIGluIGZvcm1hdFVuaXRzIGJlY2F1c2UgaXQgaXMgYmFja2VkIGJ5XG4vLyBGaXhlZE51bWJlciBhbmQgd2Ugd2FudCB0byBrZWVwIE5ldHdvcmtzIHRpbnkuIFRoZSB2YWx1ZXNcbi8vIGluY2x1ZGVkIGJ5IHRoZSBHYXMgU3RhdGlvbnMgYXJlIGFsc28gSUVFRSA3NTQgd2l0aCBsb3RzIG9mXG4vLyByb3VuZGluZyBpc3N1ZXMgYW5kIGV4Y2VlZCB0aGUgc3RyaWN0IGNoZWNrcyBmb3JtYXRVbml0cyBoYXMuXG5mdW5jdGlvbiBwYXJzZVVuaXRzKF92YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFN0cmluZyhfdmFsdWUpO1xuICAgIGlmICghdmFsdWUubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gQnJlYWsgaW50byBbIHdob2xlLCBmcmFjdGlvbiBdXG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb21wcy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICAvLyBNb3JlIHRoYW4gMSBkZWNpbWFsIHBvaW50IG9yIHRvbyBtYW55IGZyYWN0aW9uYWwgcG9zaXRpb25zXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gdG8gOSBkZWNpbWFscGxhY2VzXG4gICAgd2hpbGUgKGNvbXBzWzFdLmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbXBzWzFdICs9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUb28gbWFueSBkZWNpbWFscyBhbmQgc29tZSBub24temVybyBlbmRpbmcsIHRha2UgdGhlIGNlaWxpbmdcbiAgICBpZiAoY29tcHNbMV0ubGVuZ3RoID4gOSkge1xuICAgICAgICBsZXQgZnJhYyA9IEJpZ0ludChjb21wc1sxXS5zdWJzdHJpbmcoMCwgOSkpO1xuICAgICAgICBpZiAoIWNvbXBzWzFdLnN1YnN0cmluZyg5KS5tYXRjaCgvXjArJC8pKSB7XG4gICAgICAgICAgICBmcmFjKys7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHNbMV0gPSBmcmFjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoY29tcHNbMF0gKyBjb21wc1sxXSk7XG59XG4vLyBVc2VkIGJ5IFBvbHlnb24gdG8gdXNlIGEgZ2FzIHN0YXRpb24gZm9yIGZlZSBkYXRhXG5mdW5jdGlvbiBnZXRHYXNTdGF0aW9uUGx1Z2luKHVybCkge1xuICAgIHJldHVybiBuZXcgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbih1cmwsIGFzeW5jIChmZXRjaEZlZURhdGEsIHByb3ZpZGVyLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgIC8vIFByZXZlbnQgQ2xvdWRmbGFyZSBmcm9tIGJsb2NraW5nIG91ciByZXF1ZXN0IGluIG5vZGUuanNcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJVc2VyLUFnZW50XCIsIFwiZXRoZXJzXCIpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbX3Jlc3BvbnNlLCBfZmVlRGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCksIGZldGNoRmVlRGF0YSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX3Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3BvbnNlLmJvZHlKc29uLnN0YW5kYXJkO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogX2ZlZURhdGEuZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4RmVlLCA5KSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heFByaW9yaXR5RmVlLCA5KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZmVlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIHdpdGggcG9seWdvbiBnYXMgc3RhdGlvbiAoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnVybCl9KWAsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xubGV0IGluamVjdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbmplY3RDb21tb25OZXR3b3JrcygpIHtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcbiAgICBmdW5jdGlvbiByZWdpc3RlckV0aChuYW1lLCBjaGFpbklkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBXZSB1c2UgMCB0byBkaXNhYmxlIEVOU1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIoY2hhaW5JZCwgZnVuYyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicmlua2VieVwiLCA0LCB7IGVuc05ldHdvcms6IDQgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJzZXBvbGlhXCIsIDExMTU1MTExLCB7IGVuc05ldHdvcms6IDExMTU1MTExIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiaG9sZXNreVwiLCAxNzAwMCwgeyBlbnNOZXR3b3JrOiAxNzAwMCB9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNLb3R0aVwiLCA2LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tc2Vwb2xpYVwiLCA0MjE2MTQsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2VcIiwgODQ1MywgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1nb2VybGlcIiwgODQ1MzEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJhc2Utc2Vwb2xpYVwiLCA4NDUzMiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5iXCIsIDU2LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJ0XCIsIDk3LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYVwiLCA1OTE0NCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWEtZ29lcmxpXCIsIDU5MTQwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1zZXBvbGlhXCIsIDU5MTQxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpY1wiLCAxMzcsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1hbW95XCIsIDgwMDAyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1tdW1iYWlcIiwgODAwMDEsIHtcbiAgICAgICAgYWx0TmFtZXM6IFtcIm1hdGljTXVtYmFpXCIsIFwibWF0aWNtdW1cIl0sXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi10ZXN0bmV0LnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbVwiLCAxMCwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tc2Vwb2xpYVwiLCAxMTE1NTQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbImFjY2Vzc0xpc3RpZnkiLCJnZXRCaWdJbnQiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkVuc1BsdWdpbiIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJHYXNDb3N0UGx1Z2luIiwiTmV0d29ya3MiLCJNYXAiLCJOZXR3b3JrIiwibmFtZSIsImNoYWluSWQiLCJwbHVnaW5zIiwiY29uc3RydWN0b3IiLCJ0b0pTT04iLCJTdHJpbmciLCJ2YWx1ZSIsIm1hdGNoZXMiLCJvdGhlciIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYXR0YWNoUGx1Z2luIiwicGx1Z2luIiwiZ2V0IiwiRXJyb3IiLCJzZXQiLCJjbG9uZSIsImdldFBsdWdpbiIsImdldFBsdWdpbnMiLCJiYXNlbmFtZSIsImZpbHRlciIsInAiLCJzcGxpdCIsImZvckVhY2giLCJjb21wdXRlSW50cmluc2ljR2FzIiwidHgiLCJjb3N0cyIsImdhcyIsInR4QmFzZSIsInRvIiwidHhDcmVhdGUiLCJkYXRhIiwiaSIsImxlbmd0aCIsInN1YnN0cmluZyIsInR4RGF0YVplcm8iLCJ0eERhdGFOb256ZXJvIiwiYWNjZXNzTGlzdCIsImFkZHIiLCJ0eEFjY2Vzc0xpc3RBZGRyZXNzIiwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleSIsInN0b3JhZ2VLZXlzIiwibmV0d29yayIsImluamVjdENvbW1vbk5ldHdvcmtzIiwiQmlnSW50IiwibmV0d29ya0Z1bmMiLCJjdXN0b20iLCJlbnNBZGRyZXNzIiwiZW5zTmV0d29yayIsInJlZ2lzdGVyIiwibmFtZU9yQ2hhaW5JZCIsImV4aXN0aW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlVW5pdHMiLCJfdmFsdWUiLCJkZWNpbWFscyIsIm1hdGNoIiwiY29tcHMiLCJwdXNoIiwiZnJhYyIsInRvU3RyaW5nIiwiZ2V0R2FzU3RhdGlvblBsdWdpbiIsInVybCIsImZldGNoRmVlRGF0YSIsInByb3ZpZGVyIiwicmVxdWVzdCIsInNldEhlYWRlciIsInJlc3BvbnNlIiwiX3Jlc3BvbnNlIiwiX2ZlZURhdGEiLCJQcm9taXNlIiwiYWxsIiwic2VuZCIsInBheWxvYWQiLCJib2R5SnNvbiIsInN0YW5kYXJkIiwiZmVlRGF0YSIsImdhc1ByaWNlIiwibWF4RmVlUGVyR2FzIiwibWF4RmVlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZSIsImluamVjdGVkIiwicmVnaXN0ZXJFdGgiLCJvcHRpb25zIiwiZnVuYyIsImFsdE5hbWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: () => (/* binding */ EnsPlugin),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* binding */ FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* binding */ FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* binding */ GasCostPlugin),\n/* harmony export */   NetworkPlugin: () => (/* binding */ NetworkPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */ class NetworkPlugin {\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */ constructor(name){\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */ clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */ class GasCostPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */ constructor(effectiveBlock, costs){\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);\n        const props = {\n            effectiveBlock\n        };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof value === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */ class EnsPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */ constructor(address, targetNetwork){\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: address || EnsAddress,\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */ class FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */ get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */ constructor(feeDataFunc){\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */ async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */ get url() {\n        return this.#url;\n    }\n    /**\n     *  The callback to use when computing the FeeData.\n     */ get processFunc() {\n        return this.#processFunc;\n    }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */ constructor(url, processFunc){\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() {\n        return this;\n    }\n} /*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/  //# sourceMappingURL=plugins-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQ1A7QUFDbkQsTUFBTUUsYUFBYTtBQUNuQjs7Q0FFQyxHQUNNLE1BQU1DO0lBUVQ7O0tBRUMsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2RMLHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRUs7UUFBSztJQUNsQztJQUNBOztLQUVDLEdBQ0RDLFFBQVE7UUFDSixPQUFPLElBQUlILGNBQWMsSUFBSSxDQUFDRSxJQUFJO0lBQ3RDO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNRSxzQkFBc0JKO0lBZ0MvQjs7OztLQUlDLEdBQ0RDLFlBQVlJLGNBQWMsRUFBRUMsS0FBSyxDQUFFO1FBQy9CLElBQUlELGtCQUFrQixNQUFNO1lBQ3hCQSxpQkFBaUI7UUFDckI7UUFDQSxLQUFLLENBQUMsQ0FBQyxtQ0FBbUMsRUFBR0Esa0JBQWtCLEVBQUcsQ0FBQztRQUNuRSxNQUFNRSxRQUFRO1lBQUVGO1FBQWU7UUFDL0IsU0FBU0csSUFBSU4sSUFBSSxFQUFFTyxPQUFPO1lBQ3RCLElBQUlDLFFBQVEsQ0FBQ0osU0FBUyxDQUFDLEVBQUUsQ0FBQ0osS0FBSztZQUMvQixJQUFJUSxTQUFTLE1BQU07Z0JBQ2ZBLFFBQVFEO1lBQ1o7WUFDQVgsK0RBQWNBLENBQUMsT0FBUVksVUFBVyxVQUFVLENBQUMsa0JBQWtCLEVBQUVSLEtBQUssQ0FBQyxFQUFFLFNBQVNJO1lBQ2xGQyxLQUFLLENBQUNMLEtBQUssR0FBR1E7UUFDbEI7UUFDQUYsSUFBSSxVQUFVO1FBQ2RBLElBQUksWUFBWTtRQUNoQkEsSUFBSSxjQUFjO1FBQ2xCQSxJQUFJLGlCQUFpQjtRQUNyQkEsSUFBSSwwQkFBMEI7UUFDOUJBLElBQUksdUJBQXVCO1FBQzNCWCxzRUFBZ0JBLENBQUMsSUFBSSxFQUFFVTtJQUMzQjtJQUNBSixRQUFRO1FBQ0osT0FBTyxJQUFJQyxjQUFjLElBQUksQ0FBQ0MsY0FBYyxFQUFFLElBQUk7SUFDdEQ7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sTUFBTU0sa0JBQWtCWDtJQVMzQjs7OztLQUlDLEdBQ0RDLFlBQVlXLE9BQU8sRUFBRUMsYUFBYSxDQUFFO1FBQ2hDLEtBQUssQ0FBQztRQUNOaEIsc0VBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmUsU0FBVUEsV0FBV2I7WUFDckJjLGVBQWdCLGlCQUFrQixPQUFRLElBQUlBO1FBQ2xEO0lBQ0o7SUFDQVYsUUFBUTtRQUNKLE9BQU8sSUFBSVEsVUFBVSxJQUFJLENBQUNDLE9BQU8sRUFBRSxJQUFJLENBQUNDLGFBQWE7SUFDekQ7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1DLDZCQUE2QmQ7SUFDdEMsQ0FBQ2UsV0FBVyxDQUFDO0lBQ2I7O0tBRUMsR0FDRCxJQUFJQSxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUM1QjtJQUNBOztLQUVDLEdBQ0RkLFlBQVljLFdBQVcsQ0FBRTtRQUNyQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHQTtJQUN4QjtJQUNBOztLQUVDLEdBQ0QsTUFBTUMsV0FBV0MsUUFBUSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTSxJQUFJLENBQUMsQ0FBQ0YsV0FBVyxDQUFDRTtJQUNuQztJQUNBZCxRQUFRO1FBQ0osT0FBTyxJQUFJVyxxQkFBcUIsSUFBSSxDQUFDLENBQUNDLFdBQVc7SUFDckQ7QUFDSjtBQUNPLE1BQU1HLHFDQUFxQ2xCO0lBQzlDLENBQUNtQixHQUFHLENBQUM7SUFDTCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNELElBQUlELE1BQU07UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxHQUFHO0lBQUU7SUFDOUI7O0tBRUMsR0FDRCxJQUFJQyxjQUFjO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUFFO0lBQzlDOzs7S0FHQyxHQUNEbkIsWUFBWWtCLEdBQUcsRUFBRUMsV0FBVyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQyxDQUFDRCxHQUFHLEdBQUdBO1FBQ1osSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBR0E7SUFDeEI7SUFDQSxxREFBcUQ7SUFDckRqQixRQUFRO1FBQUUsT0FBTyxJQUFJO0lBQUU7QUFDM0IsRUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsSUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcz80MTI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEVuc0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmtQbHVnaW4qKiBwcm92aWRlcyBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgb24gYSBbW05ldHdvcmtdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSByZXZlcnNlLWRvbWFpbi1ub3RhdGlvbiwgd2hpY2ggcGVybWl0c1xuICAgICAqICB1bmlxdWUgbmFtZXMgd2l0aCBhIGtub3duIGF1dGhvcml0eSBhcyB3ZWxsIGFzIGhpZXJhcmNoYWwgZW50cmllcy5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrUGx1Z2luKHRoaXMubmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkdhc0Nvc3RQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYWx0ZXJuYXRpdmUgdmFsdWVzIHdoZW5cbiAqICBjb21wdXRpbmcgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXNDb3N0UGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgdG8gdHJlYXQgdGhlc2UgdmFsdWVzIGFzIHZhbGlkIGZyb20uXG4gICAgICpcbiAgICAgKiAgVGhpcyBhbGxvd3MgYSBoYXJkZm9yayB0byBoYXZlIHVwZGF0ZWQgdmFsdWVzIGluY2x1ZGVkIGFzIHdlbGwgYXNcbiAgICAgKiAgbXVsdXRpcGxlIGhhcmRmb3JrcyB0byBiZSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgZWZmZWN0aXZlQmxvY2s7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbnMgYmFzZSBmZWUuXG4gICAgICovXG4gICAgdHhCYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGZvciBjcmVhdGluZyBhIG5ldyBhY2NvdW50LlxuICAgICAqL1xuICAgIHR4Q3JlYXRlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciB6ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhWmVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgbm9uLXplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFOb256ZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBzdG9yYWdlIGtleSBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0U3RvcmFnZUtleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgYWRkcmVzcyBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBHYXNDb3N0UGx1Z2luIGZyb20gJSVlZmZlY3RpdmVCbG9jayUlIHVudGlsIHRoZVxuICAgICAqICBsYXRlc3QgYmxvY2sgb3IgYW5vdGhlciBHYXNDb3N0UGx1Z2luIHN1cGVyY2VkZXMgdGhhdCBibG9jayBudW1iZXIsXG4gICAgICogIHdpdGggdGhlIGFzc29jaWF0ZWQgJSVjb3N0cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdGl2ZUJsb2NrLCBjb3N0cykge1xuICAgICAgICBpZiAoZWZmZWN0aXZlQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWZmZWN0aXZlQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGBvcmcuZXRoZXJzLm5ldHdvcmsucGx1Z2lucy5HYXNDb3N0IyR7KGVmZmVjdGl2ZUJsb2NrIHx8IDApfWApO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHsgZWZmZWN0aXZlQmxvY2sgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIG51bGxpc2gpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChjb3N0cyB8fCB7fSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbGlzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiLCBgaW52YWx1ZCB2YWx1ZSBmb3IgJHtuYW1lfWAsIFwiY29zdHNcIiwgY29zdHMpO1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoXCJ0eEJhc2VcIiwgMjEwMDApO1xuICAgICAgICBzZXQoXCJ0eENyZWF0ZVwiLCAzMjAwMCk7XG4gICAgICAgIHNldChcInR4RGF0YVplcm9cIiwgNCk7XG4gICAgICAgIHNldChcInR4RGF0YU5vbnplcm9cIiwgMTYpO1xuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5XCIsIDE5MDApO1xuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RBZGRyZXNzXCIsIDI0MDApO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2FzQ29zdFBsdWdpbih0aGlzLmVmZmVjdGl2ZUJsb2NrLCB0aGlzKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkVuc1BsdWdpbioqIGFsbG93cyBhIFtbTmV0d29ya11dIHRvIHNwZWNpZnkgdGhlIEVOUyBSZWdpc3RyeVxuICogIENvbnRyYWN0IGFkZHJlc3MgYW5kIHRoZSB0YXJnZXQgbmV0d29yayB0byB1c2Ugd2hlbiB1c2luZyB0aGF0XG4gKiAgY29udHJhY3QuXG4gKlxuICogIFZhcmlvdXMgdGVzdG5ldHMgaGF2ZSB0aGVpciBvd24gaW5zdGFuY2Ugb2YgdGhlIGNvbnRyYWN0IHRvIHVzZSwgYnV0XG4gKiAgaW4gZ2VuZXJhbCwgdGhlIG1haW5uZXQgaW5zdGFuY2Ugc3VwcG9ydHMgbXVsdGktY2hhaW4gYWRkcmVzc2VzIGFuZFxuICogIHNob3VsZCBiZSB1c2VkLlxuICovXG5leHBvcnQgY2xhc3MgRW5zUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBFTlMgUmVnaXN0cnR5IENvbnRyYWN0IGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoYXQgdGhlIEVOUyBjb250cmFjdCBsaXZlcyBvbi5cbiAgICAgKi9cbiAgICB0YXJnZXROZXR3b3JrO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRW5zUGx1Z2luKiogY29ubmVjdGVkIHRvICUlYWRkcmVzcyUlIG9uIHRoZVxuICAgICAqICAlJXRhcmdldE5ldHdvcmslJS4gVGhlIGRlZmF1bHQgRU5TIGFkZHJlc3MgYW5kIG1haW5uZXQgaXMgdXNlZFxuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCB0YXJnZXROZXR3b3JrKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IChhZGRyZXNzIHx8IEVuc0FkZHJlc3MpLFxuICAgICAgICAgICAgdGFyZ2V0TmV0d29yazogKCh0YXJnZXROZXR3b3JrID09IG51bGwpID8gMSA6IHRhcmdldE5ldHdvcmspXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnNQbHVnaW4odGhpcy5hZGRyZXNzLCB0aGlzLnRhcmdldE5ldHdvcmspO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbmQgYWx0ZXJuYXRlXG4gKiAgbWVhbnMgdG8gc3BlY2lmeSBpdHMgZmVlIGRhdGEuXG4gKlxuICogIEZvciBleGFtcGxlLCBhIG5ldHdvcmsgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBbW2xpbmstZWlwLTE1NTldXSBtYXlcbiAqICBjaG9vc2UgdG8gdXNlIGEgR2FzIFN0YXRpb24gc2l0ZSB0byBhcHByb3hpbWF0ZSB0aGUgZ2FzIHByaWNlLlxuICovXG5leHBvcnQgY2xhc3MgRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjZmVlRGF0YUZ1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZGF0YSBmdW5jdGlvbiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZ2V0IGZlZURhdGFGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmZWVEYXRhRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZlZURhdGFcIik7XG4gICAgICAgIHRoaXMuI2ZlZURhdGFGdW5jID0gZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZmVlIGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmVlRGF0YShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmVlRGF0YUZ1bmMocHJvdmlkZXIpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhTmV0d29ya1BsdWdpbih0aGlzLiNmZWVEYXRhRnVuYyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjdXJsO1xuICAgICNwcm9jZXNzRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIFVSTCB0byBpbml0aWFsaXplIHRoZSBGZXRjaFJlcXVlc3Qgd2l0aCBpbiAlJXByb2Nlc3NGdW5jJSUuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2FsbGJhY2sgdG8gdXNlIHdoZW4gY29tcHV0aW5nIHRoZSBGZWVEYXRhLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHsgcmV0dXJuIHRoaXMuI3Byb2Nlc3NGdW5jOyB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKiogd2hpY2ggd2lsbFxuICAgICAqICBiZSB1c2VkIHdoZW4gY29tcHV0aW5nIHRoZSBmZWUgZGF0YSBmb3IgdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCBwcm9jZXNzRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICB0aGlzLiNwcm9jZXNzRnVuYyA9IHByb2Nlc3NGdW5jO1xuICAgIH1cbiAgICAvLyBXZSBhcmUgaW1tdXRhYmxlLCBzbyB3ZSBjYW4gc2VydmUgYXMgb3VyIG93biBjbG9uZVxuICAgIGNsb25lKCkgeyByZXR1cm4gdGhpczsgfVxufVxuLypcbmV4cG9ydCBjbGFzcyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSAjYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPjtcbiAgICByZWFkb25seSAjYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPjtcblxuICAgIGNvbnN0cnVjdG9yKGJsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz4sIGJsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4pIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLm5ldHdvcmstcGx1Z2lucy5jdXN0b20tYmxvY2tcIik7XG4gICAgICAgIHRoaXMuI2Jsb2NrRnVuYyA9IGJsb2NrRnVuYztcbiAgICAgICAgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyA9IGJsb2NrV2l0aFR4c0Z1bmM7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2socHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPik6IFByb21pc2U8QmxvY2s8c3RyaW5nPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2tpb25zKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KTogUHJvbWlzZTxCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGNsb25lKCk6IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luKHRoaXMuI2Jsb2NrRnVuYywgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyk7XG4gICAgfVxufVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMtbmV0d29yay5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydEFyZ3VtZW50IiwiRW5zQWRkcmVzcyIsIk5ldHdvcmtQbHVnaW4iLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjbG9uZSIsIkdhc0Nvc3RQbHVnaW4iLCJlZmZlY3RpdmVCbG9jayIsImNvc3RzIiwicHJvcHMiLCJzZXQiLCJudWxsaXNoIiwidmFsdWUiLCJFbnNQbHVnaW4iLCJhZGRyZXNzIiwidGFyZ2V0TmV0d29yayIsIkZlZURhdGFOZXR3b3JrUGx1Z2luIiwiZmVlRGF0YUZ1bmMiLCJnZXRGZWVEYXRhIiwicHJvdmlkZXIiLCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIiwidXJsIiwicHJvY2Vzc0Z1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: () => (/* binding */ BrowserProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\n\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */ class BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\n    #request;\n    #providerInfo;\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */ constructor(ethereum, network, _options){\n        // Copy the options\n        const options = Object.assign({}, _options != null ? _options : {}, {\n            batchMaxCount: 1\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, options);\n        this.#providerInfo = null;\n        if (_options && _options.providerInfo) {\n            this.#providerInfo = _options.providerInfo;\n        }\n        this.#request = async (method, params)=>{\n            const payload = {\n                method,\n                params\n            };\n            this.emit(\"debug\", {\n                action: \"sendEip1193Request\",\n                payload\n            });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Result\",\n                    result\n                });\n                return result;\n            } catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Error\",\n                    error\n                });\n                throw error;\n            }\n        };\n    }\n    get providerInfo() {\n        return this.#providerInfo;\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [\n                {\n                    id: payload.id,\n                    result\n                }\n            ];\n        } catch (e) {\n            return [\n                {\n                    id: payload.id,\n                    error: {\n                        code: e.code,\n                        data: e.data,\n                        message: e.message\n                    }\n                }\n            ];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into Ethers standard errors.\n        switch(error.error.code || -1){\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */ async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof address === \"number\") {\n            return accounts.length > address;\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a)=>a.toLowerCase() === address).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!await this.hasSigner(address)) {\n            try {\n                await this.#request(\"eth_requestAccounts\", []);\n            } catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, {\n                    id: payload.id,\n                    error\n                });\n            }\n        }\n        return await super.getSigner(address);\n    }\n    /**\n     *  Discover and connect to a Provider in the Browser using the\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\n     *  present, ``null`` is resolved.\n     */ static async discover(options) {\n        if (options == null) {\n            options = {};\n        }\n        if (options.provider) {\n            return new BrowserProvider(options.provider);\n        }\n        const context = options.window ? options.window : typeof window !== \"undefined\" ? window : null;\n        if (context == null) {\n            return null;\n        }\n        const anyProvider = options.anyProvider;\n        if (anyProvider && context.ethereum) {\n            return new BrowserProvider(context.ethereum);\n        }\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context && \"removeEventListener\" in context)) {\n            return null;\n        }\n        const timeout = options.timeout ? options.timeout : 300;\n        if (timeout === 0) {\n            return null;\n        }\n        return await new Promise((resolve, reject)=>{\n            let found = [];\n            const addProvider = (event)=>{\n                found.push(event.detail);\n                if (anyProvider) {\n                    finalize();\n                }\n            };\n            const finalize = ()=>{\n                clearTimeout(timer);\n                if (found.length) {\n                    // If filtering is provided:\n                    if (options && options.filter) {\n                        // Call filter, with a copies of found provider infos\n                        const filtered = options.filter(found.map((i)=>Object.assign({}, i.info)));\n                        if (filtered == null) {\n                            // No provider selected\n                            resolve(null);\n                        } else if (filtered instanceof BrowserProvider) {\n                            // Custom provider created\n                            resolve(filtered);\n                        } else {\n                            // Find the matching provider\n                            let match = null;\n                            if (filtered.uuid) {\n                                const matches = found.filter((f)=>filtered.uuid === f.info.uuid);\n                                // @TODO: What should happen if multiple values\n                                //        for the same UUID?\n                                match = matches[0];\n                            }\n                            if (match) {\n                                const { provider, info } = match;\n                                resolve(new BrowserProvider(provider, undefined, {\n                                    providerInfo: info\n                                }));\n                            } else {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                                    value: filtered\n                                }));\n                            }\n                        }\n                    } else {\n                        // Pick the first found provider\n                        const { provider, info } = found[0];\n                        resolve(new BrowserProvider(provider, undefined, {\n                            providerInfo: info\n                        }));\n                    }\n                } else {\n                    // Nothing found\n                    resolve(null);\n                }\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n            };\n            const timer = setTimeout(()=>{\n                finalize();\n            }, timeout);\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n        });\n    }\n} //# sourceMappingURL=provider-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThEO0FBQ0k7O0FBRWxFOzs7O0NBSUMsR0FDTSxNQUFNRyx3QkFBd0JELDJFQUF5QkE7SUFDMUQsQ0FBQ0UsT0FBTyxDQUFDO0lBQ1QsQ0FBQ0MsWUFBWSxDQUFDO0lBQ2Q7OztLQUdDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDckMsbUJBQW1CO1FBQ25CLE1BQU1DLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUksWUFBYSxPQUFRSCxXQUFXLENBQUMsR0FBSTtZQUFFSSxlQUFlO1FBQUU7UUFDM0ZiLCtEQUFjQSxDQUFDTyxZQUFZQSxTQUFTSCxPQUFPLEVBQUUsNkJBQTZCLFlBQVlHO1FBQ3RGLEtBQUssQ0FBQ0MsU0FBU0U7UUFDZixJQUFJLENBQUMsQ0FBQ0wsWUFBWSxHQUFHO1FBQ3JCLElBQUlJLFlBQVlBLFNBQVNKLFlBQVksRUFBRTtZQUNuQyxJQUFJLENBQUMsQ0FBQ0EsWUFBWSxHQUFHSSxTQUFTSixZQUFZO1FBQzlDO1FBQ0EsSUFBSSxDQUFDLENBQUNELE9BQU8sR0FBRyxPQUFPVSxRQUFRQztZQUMzQixNQUFNQyxVQUFVO2dCQUFFRjtnQkFBUUM7WUFBTztZQUNqQyxJQUFJLENBQUNFLElBQUksQ0FBQyxTQUFTO2dCQUFFQyxRQUFRO2dCQUFzQkY7WUFBUTtZQUMzRCxJQUFJO2dCQUNBLE1BQU1HLFNBQVMsTUFBTVosU0FBU0gsT0FBTyxDQUFDWTtnQkFDdEMsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztvQkFBRUMsUUFBUTtvQkFBd0JDO2dCQUFPO2dCQUM1RCxPQUFPQTtZQUNYLEVBQ0EsT0FBT0MsR0FBRztnQkFDTixNQUFNQyxRQUFRLElBQUlDLE1BQU1GLEVBQUVHLE9BQU87Z0JBQ2pDRixNQUFNRyxJQUFJLEdBQUdKLEVBQUVJ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QyxJQUFJQyxNQUFNO1FBQ3BDO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcz9jNmUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XG47XG4vKipcbiAqICBBICoqQnJvd3NlclByb3ZpZGVyKiogaXMgaW50ZW5kZWQgdG8gd3JhcCBhbiBpbmplY3RlZCBwcm92aWRlciB3aGljaFxuICogIGFkaGVyZXMgdG8gdGhlIFtbbGluay1laXAtMTE5M11dIHN0YW5kYXJkLCB3aGljaCBtb3N0IChpZiBub3QgYWxsKVxuICogIGN1cnJlbnRseSBkby5cbiAqL1xuZXhwb3J0IGNsYXNzIEJyb3dzZXJQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNyZXF1ZXN0O1xuICAgICNwcm92aWRlckluZm87XG4gICAgLyoqXG4gICAgICogIENvbm5lY3QgdG8gdGhlICUlZXRoZXJldW0lJSBwcm92aWRlciwgb3B0aW9uYWxseSBmb3JjaW5nIHRoZVxuICAgICAqICAlJW5ldHdvcmslJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihldGhlcmV1bSwgbmV0d29yaywgX29wdGlvbnMpIHtcbiAgICAgICAgLy8gQ29weSB0aGUgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgKChfb3B0aW9ucyAhPSBudWxsKSA/IF9vcHRpb25zIDoge30pLCB7IGJhdGNoTWF4Q291bnQ6IDEgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGV0aGVyZXVtICYmIGV0aGVyZXVtLnJlcXVlc3QsIFwiaW52YWxpZCBFSVAtMTE5MyBwcm92aWRlclwiLCBcImV0aGVyZXVtXCIsIGV0aGVyZXVtKTtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVySW5mbyA9IG51bGw7XG4gICAgICAgIGlmIChfb3B0aW9ucyAmJiBfb3B0aW9ucy5wcm92aWRlckluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVySW5mbyA9IF9vcHRpb25zLnByb3ZpZGVySW5mbztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZXF1ZXN0ID0gYXN5bmMgKG1ldGhvZCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyBtZXRob2QsIHBhcmFtcyB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZEVpcDExOTNSZXF1ZXN0XCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgIGVycm9yLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBwcm92aWRlckluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm92aWRlckluZm87XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFBcnJheS5pc0FycmF5KHBheWxvYWQpLCBcIkVJUC0xMTkzIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2ggcmVxdWVzdFwiLCBcInBheWxvYWRcIiwgcGF5bG9hZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXF1ZXN0KHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyB8fCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW3sgaWQ6IHBheWxvYWQuaWQsIHJlc3VsdCB9XTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXlsb2FkLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiBlLmNvZGUsIGRhdGE6IGUuZGF0YSwgbWVzc2FnZTogZS5tZXNzYWdlIH1cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcikge1xuICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgLy8gRUlQLTExOTMgZ2l2ZXMgdXMgc29tZSBtYWNoaW5lLXJlYWRhYmxlIGVycm9yIGNvZGVzLCBzbyByZXdyaXRlXG4gICAgICAgIC8vIHRoZW0gaW50byBFdGhlcnMgc3RhbmRhcmQgZXJyb3JzLlxuICAgICAgICBzd2l0Y2ggKGVycm9yLmVycm9yLmNvZGUgfHwgLTEpIHtcbiAgICAgICAgICAgIGNhc2UgNDAwMTpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11c2VyLWRlbmllZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQyMDA6XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IGBldGhlcnMtdW5zdXBwb3J0ZWQ6ICR7ZXJyb3IuZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiB0aGUgcHJvdmlkZXIgbWFuYWdlcyB0aGUgJSVhZGRyZXNzJSUuXG4gICAgICovXG4gICAgYXN5bmMgaGFzU2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhY2NvdW50cy5sZW5ndGggPiBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMuZmlsdGVyKChhKSA9PiAoYS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzKSkubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLmhhc1NpZ25lcihhZGRyZXNzKSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcmVxdWVzdChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGVycm9yLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCB7IGlkOiBwYXlsb2FkLmlkLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuZ2V0U2lnbmVyKGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGlzY292ZXIgYW5kIGNvbm5lY3QgdG8gYSBQcm92aWRlciBpbiB0aGUgQnJvd3NlciB1c2luZyB0aGVcbiAgICAgKiAgW1tsaW5rLWVpcC02OTYzXV0gZGlzY292ZXJ5IG1lY2hhbmlzbS4gSWYgbm8gcHJvdmlkZXJzIGFyZVxuICAgICAqICBwcmVzZW50LCBgYG51bGxgYCBpcyByZXNvbHZlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZGlzY292ZXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJvd3NlclByb3ZpZGVyKG9wdGlvbnMucHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBvcHRpb25zLndpbmRvdyA/IG9wdGlvbnMud2luZG93IDpcbiAgICAgICAgICAgICh0eXBlb2YgKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIpID8gd2luZG93IDogbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55UHJvdmlkZXIgPSBvcHRpb25zLmFueVByb3ZpZGVyO1xuICAgICAgICBpZiAoYW55UHJvdmlkZXIgJiYgY29udGV4dC5ldGhlcmV1bSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyUHJvdmlkZXIoY29udGV4dC5ldGhlcmV1bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gY29udGV4dCAmJiBcImRpc3BhdGNoRXZlbnRcIiBpbiBjb250ZXh0XG4gICAgICAgICAgICAmJiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/IG9wdGlvbnMudGltZW91dCA6IDMwMDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRQcm92aWRlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoYW55UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZpbHRlcmluZyBpcyBwcm92aWRlZDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgZmlsdGVyLCB3aXRoIGEgY29waWVzIG9mIGZvdW5kIHByb3ZpZGVyIGluZm9zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IG9wdGlvbnMuZmlsdGVyKGZvdW5kLm1hcChpID0+IE9iamVjdC5hc3NpZ24oe30sIChpLmluZm8pKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBwcm92aWRlciBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIEJyb3dzZXJQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBwcm92aWRlciBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWx0ZXJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkLnV1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGZvdW5kLmZpbHRlcihmID0+IChmaWx0ZXJlZC51dWlkID09PSBmLmluZm8udXVpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2hhdCBzaG91bGQgaGFwcGVuIGlmIG11bHRpcGxlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgZm9yIHRoZSBzYW1lIFVVSUQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGluZm8gfSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBCcm93c2VyUHJvdmlkZXIocHJvdmlkZXIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJJbmZvOiBpbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJmaWx0ZXIgcmV0dXJuZWQgdW5rbm93biBpbmZvXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGljayB0aGUgZmlyc3QgZm91bmQgcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGluZm8gfSA9IGZvdW5kWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgQnJvd3NlclByb3ZpZGVyKHByb3ZpZGVyLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckluZm86IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgYWRkUHJvdmlkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IGZpbmFsaXplKCk7IH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKFwiZWlwNjk2Mzphbm5vdW5jZVByb3ZpZGVyXCIsIGFkZFByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJlaXA2OTYzOnJlcXVlc3RQcm92aWRlclwiKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudCIsIm1ha2VFcnJvciIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJyZXF1ZXN0IiwicHJvdmlkZXJJbmZvIiwiY29uc3RydWN0b3IiLCJldGhlcmV1bSIsIm5ldHdvcmsiLCJfb3B0aW9ucyIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJiYXRjaE1heENvdW50IiwibWV0aG9kIiwicGFyYW1zIiwicGF5bG9hZCIsImVtaXQiLCJhY3Rpb24iLCJyZXN1bHQiLCJlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiZGF0YSIsInNlbmQiLCJfc3RhcnQiLCJfc2VuZCIsIkFycmF5IiwiaXNBcnJheSIsImlkIiwiZ2V0UnBjRXJyb3IiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoYXNTaWduZXIiLCJhZGRyZXNzIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImZpbHRlciIsImEiLCJnZXRTaWduZXIiLCJkaXNjb3ZlciIsInByb3ZpZGVyIiwiY29udGV4dCIsIndpbmRvdyIsImFueVByb3ZpZGVyIiwidGltZW91dCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZm91bmQiLCJhZGRQcm92aWRlciIsImV2ZW50IiwicHVzaCIsImRldGFpbCIsImZpbmFsaXplIiwiY2xlYXJUaW1lb3V0IiwidGltZXIiLCJmaWx0ZXJlZCIsIm1hcCIsImkiLCJpbmZvIiwibWF0Y2giLCJ1dWlkIiwibWF0Y2hlcyIsImYiLCJ1bmRlZmluZWQiLCJ2YWx1ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: () => (/* binding */ JsonRpcApiPollingProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* binding */ JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */ // @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof value.getAddress === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(deepCopy);\n    }\n    if (typeof value === \"object\") {\n        return Object.keys(value).reduce((accum, key)=>{\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof value})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: 1 << 20,\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    constructor(provider, address){\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            address\n        });\n    }\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async ()=>{\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async ()=>{\n                tx.gasLimit = await this.provider.estimateGas({\n                    ...tx,\n                    from: this.address\n                });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async ()=>{\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [\n            hexTx\n        ]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await new Promise((resolve, reject)=>{\n            const timeouts = [\n                1000,\n                100\n            ];\n            let invalids = 0;\n            const checkTx = async ()=>{\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n                } catch (error) {\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CANCELLED\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"NETWORK_ERROR\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"UNSUPPORTED_OPERATION\")) {\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        reject(error);\n                        return;\n                    }\n                    // Stop-gap for misbehaving backends; see #4513\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", {\n                        error\n                    }));\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(()=>{\n                    checkTx();\n                }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        });\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [\n            hexTx\n        ]);\n    }\n    async signMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message),\n            this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, async (value)=>{\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(),\n            password,\n            null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */ class JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no harm in sending it immediately\n        const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(()=>{\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while(payloads.length){\n                // Create payload batches that satisfy our batch constraints\n                const batch = [\n                    payloads.shift()\n                ];\n                while(payloads.length){\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push(payloads.shift());\n                    const bytes = JSON.stringify(batch.map((p)=>p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(batch.pop());\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async ()=>{\n                    const payload = batch.length === 1 ? batch[0].payload : batch.map((p)=>p.payload);\n                    this.emit(\"debug\", {\n                        action: \"sendRpcPayload\",\n                        payload\n                    });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcResult\",\n                            result\n                        });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch){\n                            if (this.destroyed) {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                                    operation: payload.method\n                                }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r)=>r.id === payload.id)[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result,\n                                    info: {\n                                        payload\n                                    }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    } catch (error) {\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcError\",\n                            error\n                        });\n                        for (const { reject } of batch){\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options){\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve)=>{\n                resolve = _resolve;\n            });\n            this.#notReady = {\n                promise,\n                resolve\n            };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof staticNetwork === \"boolean\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from(network);\n            }\n        } else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */ _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */ get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */ async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, {\n                                type: undefined\n                            })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */ async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            } else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async ()=>{\n                try {\n                    const result = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(await this.send(\"eth_chainId\", [])));\n                    this.#pendingDetectNetwork = null;\n                    return result;\n                } catch (error) {\n                    this.#pendingDetectNetwork = null;\n                    throw error;\n                }\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async ()=>{\n            const payload = {\n                id: this.#nextId++,\n                method: \"eth_chainId\",\n                params: [],\n                jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", {\n                action: \"sendRpcPayload\",\n                payload\n            });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            } catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", {\n                    action: \"receiveRpcError\",\n                    error\n                });\n                throw error;\n            }\n            this.emit(\"debug\", {\n                action: \"receiveRpcResult\",\n                result\n            });\n            if (\"result\" in result) {\n                return _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */ _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async ()=>{\n            // Bootstrap the network\n            while(this.#network == null && !this.destroyed){\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                        event: \"initial-network-discovery\",\n                        info: {\n                            error\n                        }\n                    }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */ async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */ _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */ get ready() {\n        return this.#notReady == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */ getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_13__.accessListify)(tx.accessList);\n        }\n        if (tx.blobVersionedHashes) {\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n            result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map((h)=>h.toLowerCase());\n        }\n        if (tx.authorizationList) {\n            result[\"authorizationList\"] = tx.authorizationList.map((_a)=>{\n                const a = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_14__.authorizationify)(_a);\n                return {\n                    address: a.address,\n                    nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.nonce),\n                    chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.chainId),\n                    yParity: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.yParity),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.r),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.s)\n                };\n            });\n        }\n        // @TODO: blobs should probably also be copied over, optionally\n        // accounting for the kzg property to backfill blobVersionedHashes\n        // using the commitment. Or should that be left as an exercise to\n        // the caller?\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */ getRpcRequest(req) {\n        switch(req.method){\n            case \"chainId\":\n                return {\n                    method: \"eth_chainId\",\n                    args: []\n                };\n            case \"getBlockNumber\":\n                return {\n                    method: \"eth_blockNumber\",\n                    args: []\n                };\n            case \"getGasPrice\":\n                return {\n                    method: \"eth_gasPrice\",\n                    args: []\n                };\n            case \"getPriorityFee\":\n                return {\n                    method: \"eth_maxPriorityFeePerGas\",\n                    args: []\n                };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        \"0x\" + req.position.toString(16),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [\n                        req.signedTransaction\n                    ]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [\n                            req.blockTag,\n                            !!req.includeTransactions\n                        ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [\n                            req.blockHash,\n                            !!req.includeTransactions\n                        ]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [\n                        this.getRpcTransaction(req.transaction),\n                        req.blockTag\n                    ]\n                };\n            case \"estimateGas\":\n                {\n                    return {\n                        method: \"eth_estimateGas\",\n                        args: [\n                            this.getRpcTransaction(req.transaction)\n                        ]\n                    };\n                }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return {\n                    method: \"eth_getLogs\",\n                    args: [\n                        req.filter\n                    ]\n                };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */ getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_15__.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n            e.info = {\n                error,\n                payload\n            };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\"\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: actionMap[method] || \"unknown\",\n                reason: \"rejected\",\n                info: {\n                    payload,\n                    error\n                }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = payload.params[0];\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method,\n                    info: {\n                        transaction,\n                        info: {\n                            error\n                        }\n                    }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method,\n                info: {\n                    error,\n                    payload\n                }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n            error,\n            payload\n        });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */ send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: method\n            }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject)=>{\n            this.#payloads.push({\n                resolve,\n                reject,\n                payload: {\n                    method,\n                    params,\n                    id,\n                    jsonrpc: \"2.0\"\n                }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */ async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof address === \"number\") {\n            const accounts = await accountsPromise;\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        for (const account of accounts){\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a)=>new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads){\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n            }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */ class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options){\n        super(network, options);\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (pollingInterval == null) {\n            pollingInterval = defaultOptions.pollingInterval;\n        }\n        this.#pollingInterval = pollingInterval;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */ get pollingInterval() {\n        return this.#pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub)=>{\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */ class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options){\n        if (url == null) {\n            url = \"http://localhost:8545\";\n        }\n        super(network, options);\n        if (typeof url === \"string\") {\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [\n                resp\n            ];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(value.data)) {\n        return {\n            message: value.message,\n            data: value.data\n        };\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) {}\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) {}\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n} //# sourceMappingURL=provider-jsonrpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVM7QUFDVCx5QkFBeUI7QUFDekIseVFBQXlRO0FBQzlOO0FBQ3NCO0FBQ2I7QUFDc0I7QUFDa0g7QUFDN0c7QUFDekI7QUFDZjtBQUN1RDtBQUM3QjtBQUNqRSxNQUFNeUIsWUFBWSwrQ0FBK0NDLEtBQUssQ0FBQztBQUN2RSxnREFBZ0Q7QUFDaEQsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixJQUFJQSxTQUFTLFFBQVFILFVBQVVJLE9BQU8sQ0FBQyxPQUFRRCxVQUFXLEdBQUc7UUFDekQsT0FBT0E7SUFDWDtJQUNBLHVCQUF1QjtJQUN2QixJQUFJLE9BQVFBLE1BQU0zQixVQUFVLEtBQU0sWUFBWTtRQUMxQyxPQUFPMkI7SUFDWDtJQUNBLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtRQUN0QixPQUFRQSxNQUFNSSxHQUFHLENBQUNMO0lBQ3RCO0lBQ0EsSUFBSSxPQUFRQyxVQUFXLFVBQVU7UUFDN0IsT0FBT0ssT0FBT0MsSUFBSSxDQUFDTixPQUFPTyxNQUFNLENBQUMsQ0FBQ0MsT0FBT0M7WUFDckNELEtBQUssQ0FBQ0MsSUFBSSxHQUFHVCxLQUFLLENBQUNTLElBQUk7WUFDdkIsT0FBT0Q7UUFDWCxHQUFHLENBQUM7SUFDUjtJQUNBLE1BQU0sSUFBSUUsTUFBTSxDQUFDLG1CQUFtQixFQUFFVixNQUFNLEVBQUUsRUFBRSxPQUFRQSxNQUFPLENBQUMsQ0FBQztBQUNyRTtBQUNBLFNBQVNXLE1BQU1DLFFBQVE7SUFDbkIsT0FBTyxJQUFJQyxRQUFRLENBQUNDO1FBQWNDLFdBQVdELFNBQVNGO0lBQVc7QUFDckU7QUFDQSxTQUFTSSxhQUFhaEIsS0FBSztJQUN2QixJQUFJQSxPQUFPO1FBQ1AsT0FBT0EsTUFBTWlCLFdBQVc7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NEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanM/N2U0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xuICogIGJ5IGEgbm9kZSBydW5uaW5nIGEgSlNPTi1SUEMgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgdG8sXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XG4gKlxuICogIC0gSFRUUCBvciBIVFRQUyAtIFtbSnNvblJwY1Byb3ZpZGVyXV1cbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXG4gKlxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIGF1dGhvcml6YXRpb25pZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgYWRkcmVzcztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgIH1cbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBqdXN0IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBzZW50LCB3aGljaCBpcyB3aGF0XG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0cyA9IFsxMDAwLCAxMDBdO1xuICAgICAgICAgICAgbGV0IGludmFsaWRzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGNhbmNlbGxlZDogc3RvcCBwb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBpcyBiYWQ6IHRoZSBub2RlIHJldHVybnMgYmFkIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBjaGFuZ2VkOiBjYWxsaW5nIGFnYWluIHdpbGwgYWxzbyBmYWlsXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVuc3VwcG9ydGVkOiBsaWtlbHkgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTkNFTExFRFwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Vycm9yKGVycm9yLCBcIk5FVFdPUktfRVJST1JcIikgfHwgaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wLWdhcCBmb3IgbWlzYmVoYXZpbmcgYmFja2VuZHM7IHNlZSAjNDUxM1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZHMgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbnlvbmUgdGhhdCBjYXJlczsgYnV0IHdlIHdpbGwgdHJ5IGFnYWluLCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBsaWtlbHkgYW4gaW50ZXJtaXR0ZW50IHNlcnZpY2UgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGZldGNoIHRyYW5zYXRpb24gYWZ0ZXIgc2VuZGluZyAod2lsbCB0cnkgYWdhaW4pXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3NldFRpbWVvdXQoKCkgPT4geyBjaGVja1R4KCk7IH0sIHRpbWVvdXRzLnBvcCgpIHx8IDQwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJtIGluIHNlbmRpbmcgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghc3RhdGljTmV0d29yayB8fCBuZXR3b3JrICE9PSBcImFueVwiLCBcInN0YXRpY05ldHdvcmsgY2Fubm90IGJlIHVzZWQgb24gc3BlY2lhbCBuZXR3b3JrICdhbnknXCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yaykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBzdGF0aWMgbmV0d29yayBpcyBjb21wYXRiaWxlIHdpdGggdGhlIHByb3ZpZGVkIG5ldHdyb2tcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgb3IgbmV3ZXIgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgcHJlLUVJUC0xNTU5XG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyB0eXBlOiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJwY1JlcXVlc3QocmVxKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxuICAgICAqXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE5ldHdvcmsuZnJvbShnZXRCaWdJbnQoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChyZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXG4gICAgICogIHRvIFF1YW50aXR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgPGFueT4gY2FzZSBvbmNlIEVJUC00ODQ0IGFkZGVkIHRvIHByZXBhcmVkIHR4XG4gICAgICAgICAgICByZXN1bHRbXCJibG9iVmVyc2lvbmVkSGFzaGVzXCJdID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcy5tYXAoaCA9PiBoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYXV0aG9yaXphdGlvbkxpc3RcIl0gPSB0eC5hdXRob3JpemF0aW9uTGlzdC5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGF1dGhvcml6YXRpb25pZnkoX2EpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRvUXVhbnRpdHkoYS5ub25jZSksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRvUXVhbnRpdHkoYS5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogdG9RdWFudGl0eShhLnNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgcjogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5yKSxcbiAgICAgICAgICAgICAgICAgICAgczogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5zKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IGJsb2JzIHNob3VsZCBwcm9iYWJseSBhbHNvIGJlIGNvcGllZCBvdmVyLCBvcHRpb25hbGx5XG4gICAgICAgIC8vIGFjY291bnRpbmcgZm9yIHRoZSBremcgcHJvcGVydHkgdG8gYmFja2ZpbGwgYmxvYlZlcnNpb25lZEhhc2hlc1xuICAgICAgICAvLyB1c2luZyB0aGUgY29tbWl0bWVudC4gT3Igc2hvdWxkIHRoYXQgYmUgbGVmdCBhcyBhbiBleGVyY2lzZSB0b1xuICAgICAgICAvLyB0aGUgY2FsbGVyP1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcmVxdWVzdCBtZXRob2QgYW5kIGFyZ3VtZW50cyByZXF1aXJlZCB0byBwZXJmb3JtXG4gICAgICogICUlcmVxJSUuXG4gICAgICovXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9ibG9ja051bWJlclwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nYXNQcmljZVwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiMHhcIiArIHJlcS5wb3NpdGlvbi50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5zaWduZWRUcmFuc2FjdGlvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja1RhZywgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJibG9ja0hhc2hcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tIYXNoLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9lc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChyZXEuZmlsdGVyICYmIHJlcS5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcS5maWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IHJlcS5maWx0ZXIuYWRkcmVzcy5tYXAoZ2V0TG93ZXJDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShyZXEuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLCBhcmdzOiBbcmVxLmZpbHRlcl0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLXN0eWxlIEVycm9yIGZvciB0aGUgZ2l2ZW4gSlNPTi1SUEMgZXJyb3JcbiAgICAgKiAgJSVwYXlsb2FkJSUsIGNvYWxlc2NpbmcgdGhlIHZhcmlvdXMgc3RyaW5ncyBhbmQgZXJyb3Igc2hhcGVzXG4gICAgICogIHRoYXQgZGlmZmVyZW50IG5vZGVzIHJldHVybiwgY29lcmNpbmcgdGhlbSBpbnRvIGEgbWFjaGluZS1yZWFkYWJsZVxuICAgICAqICBzdGFuZGFyZGl6ZWQgZXJyb3IuXG4gICAgICovXG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgX2Vycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kIH0gPSBwYXlsb2FkO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBfZXJyb3I7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbXNnLm1hdGNoKC9yZXZlcnQvaSkgJiYgbXNnLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXNnLm1hdGNoKC9ub25jZS9pKSAmJiBtc2cubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9jYWxsXCIgfHwgbWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YShlcnJvcik7XG4gICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXG4gICAgICAgIC8vIHdlIGNhbiBwcm9jZXNzIHRleHQgc2FmZWx5LlxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25NYXAgPSB7XG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IFwic2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKGB1c2VyIHJlamVjdGVkIGFjdGlvbmAsIFwiQUNUSU9OX1JFSkVDVEVEXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IChhY3Rpb25NYXBbbWV0aG9kXSB8fCBcInVua25vd25cIiksXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiB8fCBtZXRob2QgPT09IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IChwYXlsb2FkLnBhcmFtc1swXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiY291bGQgbm90IGNvYWxlc2NlIGVycm9yXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yLCBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVxdWVzdHMgdGhlICUlbWV0aG9kJSUgd2l0aCAlJXBhcmFtcyUlIHZpYSB0aGUgSlNPTi1SUEMgcHJvdG9jb2xcbiAgICAgKiAgb3ZlciB0aGUgdW5kZXJseWluZyBjaGFubmVsLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGwgbWV0aG9kc1xuICAgICAqICBvbiB0aGUgYmFja2VuZCB0aGF0IGRvIG5vdCBoYXZlIGEgaGlnaC1sZXZlbCBBUEkgd2l0aGluIHRoZSBQcm92aWRlclxuICAgICAqICBBUEkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgcXVldWVzIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGUgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgKiAgaW4gdGhlIG9wdGlvbnMsIGFzc2lnbnMgdGhlIHJlcXVlc3QgYSB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiAgKipEbyBOT1Qgb3ZlcnJpZGUqKiB0aGlzIG1ldGhvZCBpbiBzdWItY2xhc3NlczsgaW5zdGVhZFxuICAgICAqICBvdmVycmlkZSBbW19zZW5kXV0gb3IgZm9yY2UgdGhlIG9wdGlvbnMgdmFsdWVzIGluIHRoZVxuICAgICAqICBjYWxsIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBjYWNoZSBjaGFpbklkPz8gcHVyZ2Ugb24gc3dpdGNoX25ldHdvcmtzXG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBkZXN0cm95ZWQ7IG5vIG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZCBhbnltb3JlXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1Byb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdJbnRlcnZhbFwiKTtcbiAgICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWwgPSBkZWZhdWx0T3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA0MDAwIG1zKVxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0LmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQWxsIHJlcXVlc3RzIGFyZSBvdmVyIEhUVFAsIHNvIHdlIGNhbiBqdXN0IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaGVyZSByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3Igc28gdGhhdCB3ZSBkb24ndCBzZW5kIGFueVxuICAgICAgICAvLyByZXF1ZXN0cyB0byB0aGUgbmV0d29yayAoaS5lLiBldGhfY2hhaW5JZCkgdW50aWwgd2UgYWJzb2x1dGVseSBoYXZlIHRvLlxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgUE9TVCBjb25uZWN0aW9uIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICBsZXQgcmVzcCA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcCkpIHtcbiAgICAgICAgICAgIHJlc3AgPSBbcmVzcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YTogdmFsdWUuZGF0YSB9O1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmtEYXRhKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZVtrZXldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF9zcGVsdW5rTWVzc2FnZShKU09OLnBhcnNlKHZhbHVlKSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtNZXNzYWdlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1qc29ucnBjLmpzLm1hcCJdLCJuYW1lcyI6WyJBYmlDb2RlciIsImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsIlR5cGVkRGF0YUVuY29kZXIiLCJhY2Nlc3NMaXN0aWZ5IiwiYXV0aG9yaXphdGlvbmlmeSIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ0b1F1YW50aXR5IiwidG9VdGY4Qnl0ZXMiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJGZXRjaFJlcXVlc3QiLCJyZXNvbHZlUHJvcGVydGllcyIsIkFic3RyYWN0UHJvdmlkZXIiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiQWJzdHJhY3RTaWduZXIiLCJOZXR3b3JrIiwiRmlsdGVySWRFdmVudFN1YnNjcmliZXIiLCJGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsIlByaW1pdGl2ZSIsInNwbGl0IiwiZGVlcENvcHkiLCJ2YWx1ZSIsImluZGV4T2YiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJrZXkiLCJFcnJvciIsInN0YWxsIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRMb3dlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImlzUG9sbGFibGUiLCJwb2xsaW5nSW50ZXJ2YWwiLCJkZWZhdWx0T3B0aW9ucyIsInBvbGxpbmciLCJzdGF0aWNOZXR3b3JrIiwiYmF0Y2hTdGFsbFRpbWUiLCJiYXRjaE1heFNpemUiLCJiYXRjaE1heENvdW50IiwiY2FjaGVUaW1lb3V0IiwiSnNvblJwY1NpZ25lciIsImNvbnN0cnVjdG9yIiwicHJvdmlkZXIiLCJhZGRyZXNzIiwiY29ubmVjdCIsIm9wZXJhdGlvbiIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJ0eCIsInBvcHVsYXRlQ2FsbCIsInNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbiIsIl90eCIsInByb21pc2VzIiwiZnJvbSIsIl9mcm9tIiwicHVzaCIsImdhc0xpbWl0IiwiZXN0aW1hdGVHYXMiLCJ0byIsIl90byIsImxlbmd0aCIsImFsbCIsImhleFR4IiwiZ2V0UnBjVHJhbnNhY3Rpb24iLCJzZW5kIiwic2VuZFRyYW5zYWN0aW9uIiwiYmxvY2tOdW1iZXIiLCJnZXRCbG9ja051bWJlciIsImhhc2giLCJyZWplY3QiLCJ0aW1lb3V0cyIsImludmFsaWRzIiwiY2hlY2tUeCIsImdldFRyYW5zYWN0aW9uIiwicmVwbGFjZWFibGVUcmFuc2FjdGlvbiIsImVycm9yIiwiaW5mbyIsInNlbmRUcmFuc2FjdGlvbkhhc2giLCJlbWl0IiwiX3NldFRpbWVvdXQiLCJwb3AiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduTWVzc2FnZSIsIl9tZXNzYWdlIiwibWVzc2FnZSIsInNpZ25UeXBlZERhdGEiLCJkb21haW4iLCJ0eXBlcyIsIl92YWx1ZSIsInBvcHVsYXRlZCIsInJlc29sdmVOYW1lcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRQYXlsb2FkIiwidW5sb2NrIiwicGFzc3dvcmQiLCJfbGVnYWN5U2lnbk1lc3NhZ2UiLCJKc29uUnBjQXBpUHJvdmlkZXIiLCJvcHRpb25zIiwibmV4dElkIiwicGF5bG9hZHMiLCJkcmFpblRpbWVyIiwibm90UmVhZHkiLCJuZXR3b3JrIiwicGVuZGluZ0RldGVjdE5ldHdvcmsiLCJzY2hlZHVsZURyYWluIiwic3RhbGxUaW1lIiwiX2dldE9wdGlvbiIsImJhdGNoIiwic2hpZnQiLCJieXRlcyIsInAiLCJwYXlsb2FkIiwidW5zaGlmdCIsImFjdGlvbiIsInJlc3VsdCIsIl9zZW5kIiwiZGVzdHJveWVkIiwibWV0aG9kIiwicmVzcCIsImZpbHRlciIsInIiLCJpZCIsImdldFJwY0Vycm9yIiwiYXNzaWduIiwicHJvbWlzZSIsIl9yZXNvbHZlIiwibWF0Y2hlcyIsIl9uZXR3b3JrIiwiX3BlcmZvcm0iLCJyZXEiLCJ0cmFuc2FjdGlvbiIsInR5cGUiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImZlZURhdGEiLCJnZXRGZWVEYXRhIiwidW5kZWZpbmVkIiwicmVxdWVzdCIsImdldFJwY1JlcXVlc3QiLCJhcmdzIiwiX2RldGVjdE5ldHdvcmsiLCJyZWFkeSIsInBhcmFtcyIsImpzb25ycGMiLCJfc3RhcnQiLCJjb25zb2xlIiwibG9nIiwiZXZlbnQiLCJfd2FpdFVudGlsUmVhZHkiLCJfZ2V0U3Vic2NyaWJlciIsInN1YiIsIm9ycGhhbiIsImZvckVhY2giLCJkc3RLZXkiLCJhY2Nlc3NMaXN0IiwiYmxvYlZlcnNpb25lZEhhc2hlcyIsImgiLCJhdXRob3JpemF0aW9uTGlzdCIsIl9hIiwiYSIsIm5vbmNlIiwiY2hhaW5JZCIsInlQYXJpdHkiLCJzaWduYXR1cmUiLCJzIiwiYmxvY2tUYWciLCJwb3NpdGlvbiIsInRvU3RyaW5nIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwiYmxvY2tIYXNoIiwiX2Vycm9yIiwibXNnIiwibWF0Y2giLCJzcGVsdW5rRGF0YSIsImUiLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImRhdGEiLCJzcGVsdW5rTWVzc2FnZSIsImFjdGlvbk1hcCIsImV0aF9zaWduIiwicGVyc29uYWxfc2lnbiIsImV0aF9zaWduVHlwZWREYXRhX3Y0IiwiZXRoX3NpZ25UcmFuc2FjdGlvbiIsImV0aF9zZW5kVHJhbnNhY3Rpb24iLCJldGhfcmVxdWVzdEFjY291bnRzIiwid2FsbGV0X3JlcXVlc3RBY2NvdW50cyIsInJlYXNvbiIsInVuc3VwcG9ydGVkIiwiZGV0YWlscyIsInN0YXJ0c1dpdGgiLCJnZXRTaWduZXIiLCJhY2NvdW50c1Byb21pc2UiLCJhY2NvdW50cyIsImdldE5ldHdvcmsiLCJhY2NvdW50IiwibGlzdEFjY291bnRzIiwiZGVzdHJveSIsImNsZWFyVGltZW91dCIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJzdWJzY3JpYmVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiX2ZvckVhY2hTdWJzY3JpYmVyIiwiSnNvblJwY1Byb3ZpZGVyIiwidXJsIiwiY2xvbmUiLCJfZ2V0Q29ubmVjdGlvbiIsImJvZHkiLCJzZXRIZWFkZXIiLCJyZXNwb25zZSIsImFzc2VydE9rIiwiYm9keUpzb24iLCJwYXJzZSIsIl9zcGVsdW5rTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (req.authorizationList) {\n        result.authorizationList = req.authorizationList.slice();\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b)=>{\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(b)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        this.#transactions = block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */ get transactions() {\n        return this.#transactions.map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash,\n            miner,\n            prevRandao,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            parentBeaconBlockRoot,\n            stateRoot,\n            receiptsRoot,\n            transactions\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return this.#transactions.length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    #logs;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.#logs = Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return this.#logs;\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    #startBlock;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;\n        this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList,\n            blockNumber,\n            blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (confirms === 1 || await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQTBEO0FBQ3NHO0FBQ3hHO0FBQ3hELE1BQU1XLE9BQU9DLE9BQU87QUFDcEIsMEJBQTBCO0FBQzFCLFNBQVNDLFNBQVNDLEtBQUs7SUFDbkIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNDLE9BQU9ELEtBQUs7SUFDakIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTUUsUUFBUTtBQUN6QjtBQUNBLDBEQUEwRDtBQUMxRDs7O0NBR0MsR0FDTSxNQUFNQztJQTRCVDs7O0tBR0MsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixDQUFFO1FBQ3REckIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQm1CLFVBQVVOLFNBQVNNO1lBQ25CQyxjQUFjUCxTQUFTTztZQUN2QkMsc0JBQXNCUixTQUFTUTtRQUNuQztJQUNKO0lBQ0E7O0tBRUMsR0FDREMsU0FBUztRQUNMLE1BQU0sRUFBRUgsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUcsSUFBSTtRQUM3RCxPQUFPO1lBQ0hFLE9BQU87WUFDUEosVUFBVUosT0FBT0k7WUFDakJDLGNBQWNMLE9BQU9LO1lBQ3JCQyxzQkFBc0JOLE9BQU9NO1FBQ2pDO0lBQ0o7QUFDSjs7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRyxZQUFZQyxHQUFHO0lBQzNCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixzREFBc0Q7SUFDdEQsSUFBSUQsSUFBSUUsRUFBRSxFQUFFO1FBQ1JELE9BQU9DLEVBQUUsR0FBR0YsSUFBSUUsRUFBRTtJQUN0QjtJQUNBLElBQUlGLElBQUlHLElBQUksRUFBRTtRQUNWRixPQUFPRSxJQUFJLEdBQUdILElBQUlHLElB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QzVCRSxTQUFTUCxJQUFJTyxPQUFPO1lBQ3BCdkUsTUFBTWdFLElBQUloRSxJQUFJO1lBQ2RpRSxRQUFRakQsT0FBT2tELE1BQU0sQ0FBQ0YsSUFBSUMsTUFBTSxDQUFDMUQsS0FBSztZQUN0Q3dDLE9BQU9pQixJQUFJakIsS0FBSztRQUNwQjtJQUFFO0FBQ1YsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzPzY4YTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNCeXRlc0xpa2UsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9Kc29uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLy8gQFRPRE8/IDxUIGV4dGVuZHMgRmVlRGF0YSA9IHsgfT4gaW1wbGVtZW50cyBSZXF1aXJlZDxUPlxuLyoqXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcbiAqICB0aGUgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGEge1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlIGZvciBsZWdhY3kgbmV0d29ya3MuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyBpcyBkZWZpbmVkIGJ5IHRoZSBuZXR3b3JrIGFuZCBiYXNlZCBvblxuICAgICAqICBjb25nZXN0aW9uLCBpbmNyZWFzaW5nIHRoZSBjb3N0IGR1cmluZyB0aW1lcyBvZiBoZWF2eSBsb2FkXG4gICAgICogIGFuZCBsb3dlcmluZyB3aGVuIGxlc3MgYnVzeS5cbiAgICAgKlxuICAgICAqICBUaGUgYWN0dWFsIGZlZSBwZXIgZ2FzIHdpbGwgYmUgdGhlIGJhc2UgZmVlIGZvciB0aGUgYmxvY2tcbiAgICAgKiAgYW5kIHRoZSBwcmlvcml0eSBmZWUsIHVwIHRvIHRoZSBtYXggZmVlIHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRpdGlvbmFsIGFtb3V0IHRvIHBheSBwZXIgZ2FzIHRvIGVuY291cmFnZSBhIHZhbGlkYXRvclxuICAgICAqICB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGUgcHVycG9zZSBvZiB0aGlzIGlzIHRvIGNvbXBlbnNhdGUgdGhlIHZhbGlkYXRvciBmb3IgdGhlXG4gICAgICogIGFkanVzdGVkIHJpc2sgZm9yIGluY2x1ZGluZyBhIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgRmVlRGF0YSBmb3IgJSVnYXNQcmljZSUlLCAlJW1heEZlZVBlckdhcyUlIGFuZFxuICAgICAqICAlJW1heFByaW9yaXR5RmVlUGVyR2FzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBnYXNQcmljZTogZ2V0VmFsdWUoZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24oZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24obWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxuICogIHR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLy8gVGhlc2UgY291bGQgYmUgYWRkcmVzc2VzLCBFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzXG4gICAgaWYgKHJlcS50bykge1xuICAgICAgICByZXN1bHQudG8gPSByZXEudG87XG4gICAgfVxuICAgIGlmIChyZXEuZnJvbSkge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHJlcS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBoZXhsaWZ5KHJlcS5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJCbG9iR2FzLG1heEZlZVBlckdhcyxtYXhQcmlvcml0eUZlZVBlckdhcyx2YWx1ZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYmlnSW50S2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldEJpZ0ludChyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlcktleXMgPSBcInR5cGUsbm9uY2VcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG51bWJlcktleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROdW1iZXIocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAocmVxLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJlcS5hY2Nlc3NMaXN0KTtcbiAgICB9XG4gICAgaWYgKHJlcS5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSByZXEuYXV0aG9yaXphdGlvbkxpc3Quc2xpY2UoKTtcbiAgICB9XG4gICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrVGFnID0gcmVxLmJsb2NrVGFnO1xuICAgIH1cbiAgICBpZiAoXCJlbmFibGVDY2lwUmVhZFwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuZW5hYmxlQ2NpcFJlYWQgPSAhIXJlcS5lbmFibGVDY2lwUmVhZDtcbiAgICB9XG4gICAgaWYgKFwiY3VzdG9tRGF0YVwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuY3VzdG9tRGF0YSA9IHJlcS5jdXN0b21EYXRhO1xuICAgIH1cbiAgICBpZiAoXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIgaW4gcmVxICYmIHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMuc2xpY2UoKTtcbiAgICB9XG4gICAgaWYgKFwia3pnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5remcgPSByZXEua3pnO1xuICAgIH1cbiAgICBpZiAoXCJibG9ic1wiIGluIHJlcSAmJiByZXEuYmxvYnMpIHtcbiAgICAgICAgcmVzdWx0LmJsb2JzID0gcmVxLmJsb2JzLm1hcCgoYikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgQSAqKkJsb2NrKiogcmVwcmVzZW50cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBmdWxsIGJsb2NrIG9uXG4gKiAgRXRoZXJldW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9jayB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciwgc29tZXRpbWVzIGNhbGxlZCB0aGUgYmxvY2sgaGVpZ2h0LiBUaGlzIGlzIGFcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBudW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoLlxuICAgICAqXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XG4gICAgICogIGFuIGV4YWN0IHNldCBvZiBibG9jayBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSB0aW1lc3RhbXAgZm9yIHRoaXMgYmxvY2ssIHdoaWNoIGlzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZVxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIHRpbWVzdGFtcDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBwYXJlbnRIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaGFzaCB0cmVlIHJvb3Qgb2YgdGhlIHBhcmVudCBiZWFjb24gYmxvY2sgZm9yIHRoZSBnaXZlblxuICAgICAqICBleGVjdXRpb24gYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ3ODhdXS5cbiAgICAgKi9cbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcbiAgICAgKiAgcGVybWl0dGVkIHRoZSBkaWZmaWN1bHR5IHRhcmdldCB0byBiZSByZWFjaGVkLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGlmZmljdWx0eSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSBwcm9vZi1vZi13b3JrIHRhcmdldCByZXF1aXJlZFxuICAgICAqICBmb3IgYSBibG9jayB0byBtZWV0IHRoZSBwcm90b2NvbCBydWxlcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBPbiBtb2Rlcm4gbmV0d29ya3MsIHRoaXMgaXMgYSByYW5kb20gbnVtYmVyIGFycml2ZWQgYXQgdXNpbmdcbiAgICAgKiAgcmFuZGFvLiAgQFRPRE86IEZpbmQgbGlua3M/XG4gICAgICovXG4gICAgZGlmZmljdWx0eTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyB1c2VkIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJvb3QgaGFzaCBmb3IgdGhlIGdsb2JhbCBzdGF0ZSBhZnRlciBhcHBseWluZyBjaGFuZ2VzXG4gICAgICogIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgc3RhdGVSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdHMgdHJpZS5cbiAgICAgKi9cbiAgICByZWNlaXB0c1Jvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBhbW91bnQgb2YgYmxvYiBnYXMgY29uc3VtZWQgYnkgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB3aXRoaW4gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgYmxvYkdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBydW5uaW5nIHRvdGFsIG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGluIGV4Y2VzcyBvZiB0aGVcbiAgICAgKiAgdGFyZ2V0LCBwcmlvciB0byB0aGUgYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBleGNlc3NCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWluZXIgY29pbmJhc2UgYWRkcmVzcywgd2loY2ggcmVjZWl2ZXMgYW55IHN1YnNpZGllcyBmb3JcbiAgICAgKiAgaW5jbHVkaW5nIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgbWluZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBsYXRlc3QgUkFOREFPIG1peCBvZiB0aGUgcG9zdCBiZWFjb24gc3RhdGUgb2ZcbiAgICAgKiAgdGhlIHByZXZpb3VzIGJsb2NrLlxuICAgICAqL1xuICAgIHByZXZSYW5kYW87XG4gICAgLyoqXG4gICAgICogIEFueSBleHRyYSBkYXRhIHRoZSB2YWxpZGF0b3Igd2lzaGVkIHRvIGluY2x1ZGUuXG4gICAgICovXG4gICAgZXh0cmFEYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyB0aGF0IGFsbCB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jayB3ZXJlXG4gICAgICogIGNoYXJnZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBhZGp1c3RzIGFmdGVyIGVhY2ggYmxvY2ssIGRlcGVuZGluZyBvbiBob3cgY29uZ2VzdGVkIHRoZSBuZXR3b3JrXG4gICAgICogIGlzLlxuICAgICAqL1xuICAgIGJhc2VGZWVQZXJHYXM7XG4gICAgI3RyYW5zYWN0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQmxvY2sqKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSBuZWNlc3NhcnkgYXMgdGhlIHVubGVzcyBpbXBsZW1lbnRpbmcgYVxuICAgICAqICBsb3ctbGV2ZWwgbGlicmFyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihibG9jaywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jdHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIGhhc2g6IGdldFZhbHVlKGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgbnVtYmVyOiBibG9jay5udW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGJsb2NrLnBhcmVudEJlYWNvbkJsb2NrUm9vdCxcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGJsb2NrLmRpZmZpY3VsdHksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmxvY2suZ2FzTGltaXQsXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IGJsb2NrLmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogYmxvY2suZXhjZXNzQmxvYkdhcyxcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgICAgIHByZXZSYW5kYW86IGdldFZhbHVlKGJsb2NrLnByZXZSYW5kYW8pLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBibG9jay5leHRyYURhdGEsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHN0YXRlUm9vdDogYmxvY2suc3RhdGVSb290LFxuICAgICAgICAgICAgcmVjZWlwdHNSb290OiBibG9jay5yZWNlaXB0c1Jvb3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgcGFyZW50QmVhY29uQmxvY2tSb290LCBzdGF0ZVJvb3QsIHJlY2VpcHRzUm9vdCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogdG9Kc29uKHRoaXMuZXhjZXNzQmxvYkdhcyksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290LCBzdGF0ZVJvb3QsIHJlY2VpcHRzUm9vdCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMudHJhbnNhY3Rpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHhzW2luZGV4KytdLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstanMtZGF0ZV1dIHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkIGF0LlxuICAgICAqL1xuICAgIGdldCBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIHRyYW5zYWN0aW9uIGF0ICUlaW5kZXhlJSUgd2l0aGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgaW50ZXJuYWwgdmFsdWUgYnkgaXRzIGluZGV4IG9yIGhhc2hcbiAgICAgICAgbGV0IHR4ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHR4ID0gdGhpcy4jdHJhbnNhY3Rpb25zW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuI3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggdHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSAqKkJsb2NrKiogd2FzIGZldGNoZWQgd2l0aCBhIHJlcXVlc3QgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICogIHRoaXMgd2lsbCBhbGxvdyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gdGhvc2UgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIElmIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldFByZWZldGNoZWRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnByZWZldGNoZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4c1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhPckhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHR4cykge1xuICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IGluZGV4T3JIYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcbiAgICAgKiAgZm9yIGFsbCBwcm9wZXJ0aWVzIG9uIGEgW1tNaW5lZEJsb2NrXV0uXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIGFuIFtbbGluay1laXAtMjkzMF1dIGJsb2NrLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmJhc2VGZWVQZXJHYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBvcnBoYW5lZEV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNaW5lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTG9nXG4vKipcbiAqICBBICoqTG9nKiogaW4gRXRoZXJldW0gcmVwcmVzZW50cyBhbiBldmVudCB0aGF0IGhhcyBiZWVuIGluY2x1ZGVkIGluIGFcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxuICogIFNvbGlkaXR5J3MgZW1pdCBmb3IgYW5ub3VuY2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0VHJhbnNhY3Rpb25dXSB0byBnZXQgdGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldEJsb2NrXV0gdG8gZ2V0IHRoZSBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gSXQgaXMgcHJlZmVycmVkXG4gICAgICogIHRvIHVzZSB0aGUgW1tCbG9jay1oYXNoXV0gd2hlbiBmZXRjaGluZyB0aGUgcmVsYXRlZCBbW0Jsb2NrXV0sXG4gICAgICogIHNpbmNlIGluIHRoZSBjYXNlIG9mIGFuIG9ycGhhbmVkIGJsb2NrLCB0aGUgYmxvY2sgYXQgdGhhdCBoZWlnaHQgbWF5XG4gICAgICogIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlICoqTG9nKiogcmVwcmVzZW50cyBhIGJsb2NrIHRoYXQgd2FzIHJlbW92ZWQgZHVlIHRvIGFuIG9ycGhhbmVkXG4gICAgICogIGJsb2NrLCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoaW4gYW4gb3JwaGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHJlbW92ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGF0IGVtaXR0ZWQgdGhpcyBsb2cuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXhlZCB0b3BpY3MgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqICBBbGwgdG9waWNzIGFyZSBpbmNsdWRlZCBpbiB0aGUgYmxvb20gZmlsdGVycywgc28gdGhleSBjYW4gYmVcbiAgICAgKiAgZWZmaWNpZW50bHkgZmlsdGVyZWQgdXNpbmcgdGhlIFtbUHJvdmlkZXItZ2V0TG9nc11dIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0b3BpY3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGF0LiBUaGlzIGlzIGdlbmVyYWxseVxuICAgICAqICBub3QgdXNlZnVsIHRvIGRldmVsb3BlcnMsIGJ1dCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB2YXJpb3VzIHJvb3RzXG4gICAgICogIHRvIHByb29mIGluY2x1c2lvbiB3aXRoaW4gYSBibG9jay5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gb2YgdGhpcyBsb2cuXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25JbmRleDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogbG9nLnJlbW92ZWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCwgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgIGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGJsb2NrIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgIGFzc2VydCghIWJsb2NrLCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXR4LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm90IHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXNcbiAgICAgKiAgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhcmVjZWlwdCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvbiByZWNlaXB0XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUcmFuc2FjdGlvbiBSZWNlaXB0XG4vKlxuZXhwb3J0IGludGVyZmFjZSBMZWdhY3lUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogZmFsc2U7XG4gICAgc3RhdHVzOiBudWxsO1xuICAgIHJvb3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCeXphbnRpdW1UcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogdHJ1ZTtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICByb290OiBudWxsO1xufVxuKi9cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGFcbiAqICB0cmFuc2FjdGlvbiB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGl0IGhhcyBiZWVuIG1pbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxuICAgICAqICByZXNwb25zaWJsZSBmb3IgZGVwbG95aW5nIG9uZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIGFzIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGNvbnRyYWN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgbW9zdCBkZXZlbG9wZXJzLFxuICAgICAqICBidXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGluY2x1ZGVkIGxvZ3MuXG4gICAgICovXG4gICAgbG9nc0Jsb29tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiwgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3aWxsIGJlIHVzZWQgY2FuXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXG4gICAgICogIGVudGlyZSBnYXMgbGltaXQuIEFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgdGhlIGRpZmZlcmVuY2UgaXMgcmVmdW5kZWQuXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyB1c2VkIGZvciBCTE9icy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmljZSBwYWlkIHBlciBCTE9CIGluIGdhcy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvL3JlYWRvbmx5IGJ5emFudGl1bSE6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0dXMgb2YgdGhpcyB0cmFuc2FjdGlvbiwgaW5kaWNhdGluZyBzdWNjZXNzIChpLmUuIGBgMWBgKSBvclxuICAgICAqICBhIHJldmVydCAoaS5lLiBgYDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBhdmFpbGFibGUgaW4gcG9zdC1ieXphbnRpdW0gYmxvY2tzLCBidXQgc29tZSBiYWNrZW5kcyBtYXlcbiAgICAgKiAgYmFja2ZpbGwgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0dXM7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vIHByZXNlbnQgYW5kIHdhcyBvbmx5IGluY2x1ZGVkIGluIHByZS1ieXphbnRpdW0gYmxvY2tzLCBidXRcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgI2xvZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNsb2dzID0gT2JqZWN0LmZyZWV6ZSh0eC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZ2FzUHJpY2UgPSBCTl8wO1xuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5lZmZlY3RpdmVHYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0eC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgaW5kZXg6IHR4LmluZGV4LFxuICAgICAgICAgICAgYmxvY2tIYXNoOiB0eC5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogdHguYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IHR4LmxvZ3NCbG9vbSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHR4Lmdhc1VzZWQsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdHguY3VtdWxhdGl2ZUdhc1VzZWQsXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdHguYmxvYkdhc1VzZWQsXG4gICAgICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdHguYmxvYkdhc1ByaWNlLFxuICAgICAgICAgICAgdHlwZTogdHgudHlwZSxcbiAgICAgICAgICAgIC8vYnl6YW50aXVtOiB0eC5ieXphbnRpdW0sXG4gICAgICAgICAgICBzdGF0dXM6IHR4LnN0YXR1cyxcbiAgICAgICAgICAgIHJvb3Q6IHR4LnJvb3RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbG9ncyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHsgcmV0dXJuIHRoaXMuI2xvZ3M7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGNvbnRyYWN0QWRkcmVzcywgaGFzaCwgaW5kZXgsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGxvZ3NCbG9vbSwgbG9ncywgLy9ieXphbnRpdW0sIFxuICAgICAgICBzdGF0dXMsIHJvb3QgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAvL2J5emFudGl1bSwgXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdG9Kc29uKHRoaXMuY3VtdWxhdGl2ZUdhc1VzZWQpLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1ByaWNlOiB0b0pzb24odGhpcy5ibG9iR2FzUHJpY2UpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKHRoaXMuZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBpbmRleCwgbG9ncywgbG9nc0Jsb29tLCByb290LCBzdGF0dXMsIHRvXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5sb2dzLmxlbmd0aDsgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmxvZ3NbaW5kZXgrK10sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBmZWUgZm9yIHRoaXMgdHJhbnNhY3Rpb24sIGluIHdlaS5cbiAgICAgKi9cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXNVc2VkICogdGhpcy5nYXNQcmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBibG9jayB0aGlzIHRyYW5zYWN0aW9uIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFN1cHBvcnQgZm9yIHRoaXMgZmVhdHVyZSBpcyBsaW1pdGVkLCBhcyBpdCByZXF1aXJlcyBhbiBhcmNoaXZlIG5vZGVcbiAgICAgKiAgd2l0aCB0aGUgYGBkZWJ1Z19gYCBvciBgYHRyYWNlX2BgIEFQSSBlbmFibGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHRoaXMuaGFzaCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpKSAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zY3Rpb24gY2Fubm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlb3JkZXJlZEV2ZW50KG90aGVyKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlc3BvbnNlKiogaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMgYWJvdXQgYSB0cmFuc2FjdGlvblxuICogIHRoYXQgd2FzIHNlbnQgdG8gdGhlIG5ldHdvcmssIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGluY2x1ZGVkIGluIGFcbiAqICBibG9jay5cbiAqXG4gKiAgVGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZS1pc01pbmVkXV0gY2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlXG4gKiAgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYXMgd2VsbCBhcyB0eXBlIGd1YXJkIHRoYXQgdGhlIG90aGVyd2lzZVxuICogIHBvc3NpYmx5IGBgbnVsbGBgIHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXG4gICAgICogIG1ldGhvZHMgd2lsbCByZXNvbHZlIGl0cyBhc3luYyBpbnNwZWN0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9ja0hhc2ggb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gcmVzaWRlcyBhdC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGUuIFRoaXMgaXNcbiAgICAgKiAgYGAwYGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgdHlwZXMuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgSWYgYGBudWxsYGAsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGluaXRjb2RlIHRyYW5zYWN0aW9uLlxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXG4gICAgICogIGFzIGEgbmV3IGNvbnRyYWN0IG9uIGNoYWluIChhc3N1bWluZyBpdCBkb2VzIG5vdCByZXZlcnQpIGFuZCB0aGVcbiAgICAgKiAgYWRkcmVzcyBtYXkgYmUgY29tcHV0ZWQgdXNpbmcgW1tnZXRDcmVhdGVBZGRyZXNzXV0uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxuICAgICAqICBmcm9tIHRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UgaGFzaCAoYXMgdGhlIGRpZ2VzdCkgYW5kIHRoZVxuICAgICAqICBbW3NpZ25hdHVyZV1dIHVzaW5nIGVjcmVjb3Zlci5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcbiAgICAgKiAgYSBtZXRob2QgdG8gZW5zdXJlIHRyYW5zYWN0aW9ucyBmcm9tIGEgZ2l2ZW4gc2VuZGVyIGFyZSBleHBsaWNpdGx5XG4gICAgICogIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZW5kaW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgbXVzdCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICogIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgYnkgW1tmcm9tXV0uXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cbiAgICAgKiAgZXhjZWVkcyB0aGlzLCB0aGUgZW50cmllcyB0cmFuc2FjdGlvbiBpcyByZXZlcnRlZCBhbmQgdGhlIHNlbmRlclxuICAgICAqICBpcyBjaGFyZ2VkIGZvciB0aGUgZnVsbCBhbW91bnQsIGRlc3BpdGUgbm90IHN0YXRlIGNoYW5nZXMgYmVpbmcgbWFkZS5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogIEluIG1vZGVybiBuZXR3b3JrcywgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbmNsdWRlZCB0aGlzIGlzXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XG4gICAgICogIGNoYXJnZWQpLCB3aGlsZSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSBub3QgYmVlbiBpbmNsdWRlZCB5ZXRcbiAgICAgKiAgaXMgdGhlIFtbbWF4RmVlUGVyR2FzXV0uXG4gICAgICpcbiAgICAgKiAgRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIG9yIHRyYW5zYWN0aW9ucyBvbiBsZWdhY3kgbmV0d29ya3MsIHRoaXNcbiAgICAgKiAgaXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgY2hhcmdlZCBwZXIgdW5pdCBvZiBnYXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogIGNvbnN1bWVzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgYVxuICAgICAqICB2YWxpZGF0b3IgdG8gY2hhcmdlIHRoZSBzZW5kZXIuIFRoaXMgaXMgaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgdGhpcyB0cmFuc2FjdGlvblxuICAgICAqICB0byBjaGFyZ2UgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBCTE9iIHZlcnNpb25lZCBoYXNoZXMuXG4gICAgICovXG4gICAgYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb25zIChpZiBhbnkpLlxuICAgICAqL1xuICAgIGF1dGhvcml6YXRpb25MaXN0O1xuICAgICNzdGFydEJsb2NrO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmJsb2NrTnVtYmVyID0gKHR4LmJsb2NrTnVtYmVyICE9IG51bGwpID8gdHguYmxvY2tOdW1iZXIgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrSGFzaCA9ICh0eC5ibG9ja0hhc2ggIT0gbnVsbCkgPyB0eC5ibG9ja0hhc2ggOiBudWxsO1xuICAgICAgICB0aGlzLmhhc2ggPSB0eC5oYXNoO1xuICAgICAgICB0aGlzLmluZGV4ID0gdHguaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IHR4LmZyb207XG4gICAgICAgIHRoaXMudG8gPSB0eC50byB8fCBudWxsO1xuICAgICAgICB0aGlzLmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIHRoaXMubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgdGhpcy5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB0aGlzLmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyR2FzID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyQmxvYkdhcyA9ICh0eC5tYXhGZWVQZXJCbG9iR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyQmxvYkdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gdHguc2lnbmF0dXJlO1xuICAgICAgICB0aGlzLmFjY2Vzc0xpc3QgPSAodHguYWNjZXNzTGlzdCAhPSBudWxsKSA/IHR4LmFjY2Vzc0xpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2JWZXJzaW9uZWRIYXNoZXMgPSAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSA/IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgOiBudWxsO1xuICAgICAgICB0aGlzLmF1dGhvcml6YXRpb25MaXN0ID0gKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpID8gdHguYXV0aG9yaXphdGlvbkxpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLiNzdGFydEJsb2NrID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsIGluZGV4LCBoYXNoLCB0eXBlLCB0bywgZnJvbSwgbm9uY2UsIGRhdGEsIHNpZ25hdHVyZSwgYWNjZXNzTGlzdCwgYmxvYlZlcnNpb25lZEhhc2hlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVzcG9uc2VcIixcbiAgICAgICAgICAgIGFjY2Vzc0xpc3QsIGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICAgICAgICAgICAgY2hhaW5JZDogdG9Kc29uKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBkYXRhLCBmcm9tLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckJsb2JHYXM6IHRvSnNvbih0aGlzLm1heEZlZVBlckJsb2JHYXMpLFxuICAgICAgICAgICAgbm9uY2UsIHNpZ25hdHVyZSwgdG8sIGluZGV4LCB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHRvSnNvbih0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBCbG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIHlldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gdGhpcy5ibG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2FjdGlvbiBiZWluZyByZS1yZXF1ZXN0ZWQgZnJvbSB0aGVcbiAgICAgKiAgcHJvdmlkZXIuIFRoaXMgY2FuIGJlIHVzZWQgaWYgeW91IGhhdmUgYW4gdW5taW5lZCB0cmFuc2FjdGlvblxuICAgICAqICBhbmQgd2lzaCB0byBnZXQgYW4gdXAtdG8tZGF0ZSBwb3B1bGF0ZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR4LCBibG9ja051bWJlciB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHR4OiB0aGlzLmdldFRyYW5zYWN0aW9uKCksXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOb3QgbWluZWQgeWV0Li4uXG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCB8fCB0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFuZCBoYXNcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcbiAgICAgKiAgd2FpdCB1bnRpbCBlbm91Z2ggY29uZmlybWF0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KF9jb25maXJtcywgX3RpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zID09IG51bGwpID8gMSA6IF9jb25maXJtcztcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChfdGltZW91dCA9PSBudWxsKSA/IDAgOiBfdGltZW91dDtcbiAgICAgICAgbGV0IHN0YXJ0QmxvY2sgPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICBsZXQgbmV4dFNjYW4gPSAtMTtcbiAgICAgICAgbGV0IHN0b3BTY2FubmluZyA9IChzdGFydEJsb2NrID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNoZWNrUmVwbGFjZW1lbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgZm9yIHRoaXMgc2VuZGVyXG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBub25jZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmZyb20pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zYWN0aW9uIG9yIG91ciBub25jZSBoYXMgbm90IGJlZW4gbWluZWQgeWV0OyBidXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdGFydCBzY2FubmluZyBsYXRlciB3aGVuIHdlIGRvIHN0YXJ0XG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5lZCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHRvIHNjYW47IGxvb2sgYmFjayBhIGZldyBleHRyYSBibG9ja3MgZm9yIHNhZmV0eVxuICAgICAgICAgICAgaWYgKG5leHRTY2FuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTY2FuIDwgdGhpcy4jc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5leHRTY2FuIDw9IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobmV4dFNjYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2ggPT09IHRoaXMuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYmxvY2suZ2V0VHJhbnNhY3Rpb24oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4Lmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCByZXRyeSB0aGlzIG9uIHRoZSBuZXh0IGJsb2NrICh0aGlzIGNhc2UgY291bGQgYmUgb3B0aW1pemVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxKSA8IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHRoaXMuZGF0YSAmJiB0eC50byA9PT0gdGhpcy50byAmJiB0eC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hlY2tSZWNlaXB0ID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgfHwgcmVjZWlwdC5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiBleGVjdXRpb24gcmV2ZXJ0ZWRcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsIHJlYXNvbjogbnVsbCwgaW52b2NhdGlvbjogbnVsbCwgcmV2ZXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiByZWNlaXB0LnRvLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiByZWNlaXB0LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIgLy8gQFRPRE86IGluIHY3LCBzcGxpdCBvdXQgc2VuZFRyYW5zYWN0aW9uIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICB9LCByZWNlaXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaGFzaCk7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjZWlwdCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAxIHx8IChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRocm93cyBpZiBhIHJlcGxhY2VtZW50IHdhcyBmb3VuZFxuICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xuICAgICAgICAgICAgLy8gQWxsb3cgbnVsbCBvbmx5IHdoZW4gdGhlIGNvbmZpcm1zIGlzIDBcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhaXRlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIExpc3Qgb2YgdGhpbmdzIHRvIGNhbmNlbCB3aGVuIHdlIGhhdmUgYSByZXN1bHQgKG9uZSB3YXkgb3IgdGhlIG90aGVyKVxuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4geyBjYW5jZWxsZXJzLmZvckVhY2goKGMpID0+IGMoKSk7IH07XG4gICAgICAgICAgICAvLyBPbiBjYW5jZWwsIHN0b3Agc2Nhbm5pbmcgZm9yIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgc3RvcFNjYW5uaW5nID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYW55IHRpbWVvdXQgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcIndhaXQgZm9yIHRyYW5zYWN0aW9uIHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4TGlzdGVuZXIgPSBhc3luYyAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcbiAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2hlY2tSZWNlaXB0KHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYodGhpcy5oYXNoLCB0eExpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0IHJlcGxhY2VtZW50IGRldGVjdGlvbjsgc3RhcnQgY2hlY2tpbmdcbiAgICAgICAgICAgIGlmIChzdGFydEJsb2NrID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhpcyB0aHJvd3Mgb25seSBpZiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2NoZXVkbGUgYSBjaGVjayBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHdhaXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGVmZmVjdGl2ZSBvbmx5IGFzIG9mIHRoZSB0aW1lIHRoZSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgICogIHdhcyBpbnN0YW50aWF0ZWQuIFRvIGdldCB1cC10by1kYXRlIGluZm9ybWF0aW9uLCB1c2VcbiAgICAgKiAgW1tnZXRUcmFuc2FjdGlvbl1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgbm9uLW51bGwgcHJvcGVydHkgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYXJlIG51bGwgZm9yXG4gICAgICogIHVubWluZWQgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ibG9ja0hhc2ggIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IChpLmUuIGBgdHlwZSA9PSAwYGApXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIEJlcmxpbiAoaS5lLiBgYHR5cGUgPT0gMWBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMjA3MF1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIExvbmRvbiAoaS5lLiBgYHR5cGUgPT0gMmBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMTU1OV1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGh0ZSB0cmFuc2FjdGlvbiBpcyBhIENhbmN1biAoaS5lLiBgYHR5cGUgPT0gM2BgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGlzQ2FuY3VuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IGV2aWN0IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IHJlLW9yZGVyIHRoaXMgZXZlbnQgYWdhaW5zdCAlJW90aGVyJSUuXG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICBhc3NlcnQoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgYWJpbGl0eSB0b1xuICAgICAqICBkZXRlY3QgKGFuZCB0aHJvdyBhbiBlcnJvcikgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHJlcGxhY2VkLCB3aGljaFxuICAgICAqICB3aWxsIGJlZ2luIHNjYW5uaW5nIGF0ICUlc3RhcnRCbG9jayUlLlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBieSBkZXZlbG9wZXJzIGFuZCBpcyBpbnRlbmRlZFxuICAgICAqICBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gU2V0dGluZyBhbiBpbmNvcnJlY3QgJSVzdGFydEJsb2NrJSUgY2FuXG4gICAgICogIGhhdmUgZGV2YXN0YXRpbmcgcGVyZm9ybWFuY2UgY29uc2VxdWVuY2VzIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICovXG4gICAgcmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhcnRCbG9jaykgJiYgc3RhcnRCbG9jayA+PSAwLCBcImludmFsaWQgc3RhcnRCbG9ja1wiLCBcInN0YXJ0QmxvY2tcIiwgc3RhcnRCbG9jayk7XG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIHR4LiNzdGFydEJsb2NrID0gc3RhcnRCbG9jaztcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJpc0J5dGVzTGlrZSIsInJlc29sdmVQcm9wZXJ0aWVzIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYWNjZXNzTGlzdGlmeSIsIkJOXzAiLCJCaWdJbnQiLCJnZXRWYWx1ZSIsInZhbHVlIiwidG9Kc29uIiwidG9TdHJpbmciLCJGZWVEYXRhIiwiY29uc3RydWN0b3IiLCJnYXNQcmljZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwidG9KU09OIiwiX3R5cGUiLCJjb3B5UmVxdWVzdCIsInJlcSIsInJlc3VsdCIsInRvIiwiZnJvbSIsImRhdGEiLCJiaWdJbnRLZXlzIiwic3BsaXQiLCJrZXkiLCJudW1iZXJLZXlzIiwiYWNjZXNzTGlzdCIsImF1dGhvcml6YXRpb25MaXN0Iiwic2xpY2UiLCJibG9ja1RhZyIsImVuYWJsZUNjaXBSZWFkIiwiY3VzdG9tRGF0YSIsImJsb2JWZXJzaW9uZWRIYXNoZXMiLCJremciLCJibG9icyIsIm1hcCIsImIiLCJPYmplY3QiLCJhc3NpZ24iLCJCbG9jayIsInRyYW5zYWN0aW9ucyIsImJsb2NrIiwicHJvdmlkZXIiLCJ0eCIsIlRyYW5zYWN0aW9uUmVzcG9uc2UiLCJoYXNoIiwibnVtYmVyIiwidGltZXN0YW1wIiwicGFyZW50SGFzaCIsInBhcmVudEJlYWNvbkJsb2NrUm9vdCIsIm5vbmNlIiwiZGlmZmljdWx0eSIsImdhc0xpbWl0IiwiZ2FzVXNlZCIsImJsb2JHYXNVc2VkIiwiZXhjZXNzQmxvYkdhcyIsIm1pbmVyIiwicHJldlJhbmRhbyIsImV4dHJhRGF0YSIsImJhc2VGZWVQZXJHYXMiLCJzdGF0ZVJvb3QiLCJyZWNlaXB0c1Jvb3QiLCJwcmVmZXRjaGVkVHJhbnNhY3Rpb25zIiwidHhzIiwibGVuZ3RoIiwib3BlcmF0aW9uIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpbmRleCIsIm5leHQiLCJkb25lIiwidW5kZWZpbmVkIiwiZGF0ZSIsIkRhdGUiLCJnZXRUcmFuc2FjdGlvbiIsImluZGV4T3JIYXNoIiwidG9Mb3dlckNhc2UiLCJ2IiwiRXJyb3IiLCJnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24iLCJpc01pbmVkIiwiaXNMb25kb24iLCJvcnBoYW5lZEV2ZW50IiwiY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlciIsIkxvZyIsImxvZyIsInRvcGljcyIsImZyZWV6ZSIsInRyYW5zYWN0aW9uSGFzaCIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwicmVtb3ZlZCIsImFkZHJlc3MiLCJ0cmFuc2FjdGlvbkluZGV4IiwiZ2V0QmxvY2siLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJyZWNlaXB0IiwicmVtb3ZlZEV2ZW50IiwiY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlciIsIlRyYW5zYWN0aW9uUmVjZWlwdCIsImxvZ3MiLCJlZmZlY3RpdmVHYXNQcmljZSIsImNvbnRyYWN0QWRkcmVzcyIsImxvZ3NCbG9vbSIsImN1bXVsYXRpdmVHYXNVc2VkIiwiYmxvYkdhc1ByaWNlIiwidHlwZSIsInN0YXR1cyIsInJvb3QiLCJmZWUiLCJnZXRSZXN1bHQiLCJnZXRUcmFuc2FjdGlvblJlc3VsdCIsImNvbmZpcm1hdGlvbnMiLCJnZXRCbG9ja051bWJlciIsImNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlciIsInJlb3JkZXJlZEV2ZW50Iiwib3RoZXIiLCJjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlciIsInN0YXJ0QmxvY2siLCJtYXhGZWVQZXJCbG9iR2FzIiwiY2hhaW5JZCIsInNpZ25hdHVyZSIsIndhaXQiLCJfY29uZmlybXMiLCJfdGltZW91dCIsImNvbmZpcm1zIiwidGltZW91dCIsIm5leHRTY2FuIiwic3RvcFNjYW5uaW5nIiwiY2hlY2tSZXBsYWNlbWVudCIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJtaW5lZCIsImkiLCJyZWFzb24iLCJjYW5jZWxsZWQiLCJyZXBsYWNlbWVudCIsInJlcGxhY2VhYmxlVHJhbnNhY3Rpb24iLCJjaGVja1JlY2VpcHQiLCJhY3Rpb24iLCJpbnZvY2F0aW9uIiwicmV2ZXJ0IiwidHJhbnNhY3Rpb24iLCJ3YWl0ZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbmNlbGxlcnMiLCJjYW5jZWwiLCJmb3JFYWNoIiwiYyIsInB1c2giLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJ0eExpc3RlbmVyIiwiZXJyb3IiLCJvZmYiLCJvbiIsInJlcGxhY2VMaXN0ZW5lciIsIm9uY2UiLCJpc0xlZ2FjeSIsImlzQmVybGluIiwiaXNDYW5jdW4iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvcnBoYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: () => (/* binding */ FilterIdEventSubscriber),\n/* harmony export */   FilterIdPendingSubscriber: () => (/* binding */ FilterIdPendingSubscriber),\n/* harmony export */   FilterIdSubscriber: () => (/* binding */ FilterIdSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */ _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */ _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */ _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [\n                filterId\n            ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId)=>{\n                if (this.#provider.destroyed) {\n                    return;\n                }\n                this.#provider.send(\"eth_uninstallFilter\", [\n                    filterId\n                ]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */ constructor(provider, filter){\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [\n            this.#event\n        ]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(\"pending\", result);\n        }\n    }\n} //# sourceMappingURL=subscriber-filterid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDcUI7QUFDakUsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1JO0lBQ1QsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsZUFBZSxDQUFDO0lBQ2pCLENBQUNDLE1BQU0sQ0FBQztJQUNSLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLEtBQUssQ0FBQztJQUNQOzs7O0tBSUMsR0FDREMsWUFBWU4sUUFBUSxDQUFFO1FBQ2xCLElBQUksQ0FBQyxDQUFDQSxRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDQyxlQUFlLEdBQUc7UUFDeEIsSUFBSSxDQUFDLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQ0ssSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuQyxJQUFJLENBQUMsQ0FBQ0wsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNDLEtBQUssR0FBRztJQUNsQjtJQUNBOztLQUVDLEdBQ0RJLFdBQVdULFFBQVEsRUFBRTtRQUNqQixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNEQyxhQUFhWCxRQUFRLEVBQUVZLE1BQU0sRUFBRTtRQUMzQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNERyxTQUFTYixRQUFRLEVBQUU7UUFDZixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQSxNQUFNLENBQUNILElBQUksQ0FBQ08sV0FBVztRQUNuQixJQUFJO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksSUFBSSxDQUFDLENB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d2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanM/OWMyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Vycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgU29tZSBiYWNrZW5kcyBzdXBwb3J0IHN1YnNjcmliaW5nIHRvIGV2ZW50cyB1c2luZyBhIEZpbHRlciBJRC5cbiAqXG4gKiAgV2hlbiBzdWJzY3JpYmluZyB3aXRoIHRoaXMgdGVjaG5pcXVlLCB0aGUgbm9kZSBpc3N1ZXMgYSB1bmlxdWVcbiAqICAvL0ZpbHRlciBJRC8vLiBBdCB0aGlzIHBvaW50IHRoZSBub2RlIGRlZGljYXRlcyByZXNvdXJjZXMgdG9cbiAqICB0aGUgZmlsdGVyLCBzbyB0aGF0IHBlcmlvZGljIGNhbGxzIHRvIGZvbGxvdyB1cCBvbiB0aGUgLy9GaWx0ZXIgSUQvL1xuICogIHdpbGwgcmVjZWl2ZSBhbnkgZXZlbnRzIHNpbmNlIHRoZSBsYXN0IGNhbGwuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVySWRQcm9taXNlO1xuICAgICNwb2xsZXI7XG4gICAgI3J1bm5pbmc7XG4gICAgI25ldHdvcms7XG4gICAgI2hhdWx0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmlsdGVySWRTdWJzY3JpYmVyKiogd2hpY2ggd2lsbCB1c2VkIFtbX3N1YnNjcmliZV1dXG4gICAgICogIGFuZCBbW19lbWl0UmVzdWx0c11dIHRvIHNldHVwIHRoZSBzdWJzY3JpcHRpb24gYW5kIHByb3ZpZGUgdGhlIGV2ZW50XG4gICAgICogIHRvIHRoZSAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25ldHdvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBiZWdpbiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSB0aGUgZXZlbnRzLlxuICAgICAqL1xuICAgIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgcmVjb3Zlcnkgb24gZXJyb3JzLlxuICAgICAqL1xuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gdGhpcy5fc3Vic2NyaWJlKHRoaXMuI3Byb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgRmlsdGVyIElEXG4gICAgICAgICAgICBsZXQgZmlsdGVySWQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJZCA9IGF3YWl0IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikgfHwgZXJyb3Iub3BlcmF0aW9uICE9PSBcImV0aF9uZXdGaWx0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IEZpbHRlciBJRDsgZG93bmdyYWRlIHRvXG4gICAgICAgICAgICAvLyBwb2xsaW5nXG4gICAgICAgICAgICBpZiAoZmlsdGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuX3JlY292ZXJTdWJzY3JpYmVyKHRoaXMsIHRoaXMuX3JlY292ZXIodGhpcy4jcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yay5jaGFpbklkICE9PSBuZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFpZCBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2hhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW1pdFJlc3VsdHModGhpcy4jcHJvdmlkZXIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkBUT0RPXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgI3RlYXJkb3duKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZFByb21pc2UgPSB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgIGlmIChmaWx0ZXJJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBmaWx0ZXJJZFByb21pc2UudGhlbigoZmlsdGVySWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcHJvdmlkZXIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jaGF1bHQgPSB0cnVlO1xuICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxufVxuLyoqXG4gKiAgQSAqKkZpbHRlcklkU3Vic2NyaWJlcioqIGZvciByZWNlaXZpbmcgY29udHJhY3QgZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgICNldmVudDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlXG4gICAgICogIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZXZlbnQgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcihwcm92aWRlciwgdGhpcy4jZXZlbnQpO1xuICAgIH1cbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkID0gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdGaWx0ZXJcIiwgW3RoaXMuI2V2ZW50XSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jZXZlbnQsIHByb3ZpZGVyLl93cmFwTG9nKHJlc3VsdCwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgIGFzeW5jIF9zdWJzY3JpYmUocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCIsIFtdKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLWZpbHRlcmlkLmpzLm1hcCJdLCJuYW1lcyI6WyJpc0Vycm9yIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsImNvcHkiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJGaWx0ZXJJZFN1YnNjcmliZXIiLCJwcm92aWRlciIsImZpbHRlcklkUHJvbWlzZSIsInBvbGxlciIsInJ1bm5pbmciLCJuZXR3b3JrIiwiaGF1bHQiLCJjb25zdHJ1Y3RvciIsInBvbGwiLCJiaW5kIiwiX3N1YnNjcmliZSIsIkVycm9yIiwiX2VtaXRSZXN1bHRzIiwicmVzdWx0IiwiX3JlY292ZXIiLCJibG9ja051bWJlciIsImZpbHRlcklkIiwiZXJyb3IiLCJvcGVyYXRpb24iLCJfcmVjb3ZlclN1YnNjcmliZXIiLCJnZXROZXR3b3JrIiwiY2hhaW5JZCIsInNlbmQiLCJjb25zb2xlIiwibG9nIiwib25jZSIsInRlYXJkb3duIiwidGhlbiIsImRlc3Ryb3llZCIsInN0YXJ0Iiwic3RvcCIsIm9mZiIsInBhdXNlIiwiZHJvcFdoaWxlUGF1c2VkIiwicmVzdW1lIiwiRmlsdGVySWRFdmVudFN1YnNjcmliZXIiLCJldmVudCIsImZpbHRlciIsInJlc3VsdHMiLCJlbWl0IiwiX3dyYXBMb2ciLCJfbmV0d29yayIsIkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: () => (/* binding */ OnBlockSubscriber),\n/* harmony export */   PollingBlockSubscriber: () => (/* binding */ PollingBlockSubscriber),\n/* harmony export */   PollingBlockTagSubscriber: () => (/* binding */ PollingBlockTagSubscriber),\n/* harmony export */   PollingEventSubscriber: () => (/* binding */ PollingEventSubscriber),\n/* harmony export */   PollingOrphanSubscriber: () => (/* binding */ PollingOrphanSubscriber),\n/* harmony export */   PollingTransactionSubscriber: () => (/* binding */ PollingTransactionSubscriber),\n/* harmony export */   getPollingSubscriber: () => (/* binding */ getPollingSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\",\n        info: {\n            event\n        }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */ get pollingInterval() {\n        return this.#interval;\n    }\n    set pollingInterval(value) {\n        this.#interval = value;\n    }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for(let b = this.#blockNumber + 1; b <= blockNumber; b++){\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        } catch (error) {\n        // @TODO: Minor bump, add an \"error\" event to let subscribers\n        //        know things went awry.\n        //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber)=>{\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */ async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n    }\n    resume() {\n        this.start();\n    }\n}\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag){\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter){\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */ constructor(provider, hash){\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */ constructor(provider, filter){\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs){\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber)=>{\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n} //# sourceMappingURL=subscriber-polling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDeEQsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7O0NBSUMsR0FDTSxTQUFTSSxxQkFBcUJDLFFBQVEsRUFBRUMsS0FBSztJQUNoRCxJQUFJQSxVQUFVLFNBQVM7UUFDbkIsT0FBTyxJQUFJQyx1QkFBdUJGO0lBQ3RDO0lBQ0EsSUFBSVAsNERBQVdBLENBQUNRLE9BQU8sS0FBSztRQUN4QixPQUFPLElBQUlFLDZCQUE2QkgsVUFBVUM7SUFDdEQ7SUFDQVQsdURBQU1BLENBQUMsT0FBTyw2QkFBNkIseUJBQXlCO1FBQ2hFWSxXQUFXO1FBQXdCQyxNQUFNO1lBQUVKO1FBQU07SUFDckQ7QUFDSjtBQUNBLHVCQUF1QjtBQUN2Qjs7Ozs7Q0FLQyxHQUNNLE1BQU1DO0lBQ1QsQ0FBQ0YsUUFBUSxDQUFDO0lBQ1YsQ0FBQ00sTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNEQyxZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNNLE1BQU0sR0FBRztRQUNmLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQUc7UUFDakIsSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBRyxDQUFDO0lBQ3pCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJRSxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQUU7SUFDL0MsSUFBSUcsZ0JBQWdCQyxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ0osUUFBUSxHQUFHSTtJQUFP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Q3BELElBQUksQ0FBQyxDQUFDaEMsV0FBVyxHQUFHZ0MsSUFBSWhDLFdBQVc7UUFDdkM7SUFDSjtJQUNBVyxRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ08sT0FBTyxFQUFFO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDQSxPQUFPLEdBQUc7UUFDaEIsSUFBSSxJQUFJLENBQUMsQ0FBQ2xCLFdBQVcsS0FBSyxDQUFDLEdBQUc7WUFDMUIsSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQ2EsY0FBYyxHQUFHcUMsSUFBSSxDQUFDLENBQUMxQztnQkFDbEMsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7WUFDeEI7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDUixRQUFRLENBQUM2QixFQUFFLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQ3ZCLE1BQU07SUFDM0M7SUFDQWMsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ00sT0FBTyxFQUFFO1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDMUIsUUFBUSxDQUFDOEIsR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUN4QixNQUFNO0lBQzVDO0lBQ0FnQixNQUFNQyxlQUFlLEVBQUU7UUFDbkIsSUFBSSxDQUFDSCxJQUFJO1FBQ1QsSUFBSUcsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxDQUFDZixXQUFXLEdBQUcsQ0FBQztRQUN6QjtJQUNKO0lBQ0FnQixTQUFTO1FBQ0wsSUFBSSxDQUFDTCxLQUFLO0lBQ2Q7QUFDSixFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzP2I2YzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBwb2xsaW5nIGV2ZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxuICAgIH0pO1xufVxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcbi8qKlxuICogIEEgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogcG9sbHMgYXQgYSByZWd1bGFyIGludGVydmFsIGZvciBhIGNoYW5nZVxuICogIGluIHRoZSBibG9jayBudW1iZXIuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjaW50ZXJ2YWw7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNpbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jaW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cbiAgICBhc3luYyAjcG9sbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCBwb2xsIHRvIHNldHVwIG91ciBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyICE9PSB0aGlzLiNibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSB0aGlzLiNibG9ja051bWJlciArIDE7IGIgPD0gYmxvY2tOdW1iZXI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTWlub3IgYnVtcCwgYWRkIGFuIFwiZXJyb3JcIiBldmVudCB0byBsZXQgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIC8vICAgICAgICBrbm93IHRoaW5ncyB3ZW50IGF3cnkuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICAgICAgdGhpcy4jcG9sbCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9jbGVhclRpbWVvdXQodGhpcy4jcG9sbGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cbiAqICBpbXBsbWVudGF0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGw7XG4gICAgI3J1bm5pbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk9uQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9sbChibG9ja051bWJlciwgdGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB0aGlzLnN0b3AoKTsgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnQgY2xhc3MgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjdGFnO1xuICAgICNsYXN0QmxvY2s7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHRhZykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI3RhZyA9IHRhZztcbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXVzZShkcm9wV2hpbGVQYXVzZWQpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm92aWRlci5nZXRCbG9jayh0aGlzLiN0YWcpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2sgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2subnVtYmVyID4gdGhpcy4jbGFzdEJsb2NrKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI3RhZywgYmxvY2subnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ09ycGhhblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuI2ZpbHRlcik7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb25cbiAqICBoYXNoIGZvciBpdHMgcmVjZWlwdC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2hhc2g7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVoYXNoJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGhhc2gpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNoYXNoID0gaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2hhc2gpO1xuICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jaGFzaCwgdHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlBvbGxpbmdFdmVudFN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gZmlsdGVyIGZvciBpdHMgbG9ncy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdFdmVudFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVyO1xuICAgICNwb2xsZXI7XG4gICAgI3J1bm5pbmc7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gVGhlIGluaXRpYWwgYmxvY2sgaGFzbid0IGJlZW4gZGV0ZXJtaW5lZCB5ZXRcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNvcHkodGhpcy4jZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgLy8gTm8gbG9ncyBjb3VsZCBqdXN0IG1lYW4gdGhlIG5vZGUgaGFzIG5vdCBpbmRleGVkIHRoZW0geWV0LFxuICAgICAgICAvLyBzbyB3ZSBrZWVwIGEgc2xpZGluZyB3aW5kb3cgb2YgNjAgYmxvY2tzIHRvIGtlZXAgc2Nhbm5pbmdcbiAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPCBibG9ja051bWJlciAtIDYwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmVtaXQodGhpcy4jZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgLy8gT25seSBhZHZhbmNlIHRoZSBibG9jayBudW1iZXIgd2hlbiBsb2dzIHdlcmUgZm91bmQgdG9cbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIG5ldHdvcmtzIChsaWtlIEJOQiBhbmQgUG9seWdvbikgd2hpY2ggbWF5XG4gICAgICAgICAgICAvLyBzYWNyaWZpY2UgZXZlbnQgY29uc2lzdGVuY3kgZm9yIGJsb2NrIGV2ZW50IHNwZWVkXG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItcG9sbGluZy5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiaXNIZXhTdHJpbmciLCJjb3B5Iiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZ2V0UG9sbGluZ1N1YnNjcmliZXIiLCJwcm92aWRlciIsImV2ZW50IiwiUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciIsIlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIiLCJvcGVyYXRpb24iLCJpbmZvIiwicG9sbGVyIiwiaW50ZXJ2YWwiLCJibG9ja051bWJlciIsImNvbnN0cnVjdG9yIiwicG9sbGluZ0ludGVydmFsIiwidmFsdWUiLCJwb2xsIiwiZ2V0QmxvY2tOdW1iZXIiLCJiIiwiZW1pdCIsImVycm9yIiwiX3NldFRpbWVvdXQiLCJiaW5kIiwic3RhcnQiLCJzdG9wIiwiX2NsZWFyVGltZW91dCIsInBhdXNlIiwiZHJvcFdoaWxlUGF1c2VkIiwicmVzdW1lIiwiT25CbG9ja1N1YnNjcmliZXIiLCJydW5uaW5nIiwiX3BvbGwiLCJFcnJvciIsIm9uIiwib2ZmIiwiUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciIsInRhZyIsImxhc3RCbG9jayIsImJsb2NrIiwiZ2V0QmxvY2siLCJudW1iZXIiLCJQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciIsImZpbHRlciIsImNvbnNvbGUiLCJsb2ciLCJoYXNoIiwidHgiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsImxvZ3MiLCJnZXRMb2dzIiwibGVuZ3RoIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n} //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEUsU0FBU0csYUFBYUMsSUFBSSxFQUFFQyxXQUFXO0lBQ25DLE9BQU87UUFDSEMsU0FBU04sNkRBQVVBLENBQUNJO1FBQ3BCQyxhQUFhQSxZQUFZRSxHQUFHLENBQUMsQ0FBQ0MsWUFBWUM7WUFDdENSLCtEQUFjQSxDQUFDQyw0REFBV0EsQ0FBQ00sWUFBWSxLQUFLLGdCQUFnQixDQUFDLFlBQVksRUFBRUMsTUFBTSxDQUFDLENBQUMsRUFBRUQ7WUFDckYsT0FBT0EsV0FBV0UsV0FBVztRQUNqQztJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE9BQU9BLE1BQU1MLEdBQUcsQ0FBQyxDQUFDUSxLQUFLTjtZQUNuQixJQUFJSSxNQUFNQyxPQUFPLENBQUNDLE1BQU07Z0JBQ3BCZCwrREFBY0EsQ0FBQ2MsSUFBSUMsTUFBTSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFUCxNQUFNLENBQUMsQ0FBQyxFQUFFTTtnQkFDeEUsT0FBT1osYUFBYVksR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDdEM7WUFDQWQsK0RBQWNBLENBQUNjLE9BQU8sUUFBUSxPQUFRQSxRQUFTLFVBQVUsNEJBQTRCLFNBQVNIO1lBQzlGLE9BQU9ULGFBQWFZLElBQUlULE9BQU8sRUFBRVMsSUFBSVYsV0FBVztRQUNwRDtJQUNKO0lBQ0FKLCtEQUFjQSxDQUFDVyxTQUFTLFFBQVEsT0FBUUEsVUFBVyxVQUFVLHVCQUF1QixTQUFTQTtJQUM3RixNQUFNSyxTQUFTQyxPQUFPQyxJQUFJLENBQUNQLE9BQU9MLEdBQUcsQ0FBQyxDQUFDSDtRQUNuQyxNQUFNQyxjQUFjTyxLQUFLLENBQUNSLEtBQUssQ0FBQ2dCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYjtZQUMzQ2EsS0FBSyxDQUFDYixXQUFXLEdBQUc7WUFDcEIsT0FBT2E7UUFDWCxHQUFHLENBQUM7UUFDSixPQUFPbEIsYUFBYUMsTUFBTWMsT0FBT0MsSUFBSSxDQUFDZCxhQUFhaUIsSUFBSTtJQUMzRDtJQUNBTCxPQUFPSyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBT0QsRUFBRWpCLE9BQU8sQ0FBQ21CLGFBQWEsQ0FBQ0QsRUFBRWxCLE9BQU87SUFDeEQsT0FBT1c7QUFDWCxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzP2VlNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiBzdG9yYWdlS2V5cy5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyhzdG9yYWdlS2V5LCAzMiksIFwiaW52YWxpZCBzbG90XCIsIGBzdG9yYWdlS2V5c1ske2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0FjY2Vzc0xpc3RdXSBmcm9tIGFueSBldGhlcnMtc3VwcG9ydGVkIGFjY2Vzcy1saXN0IHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldC5sZW5ndGggPT09IDIsIFwiaW52YWxpZCBzbG90IHNldFwiLCBgdmFsdWVbJHtpbmRleH1dYCwgc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldCAhPSBudWxsICYmIHR5cGVvZiAoc2V0KSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFkZHJlc3Mtc2xvdCBzZXRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFjY2VzcyBsaXN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzbGlzdC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImFzc2VydEFyZ3VtZW50IiwiaXNIZXhTdHJpbmciLCJhY2Nlc3NTZXRpZnkiLCJhZGRyIiwic3RvcmFnZUtleXMiLCJhZGRyZXNzIiwibWFwIiwic3RvcmFnZUtleSIsImluZGV4IiwidG9Mb3dlckNhc2UiLCJhY2Nlc3NMaXN0aWZ5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJyZXN1bHQiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/address.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/address.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */ function computeAddress(key) {\n    let pubkey;\n    if (typeof key === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */ function recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNVO0FBQzNEOzs7O0NBSUMsR0FDTSxTQUFTRyxlQUFlQyxHQUFHO0lBQzlCLElBQUlDO0lBQ0osSUFBSSxPQUFRRCxRQUFTLFVBQVU7UUFDM0JDLFNBQVNILHdEQUFVQSxDQUFDSSxnQkFBZ0IsQ0FBQ0YsS0FBSztJQUM5QyxPQUNLO1FBQ0RDLFNBQVNELElBQUlHLFNBQVM7SUFDMUI7SUFDQSxPQUFPUCw2REFBVUEsQ0FBQ0MsMkRBQVNBLENBQUMsT0FBT0ksT0FBT0csU0FBUyxDQUFDLElBQUlBLFNBQVMsQ0FBQztBQUN0RTtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLGVBQWVDLE1BQU0sRUFBRUMsU0FBUztJQUM1QyxPQUFPUixlQUFlRCx3REFBVUEsQ0FBQ1UsZ0JBQWdCLENBQUNGLFFBQVFDO0FBQzlELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FkZHJlc3MuanM/MGQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxuICpcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBsZXQgcHVia2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHVia2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KGtleSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVia2V5ID0ga2V5LnB1YmxpY0tleTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3Moa2VjY2FrMjU2KFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xuICogIHVzZWQgdG8gc2lnbiAlJWRpZ2VzdCUlIHRoYXQgcmVzdWx0ZWQgaW4gJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImtlY2NhazI1NiIsIlNpZ25pbmdLZXkiLCJjb21wdXRlQWRkcmVzcyIsImtleSIsInB1YmtleSIsImNvbXB1dGVQdWJsaWNLZXkiLCJwdWJsaWNLZXkiLCJzdWJzdHJpbmciLCJyZWNvdmVyQWRkcmVzcyIsImRpZ2VzdCIsInNpZ25hdHVyZSIsInJlY292ZXJQdWJsaWNLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/authorization.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authorizationify: () => (/* binding */ authorizationify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n\n\n\nfunction authorizationify(auth) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(auth.address),\n        nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.nonce != null ? auth.nonce : 0),\n        chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.chainId != null ? auth.chainId : 0),\n        signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(auth.signature)\n    };\n} //# sourceMappingURL=authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ0Y7QUFDRDtBQUN2QyxTQUFTRyxpQkFBaUJDLElBQUk7SUFDakMsT0FBTztRQUNIQyxTQUFTTCw2REFBVUEsQ0FBQ0ksS0FBS0MsT0FBTztRQUNoQ0MsT0FBT0osMERBQVNBLENBQUMsS0FBTUksS0FBSyxJQUFJLE9BQVFGLEtBQUtFLEtBQUssR0FBRztRQUNyREMsU0FBU0wsMERBQVNBLENBQUMsS0FBTUssT0FBTyxJQUFJLE9BQVFILEtBQUtHLE9BQU8sR0FBRztRQUMzREMsV0FBV1AsdURBQVNBLENBQUNRLElBQUksQ0FBQ0wsS0FBS0ksU0FBUztJQUM1QztBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2F1dGhvcml6YXRpb24uanM/YzQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGF1dGhvcml6YXRpb25pZnkoYXV0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcbiAgICAgICAgbm9uY2U6IGdldEJpZ0ludCgoYXV0aC5ub25jZSAhPSBudWxsKSA/IGF1dGgubm9uY2UgOiAwKSxcbiAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KChhdXRoLmNoYWluSWQgIT0gbnVsbCkgPyBhdXRoLmNoYWluSWQgOiAwKSxcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbShhdXRoLnNpZ25hdHVyZSlcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsIlNpZ25hdHVyZSIsImdldEJpZ0ludCIsImF1dGhvcml6YXRpb25pZnkiLCJhdXRoIiwiYWRkcmVzcyIsIm5vbmNlIiwiY2hhaW5JZCIsInNpZ25hdHVyZSIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/addresses.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accesslist.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./authorization.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n    const blobToKzgCommitment = (blob)=>{\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n            if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n            }\n        } else if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment(blob));\n        }\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof kzg.blobToKZGCommitment === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKZGCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    const computeBlobKzgProof = (blob, commitment)=>{\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof kzg.computeBlobProof === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof kzg.computeBlobKzgProof === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof kzg.computeBlobKZGProof === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobKZGProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    return {\n        blobToKzgCommitment,\n        computeBlobKzgProof\n    };\n}\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while(versioned.length < 2){\n        versioned = \"0\" + versioned;\n    }\n    versioned += (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleAuthorizationList(value, param) {\n    try {\n        if (!Array.isArray(value)) {\n            throw new Error(\"authorizationList: invalid array\");\n        }\n        const result = [];\n        for(let i = 0; i < value.length; i++){\n            const auth = value[i];\n            if (!Array.isArray(auth)) {\n                throw new Error(`authorization[${i}]: invalid array`);\n            }\n            if (auth.length !== 6) {\n                throw new Error(`authorization[${i}]: wrong length`);\n            }\n            if (!auth[1]) {\n                throw new Error(`authorization[${i}]: null address`);\n            }\n            result.push({\n                address: handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n                    yParity: handleNumber(auth[3], \"yParity\"),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[4], 32),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction formatAuthorizationList(value) {\n    return value.map((a)=>{\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.r),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.s)\n        ];\n    });\n}\nfunction formatHashes(value, param) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for(let i = 0; i < value.length; i++){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    } else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[8], 32),\n            v\n        });\n    //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n        r,\n        s,\n        yParity\n    });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\")\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x02\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x01\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip4844(data) {\n    let fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for(let i = 0; i < fields[1].length; i++){\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i]\n            });\n        }\n        fields = fields[0];\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for(let i = 0; i < tx.blobVersionedHashes.length; i++){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress,\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                \"0x03\",\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)([\n                    fields,\n                    blobs.map((b)=>b.data),\n                    blobs.map((b)=>b.commitment),\n                    blobs.map((b)=>b.proof)\n                ])\n            ]);\n        }\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x03\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip7702(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 4,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\")\n    };\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) {\n        return tx;\n    }\n    _parseEipSignature(tx, fields.slice(10));\n    return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatAuthorizationList(tx.authorizationList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x04\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */ class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    #auths;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */ get type() {\n        return this.#type;\n    }\n    set type(value) {\n        switch(value){\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            case 4:\n            case \"pectra\":\n            case \"eip-7702\":\n                this.#type = 4;\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */ get typeName() {\n        switch(this.type){\n            case 0:\n                return \"legacy\";\n            case 1:\n                return \"eip-2930\";\n            case 2:\n                return \"eip-1559\";\n            case 3:\n                return \"eip-4844\";\n            case 4:\n                return \"eip-7702\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */ get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = value == null ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */ get nonce() {\n        return this.#nonce;\n    }\n    set nonce(value) {\n        this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(value, \"value\");\n    }\n    /**\n     *  The gas limit.\n     */ get gasLimit() {\n        return this.#gasLimit;\n    }\n    set gasLimit(value) {\n        this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value);\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */ get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */ get data() {\n        return this.#data;\n    }\n    set data(value) {\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */ get value() {\n        return this.#value;\n    }\n    set value(value) {\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value);\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */ get signature() {\n        return this.#sig || null;\n    }\n    set signature(value) {\n        this.#sig = value == null ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */ get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = value == null ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    }\n    get authorizationList() {\n        const value = this.#auths || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths) {\n        this.#auths = auths == null ? null : auths.map((a)=>(0,_authorization_js__WEBPACK_IMPORTED_MODULE_10__.authorizationify)(a));\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */ get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */ get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for(let i = 0; i < value.length; i++){\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */ get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b)=>Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for(let i = 0; i < _blobs.length; i++){\n            const blob = _blobs[i];\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(blob)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(blob);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data),\n                    commitment: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            } else {\n                const commit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.commitment);\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.data),\n                    commitment: commit,\n                    proof: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() {\n        return this.#kzg;\n    }\n    set kzg(kzg) {\n        if (kzg == null) {\n            this.#kzg = null;\n        } else {\n            this.#kzg = getKzgLibrary(kzg);\n        }\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */ constructor(){\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#kzg = null;\n        this.#blobs = null;\n        this.#auths = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */ get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_11__.keccak256)(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */ get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_11__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */ get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_12__.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */ get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */ isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n        const sig = signed ? this.signature : null;\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n            case 4:\n                return _serializeEip7702(this, sig);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */ get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */ get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */ inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return types.pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */ inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n        const hasAccessList = this.accessList != null;\n        const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n                value: this\n            });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n            value: this\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n            value: this\n        });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        } else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            } else if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else if (hasBlob && this.to) {\n                types.push(3);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */ clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */ toJSON() {\n        const s = (v)=>{\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */ static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof tx === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(tx);\n            if (payload[0] >= 0x7f) {\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch(payload[0]){\n                case 1:\n                    return Transaction.from(_parseEip2930(payload));\n                case 2:\n                    return Transaction.from(_parseEip1559(payload));\n                case 3:\n                    return Transaction.from(_parseEip4844(payload));\n                case 4:\n                    return Transaction.from(_parseEip7702(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"from\"\n            });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ087QUFDc0I7QUFDdUc7QUFDckk7QUFDTTtBQUNSO0FBQzlDLE1BQU1zQixPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsTUFBTUUsUUFBUUYsT0FBTztBQUNyQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssY0FBY0wsT0FBTztBQUMzQixNQUFNTSxZQUFZLE9BQU87QUFDekIsU0FBU0MsY0FBY0MsR0FBRztJQUN0QixNQUFNQyxzQkFBc0IsQ0FBQ0M7UUFDekIsSUFBSSxzQkFBc0JGLEtBQUs7WUFDM0IsOERBQThEO1lBQzlELGlFQUFpRTtZQUNqRSxJQUFJLHlCQUF5QkEsT0FBTyxPQUFRQSxJQUFJQyxtQkFBbUIsS0FBTSxZQUFZO2dCQUNqRixPQUFPdkIseURBQVFBLENBQUNzQixJQUFJQyxtQkFBbUIsQ0FBQ3BCLHdEQUFPQSxDQUFDcUI7WUFDcEQ7UUFDSixPQUNLLElBQUkseUJBQXlCRixPQUFPLE9BQVFBLElBQUlDLG1CQUFtQixLQUFNLFlBQVk7WUFDdEYsaUVBQWlFO1lBQ2pFLE9BQU92Qix5REFBUUEsQ0FBQ3NCLElBQUlDLG1CQUFtQixDQUFDQztRQUM1QztRQUNBLDJEQUEyRDtRQUMzRCxJQUFJLHlCQUF5QkYsT0FBTyxPQUFRQSxJQUFJRyxtQkFBbUIsS0FBTSxZQUFZO1lBQ2pGLE9BQU96Qix5REFBUUEsQ0FBQ3NCLElBQUlHLG1CQUFtQixDQUFDdEIsd0RBQU9BLENBQUNxQjtRQUNwRDtRQUNBbkIsK0RBQWNBLENBQUMsT0FBTywyQkFBMkIsT0FBT2lCO0lBQzVEO0lBQ0EsTUFBTUksc0JBQXNCLENBQUNGLE1BQU1HO1FBQy9CLG1CQUFtQjtRQUNuQixJQUFJLHNCQUFzQkwsT0FBTyxP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QWlEO1FBQ2pELElBQUlqQyxHQUFHNkIsbUJBQW1CLElBQUksTUFBTTtZQUNoQ3hELE9BQU93RCxtQkFBbUIsR0FBRzdCLEdBQUc2QixtQkFBbUI7UUFDdkQ7UUFDQSw0REFBNEQ7UUFDNUQsOERBQThEO1FBQzlELElBQUk3QixHQUFHcEQsR0FBRyxJQUFJLE1BQU07WUFDaEJ5QixPQUFPekIsR0FBRyxHQUFHb0QsR0FBR3BELEdBQUc7UUFDdkI7UUFDQSxJQUFJb0QsR0FBR3VCLEtBQUssSUFBSSxNQUFNO1lBQ2xCbEQsT0FBT2tELEtBQUssR0FBR3ZCLEdBQUd1QixLQUFLO1FBQzNCO1FBQ0EsSUFBSXZCLEdBQUcxQyxJQUFJLElBQUksTUFBTTtZQUNqQjNCLCtEQUFjQSxDQUFDMEMsT0FBTzhFLFFBQVEsSUFBSSw4Q0FBOEMsTUFBTW5EO1lBQ3RGckUsK0RBQWNBLENBQUMwQyxPQUFPZixJQUFJLEtBQUswQyxHQUFHMUMsSUFBSSxFQUFFLGlCQUFpQixNQUFNMEM7UUFDbkU7UUFDQSxJQUFJQSxHQUFHbEIsSUFBSSxJQUFJLE1BQU07WUFDakJuRCwrREFBY0EsQ0FBQzBDLE9BQU84RSxRQUFRLElBQUksOENBQThDLE1BQU1uRDtZQUN0RnJFLCtEQUFjQSxDQUFDMEMsT0FBT1MsSUFBSSxDQUFDMEYsV0FBVyxPQUFPLENBQUN4RSxHQUFHbEIsSUFBSSxJQUFJLEVBQUMsRUFBRzBGLFdBQVcsSUFBSSxpQkFBaUIsTUFBTXhFO1FBQ3ZHO1FBQ0EsT0FBTzNCO0lBQ1g7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcz82ZWJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2FkZHJlc3Nlcy5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBzaGEyNTYsIFNpZ25hdHVyZSwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVjb2RlUmxwLCBlbmNvZGVSbHAsIGdldEJ5dGVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNCeXRlc0xpa2UsIGlzSGV4U3RyaW5nLCB0b0JlQXJyYXksIHplcm9QYWRWYWx1ZSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuL2FjY2Vzc2xpc3QuanNcIjtcbmltcG9ydCB7IGF1dGhvcml6YXRpb25pZnkgfSBmcm9tIFwiLi9hdXRob3JpemF0aW9uLmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgQk5fTUFYX1VJTlQgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5jb25zdCBCTE9CX1NJWkUgPSA0MDk2ICogMzI7XG5mdW5jdGlvbiBnZXRLemdMaWJyYXJ5KGt6Zykge1xuICAgIGNvbnN0IGJsb2JUb0t6Z0NvbW1pdG1lbnQgPSAoYmxvYikgPT4ge1xuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYlByb29mXCIgaW4ga3pnKSB7XG4gICAgICAgICAgICAvLyBtaWNyby1lY2Mtc2lnbmVyOyBjaGVjayBmb3IgY29tcHV0ZUJsb2JQcm9vZiBzaW5jZSB0aGlzIEFQSVxuICAgICAgICAgICAgLy8gZXhwZWN0cyBhIHN0cmluZyB3aGlsZSB0aGUga3pnLXdhc20gYmVsb3cgZXhwZWN0cyBhIFVuaXQ4QXJyYXlcbiAgICAgICAgICAgIGlmIChcImJsb2JUb0t6Z0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS3pnQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS3pnQ29tbWl0bWVudChoZXhsaWZ5KGJsb2IpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJibG9iVG9LemdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGt6Zy13YXNtIDwwLjUuMDsgYmxvYlRvS3pnQ29tbWl0bWVudChVaW50OEFycmF5KSA9PiBVaW50OEFycmF5XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoYmxvYikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGt6Zy13YXNtID49IDAuNS4wOyBibG9iVG9LWkdDb21taXRtZW50KHN0cmluZykgPT4gc3RyaW5nXG4gICAgICAgIGlmIChcImJsb2JUb0taR0NvbW1pdG1lbnRcIiBpbiBremcgJiYgdHlwZW9mIChremcuYmxvYlRvS1pHQ29tbWl0bWVudCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LWkdDb21taXRtZW50KGhleGxpZnkoYmxvYikpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBLWkcgbGlicmFyeVwiLCBcImt6Z1wiLCBremcpO1xuICAgIH07XG4gICAgY29uc3QgY29tcHV0ZUJsb2JLemdQcm9vZiA9IChibG9iLCBjb21taXRtZW50KSA9PiB7XG4gICAgICAgIC8vIG1pY3JvLWVjYy1zaWduZXJcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYlByb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmNvbXB1dGVCbG9iUHJvb2YoaGV4bGlmeShibG9iKSwgaGV4bGlmeShjb21taXRtZW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGt6Zy13YXNtIDwwLjUuMDsgY29tcHV0ZUJsb2JLemdQcm9vZihVaW50OEFycmF5LCBVaW50OEFycmF5KSA9PiBVaW50OEFycmF5XG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iS3pnUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JLemdQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGJsb2IsIGNvbW1pdG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGt6Zy13YXNtID49IDAuNS4wOyBjb21wdXRlQmxvYktaR1Byb29mKHN0cmluZywgc3RyaW5nKSA9PiBzdHJpbmdcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JLWkdQcm9vZlwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmNvbXB1dGVCbG9iS1pHUHJvb2YoaGV4bGlmeShibG9iKSwgaGV4bGlmeShjb21taXRtZW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIEtaRyBsaWJyYXJ5XCIsIFwia3pnXCIsIGt6Zyk7XG4gICAgfTtcbiAgICByZXR1cm4geyBibG9iVG9LemdDb21taXRtZW50LCBjb21wdXRlQmxvYkt6Z1Byb29mIH07XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uZWRIYXNoKHZlcnNpb24sIGhhc2gpIHtcbiAgICBsZXQgdmVyc2lvbmVkID0gdmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHZlcnNpb25lZC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHZlcnNpb25lZCA9IFwiMFwiICsgdmVyc2lvbmVkO1xuICAgIH1cbiAgICB2ZXJzaW9uZWQgKz0gc2hhMjU2KGhhc2gpLnN1YnN0cmluZyg0KTtcbiAgICByZXR1cm4gXCIweFwiICsgdmVyc2lvbmVkO1xufVxuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NMaXN0KHZhbHVlLCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KHZhbHVlLCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dGhvcml6YXRpb25MaXN0OiBpbnZhbGlkIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRoID0gdmFsdWVbaV07XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXV0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IGludmFsaWQgYXJyYXlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdXRoLmxlbmd0aCAhPT0gNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXV0aG9yaXphdGlvblske2l9XTogd3JvbmcgbGVuZ3RoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1dGhbMV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IG51bGwgYWRkcmVzc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGhhbmRsZUFkZHJlc3MoYXV0aFsxXSksXG4gICAgICAgICAgICAgICAgbm9uY2U6IGhhbmRsZVVpbnQoYXV0aFsyXSwgXCJub25jZVwiKSxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGF1dGhbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogaGFuZGxlTnVtYmVyKGF1dGhbM10sIFwieVBhcml0eVwiKSxcbiAgICAgICAgICAgICAgICAgICAgcjogemVyb1BhZFZhbHVlKGF1dGhbNF0sIDMyKSxcbiAgICAgICAgICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGF1dGhbNV0sIDMyKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIHBhcmFtLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBnZXROdW1iZXIoX3ZhbHVlLCBwYXJhbSk7XG59XG5mdW5jdGlvbiBoYW5kbGVVaW50KF92YWx1ZSwgcGFyYW0pIHtcbiAgICBpZiAoX3ZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgcGFyYW0pO1xuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlIDw9IEJOX01BWF9VSU5ULCBcInZhbHVlIGV4Y2VlZHMgdWludCBzaXplXCIsIHBhcmFtLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKF92YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5sZW5ndGggPD0gMzIsIGB2YWx1ZSB0b28gbGFyZ2VgLCBgdHguJHtuYW1lfWAsIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoYSkgPT4ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICAgICAgYS5hZGRyZXNzLFxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIoYS5zaWduYXR1cmUueVBhcml0eSwgXCJ5UGFyaXR5XCIpLFxuICAgICAgICAgICAgdG9CZUFycmF5KGEuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgdG9CZUFycmF5KGEuc2lnbmF0dXJlLnMpXG4gICAgICAgIF07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRIYXNoZXModmFsdWUsIHBhcmFtKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGBpbnZhbGlkICR7cGFyYW19YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgJHsgcGFyYW0gfSBoYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3BhcnNlTGVnYWN5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZGF0YSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDYpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvblwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMV0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzNdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s1XSksXG4gICAgICAgIGNoYWluSWQ6IEJOXzBcbiAgICB9O1xuICAgIC8vIExlZ2FjeSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgY29uc3QgdiA9IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZcIik7XG4gICAgY29uc3QgciA9IGhhbmRsZVVpbnQoZmllbGRzWzddLCBcInJcIik7XG4gICAgY29uc3QgcyA9IGhhbmRsZVVpbnQoZmllbGRzWzhdLCBcInNcIik7XG4gICAgaWYgKHIgPT09IEJOXzAgJiYgcyA9PT0gQk5fMCkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSBjaGFpbiBJRCAob3IgMCBmb3IgbGVnYWN5KVxuICAgICAgICBsZXQgY2hhaW5JZCA9ICh2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICAgICAgaWYgKGNoYWluSWQgPCBCTl8wKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICB0eC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgLy8gU2lnbmVkIExlZ2FjeSBUcmFuc2FjdGlvblxuICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcbiAgICAgICAgdHguc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgcjogemVyb1BhZFZhbHVlKGZpZWxkc1s3XSwgMzIpLFxuICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGZpZWxkc1s4XSwgMzIpLFxuICAgICAgICAgICAgdlxuICAgICAgICB9KTtcbiAgICAgICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICBdO1xuICAgIGxldCBjaGFpbklkID0gQk5fMDtcbiAgICBpZiAodHguY2hhaW5JZCAhPSBCTl8wKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSBnZXRCaWdJbnQodHguY2hhaW5JZCwgXCJ0eC5jaGFpbklkXCIpO1xuICAgICAgICAvLyBXZSBoYXZlIGEgY2hhaW5JZCBpbiB0aGUgdHggYW5kIGFuIEVJUC0xNTUgdiBpbiB0aGUgc2lnbmF0dXJlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhleSBhZ3JlZSB3aXRoIGVhY2ggb3RoZXJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXNpZyB8fCBzaWcubmV0d29ya1YgPT0gbnVsbCB8fCBzaWcubGVnYWN5Q2hhaW5JZCA9PT0gY2hhaW5JZCwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR4LnNpZ25hdHVyZSkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBjaGFpbklkLCBidXQgRUlQLTE1NSBoYXZlIGEgZGVyaXZlZCBpbXBsaWNpdCBjaGFpbklkXG4gICAgICAgIGNvbnN0IGxlZ2FjeSA9IHR4LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAobGVnYWN5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBsZWdhY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmICghc2lnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShjaGFpbklkKSk7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhhdCB0eC5zaWduYXR1cmUsIGNoYWluSWQsIGFuZCBzaWdcbiAgICAvLyAgICAgICAgbWF0Y2ggYnV0IHRoYXQgbG9naWMgY291bGQgYnJlYWsgZXhpc3RpbmcgY29kZSwgc28gc2NoZWR1bGVcbiAgICAvLyAgICAgICAgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgYnVtcC5cbiAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IHZcbiAgICBsZXQgdiA9IEJpZ0ludCgyNyArIHNpZy55UGFyaXR5KTtcbiAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICB2ID0gU2lnbmF0dXJlLmdldENoYWluSWRWKGNoYWluSWQsIHNpZy52KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmlnSW50KHNpZy52KSAhPT0gdikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgc2lnbmF0dXJlXG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHYpKTtcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcykge1xuICAgIGxldCB5UGFyaXR5O1xuICAgIHRyeSB7XG4gICAgICAgIHlQYXJpdHkgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcInlQYXJpdHlcIik7XG4gICAgICAgIGlmICh5UGFyaXR5ICE9PSAwICYmIHlQYXJpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB5UGFyaXR5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzFdLCAzMik7XG4gICAgY29uc3QgcyA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMl0sIDMyKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7IHIsIHMsIHlQYXJpdHkgfSk7XG4gICAgdHguc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTIpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDkpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMVwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwNDg0NChkYXRhKSB7XG4gICAgbGV0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgbGV0IHR5cGVOYW1lID0gXCIzXCI7XG4gICAgbGV0IGJsb2JzID0gbnVsbDtcbiAgICAvLyBQYXJzZSB0aGUgbmV0d29yayBmb3JtYXRcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNCAmJiBBcnJheS5pc0FycmF5KGZpZWxkc1swXSkpIHtcbiAgICAgICAgdHlwZU5hbWUgPSBcIjMgKG5ldHdvcmsgZm9ybWF0KVwiO1xuICAgICAgICBjb25zdCBmQmxvYnMgPSBmaWVsZHNbMV0sIGZDb21taXRzID0gZmllbGRzWzJdLCBmUHJvb2ZzID0gZmllbGRzWzNdO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZCbG9icyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzFdXCIsIGZCbG9icyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkNvbW1pdHMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGNvbW1pdG1lbnRzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1syXVwiLCBmQ29tbWl0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZlByb29mcyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogcHJvb2ZzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1szXVwiLCBmUHJvb2ZzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZkJsb2JzLmxlbmd0aCA9PT0gZkNvbW1pdHMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL2NvbW1pdG1lbnRzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmUHJvb2ZzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9wcm9vZnMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGJsb2JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBmQmxvYnNbaV0sXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogZkNvbW1pdHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGZQcm9vZnNbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSBmaWVsZHNbMF07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTEgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTQpLCBgaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogaGFuZGxlVWludChmaWVsZHNbOV0sIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogZmllbGRzWzEwXVxuICAgIH07XG4gICAgaWYgKGJsb2JzKSB7XG4gICAgICAgIHR4LmJsb2JzID0gYmxvYnM7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHR4LnRvICE9IG51bGwsIGBpbnZhbGlkIGFkZHJlc3MgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodHguYmxvYlZlcnNpb25lZEhhc2hlcyksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaGVzOiBtdXN0IGJlIGFuIGFycmF5XCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodHguYmxvYlZlcnNpb25lZEhhc2hlc1tpXSwgMzIpLCBgaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaCBhdCBpbmRleCAke2l9OiBtdXN0IGJlIGxlbmd0aCAzMmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgRUlQLTQ4NDQgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvLyBAVE9ETzogRG8gd2UgbmVlZCB0byBkbyB0aGlzPyBUaGlzIGlzIG9ubHkgY2FsbGVkIGludGVybmFsbHlcbiAgICAvLyBhbmQgdXNlZCB0byB2ZXJpZnkgaGFzaGVzOyBpdCBtaWdodCBzYXZlIHRpbWUgdG8gbm90IGRvIHRoaXNcbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoY29uY2F0KFsgXCIweDAzXCIsIGVuY29kZVJscChmaWVsZHMpIF0pKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA0ODQ0KHR4LCBzaWcsIGJsb2JzKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBaZXJvQWRkcmVzcyksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckJsb2JHYXMgfHwgMCwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBmb3JtYXRIYXNoZXModHguYmxvYlZlcnNpb25lZEhhc2hlcyB8fCBbXSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIpXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgICAgICAvLyBXZSBoYXZlIGJsb2JzOyByZXR1cm4gdGhlIG5ldHdvcmsgd3JhcHBlZCBmb3JtYXRcbiAgICAgICAgaWYgKGJsb2JzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgICAgICBcIjB4MDNcIixcbiAgICAgICAgICAgICAgICBlbmNvZGVSbHAoW1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmNvbW1pdG1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIucHJvb2YpLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDNcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDc3MDIoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMyksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogNFwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDQsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KGZpZWxkc1s5XSwgXCJhdXRob3JpemF0aW9uTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC03NzAyIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTApKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNzcwMih0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHR4LmF1dGhvcml6YXRpb25MaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDA0XCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXG4gKiAgRXRoZXJldW0gYnkgYW4gRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLiBJdCBpbmNsdWRlc1xuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICAjdHlwZTtcbiAgICAjdG87XG4gICAgI2RhdGE7XG4gICAgI25vbmNlO1xuICAgICNnYXNMaW1pdDtcbiAgICAjZ2FzUHJpY2U7XG4gICAgI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICNtYXhGZWVQZXJHYXM7XG4gICAgI3ZhbHVlO1xuICAgICNjaGFpbklkO1xuICAgICNzaWc7XG4gICAgI2FjY2Vzc0xpc3Q7XG4gICAgI21heEZlZVBlckJsb2JHYXM7XG4gICAgI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgI2t6ZztcbiAgICAjYmxvYnM7XG4gICAgI2F1dGhzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cbiAgICAgKiAgZXhwbGljaXQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIFwibGVnYWN5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJsb25kb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSBcImNhbmN1blwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC00ODQ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIFwicGVjdHJhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTc3MDJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJlaXAtNDg0NFwiO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gXCJlaXAtNzcwMlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN0bztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gWmVyb0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gbm9uY2UuXG4gICAgICovXG4gICAgZ2V0IG5vbmNlKCkgeyByZXR1cm4gdGhpcy4jbm9uY2U7IH1cbiAgICBzZXQgbm9uY2UodmFsdWUpIHsgdGhpcy4jbm9uY2UgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBsaW1pdC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxuICAgIHNldCBnYXNMaW1pdCh2YWx1ZSkgeyB0aGlzLiNnYXNMaW1pdCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcImdhc1ByaWNlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdG90YWwgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gZGF0YS4gRm9yIGBgaW5pdGBgIHRyYW5zYWN0aW9ucyB0aGlzIGlzIHRoZVxuICAgICAqICBkZXBsb3ltZW50IGNvZGUuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgc2V0IGRhdGEodmFsdWUpIHsgdGhpcy4jZGF0YSA9IGhleGxpZnkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhbW91bnQgb2YgZXRoZXIgKGluIHdlaSkgdG8gc2VuZCBpbiB0aGlzIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWx1ZTsgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IGdldEJpZ0ludCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGlzIHRyYW5zYWN0aW9uIGlzIHZhbGlkIG9uLlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIElmIHNpZ25lZCwgdGhlIHNpZ25hdHVyZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy4jc2lnIHx8IG51bGw7IH1cbiAgICBzZXQgc2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3NpZyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYWNjZXNzIGxpc3QuXG4gICAgICpcbiAgICAgKiAgQW4gYWNjZXNzIGxpc3QgcGVybWl0cyBkaXNjb3VudGVkIChidXQgcHJlLXBhaWQpIGFjY2VzcyB0b1xuICAgICAqICBieXRlY29kZSBhbmQgc3RhdGUgdmFyaWFibGUgYWNjZXNzIHdpdGhpbiBjb250cmFjdCBleGVjdXRpb24uXG4gICAgICovXG4gICAgZ2V0IGFjY2Vzc0xpc3QoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYWNjZXNzTGlzdCB8fCBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMSB8fCB0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IGluIHY3LCB0aGlzIHNob3VsZCBhc3NpZ24gdGhlIHZhbHVlIG9yIGJlY29tZVxuICAgICAgICAgICAgICAgIC8vIGEgbGl2ZSBvYmplY3QgaXRzZWxmLCBvdGhlcndpc2UgbXV0YXRpb24gaXMgaW5jb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgYXV0aG9yaXphdGlvbkxpc3QoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYXV0aHMgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGJlY29tZSBhIGxpdmUgb2JqZWN0IGl0c2VsZixcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgbXV0YXRpb24gaXMgaW5jb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGF1dGhvcml6YXRpb25MaXN0KGF1dGhzKSB7XG4gICAgICAgIHRoaXMuI2F1dGhzID0gKGF1dGhzID09IG51bGwpID8gbnVsbCA6IGF1dGhzLm1hcCgoYSkgPT4gYXV0aG9yaXphdGlvbmlmeShhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4IGZlZSBwZXIgYmxvYiBnYXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IG1heEZlZVBlckJsb2JHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyQmxvYkdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJCbG9iR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckJsb2JHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQkxPYiB2ZXJzaW9uZWQgaGFzaGVzIGZvciBDYW5jdW4gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCBibG9iVmVyc2lvbmVkSGFzaGVzKCkge1xuICAgICAgICAvLyBAVE9ETzogTXV0YXRpb24gaXMgaW5jb25zaXN0ZW50OyBpZiB1bnNldCwgdGhlIHJldHVybmVkIHZhbHVlXG4gICAgICAgIC8vIGNhbm5vdCBtdXRhdGUgdGhlIG9iamVjdCwgaWYgc2V0IGl0IGNhblxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBibG9iVmVyc2lvbmVkSGFzaGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzIG11c3QgYmUgYW4gQXJyYXlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWVbaV0sIDMyKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQkxPYnMgZm9yIHRoZSBUcmFuc2FjdGlvbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogIElmIGBgYmxvYnNgYCBpcyBub24tYGBudWxsYGAsIHRoZW4gdGhlIFtbc2VyaWFpbGl6ZWRdXVxuICAgICAqICB3aWxsIHJldHVybiB0aGUgbmV0d29yayBmb3JtYXR0ZWQgc2lkZWNhciwgb3RoZXJ3aXNlIGl0XG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBzdGFuZGFyZCBbW2xpbmstZWlwLTI3MThdXSBwYXlsb2FkLiBUaGVcbiAgICAgKiAgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXSBpcyB1bmFmZmVjdGVkIHJlZ2FyZGxlc3MuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGBgYmxvYnNgYCwgZWl0aGVyIGZ1bGx5IHZhbGlkIFtbQmxvYl1dIG9iamVjdHNcbiAgICAgKiAgbWF5IGJlIHNwZWNpZmllZCAoaS5lLiBjb3JyZWN0bHkgcGFkZGVkLCB3aXRoIGNvcnJlY3RcbiAgICAgKiAgY29tbWl0dG1lbnRzIGFuZCBwcm9vZnMpIG9yIGEgcmF3IFtbQnl0ZXNMaWtlXV0gbWF5XG4gICAgICogIGJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogIElmIHJhdyBbW0J5dGVzTGlrZV1dIGFyZSBwcm92aWRlZCwgdGhlIFtba3pnXV0gcHJvcGVydHkgKiptdXN0KipcbiAgICAgKiAgYmUgYWxyZWFkeSBzZXQuIFRoZSBibG9iIHdpbGwgYmUgY29ycmVjdGx5IHBhZGRlZCBhbmQgdGhlXG4gICAgICogIFtbS3pnTGlicmFyeV1dIHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb21taXR0bWVudCBhbmRcbiAgICAgKiAgcHJvb2YgZm9yIHRoZSBibG9iLlxuICAgICAqXG4gICAgICogIEEgQkxPYiBpcyBhIHNlcXVlbmNlIG9mIGZpZWxkIGVsZW1lbnRzLCBlYWNoIG9mIHdoaWNoIG11c3RcbiAgICAgKiAgYmUgd2l0aGluIHRoZSBCTFMgZmllbGQgbW9kdWxvLCBzbyBzb21lIGFkZGl0aW9uYWwgcHJvY2Vzc2luZ1xuICAgICAqICBtYXkgYmUgcmVxdWlyZWQgdG8gZW5jb2RlIGFyYml0cmFyeSBkYXRhIHRvIGVuc3VyZSBlYWNoIDMyIGJ5dGVcbiAgICAgKiAgZmllbGQgaXMgd2l0aGluIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZXMgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sXG4gICAgICogIG92ZXJ3cml0aW5nIGFueSBleGlzdGluZyB2YWx1ZXMuIFNldHRpbmcgdGhpcyB0byBgYG51bGxgYFxuICAgICAqICBkb2VzICoqbm90KiogcmVtb3ZlIHRoZSBbW2Jsb2JWZXJzaW9uZWRIYXNoZXNdXSwgbGVhdmluZyB0aGVtXG4gICAgICogIHByZXNlbnQuXG4gICAgICovXG4gICAgZ2V0IGJsb2JzKCkge1xuICAgICAgICBpZiAodGhpcy4jYmxvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jsb2JzLm1hcCgoYikgPT4gT2JqZWN0LmFzc2lnbih7fSwgYikpO1xuICAgIH1cbiAgICBzZXQgYmxvYnMoX2Jsb2JzKSB7XG4gICAgICAgIGlmIChfYmxvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2JzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnNpb25lZEhhc2hlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9ibG9icy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IF9ibG9ic1tpXTtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShibG9iKSkge1xuICAgICAgICAgICAgICAgIGFzc2VydCh0aGlzLiNremcsIFwiYWRkaW5nIGEgcmF3IGJsb2IgcmVxdWlyZXMgYSBLWkcgbGlicmFyeVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXQgYmxvYnMoKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlcyhibG9iKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhLmxlbmd0aCA8PSBCTE9CX1NJWkUsIFwiYmxvYiBpcyB0b28gbGFyZ2VcIiwgYGJsb2JzWyR7aX1dYCwgYmxvYik7XG4gICAgICAgICAgICAgICAgLy8gUGFkIGJsb2IgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBCTE9CX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoQkxPQl9TSVpFKTtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGVkLnNldChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWl0ID0gdGhpcy4ja3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBoZXhsaWZ5KHRoaXMuI2t6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGRhdGEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhsaWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBoZXhsaWZ5KGNvbW1pdCksXG4gICAgICAgICAgICAgICAgICAgIHByb29mXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1pdCA9IGhleGxpZnkoYmxvYi5jb21taXRtZW50KTtcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4bGlmeShibG9iLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBjb21taXQsXG4gICAgICAgICAgICAgICAgICAgIHByb29mOiBoZXhsaWZ5KGJsb2IucHJvb2YpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNibG9icyA9IGJsb2JzO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmVyc2lvbmVkSGFzaGVzO1xuICAgIH1cbiAgICBnZXQga3pnKCkgeyByZXR1cm4gdGhpcy4ja3pnOyB9XG4gICAgc2V0IGt6ZyhremcpIHtcbiAgICAgICAgaWYgKGt6ZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNremcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4ja3pnID0gZ2V0S3pnTGlicmFyeShremcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLiN0byA9IG51bGw7XG4gICAgICAgIHRoaXMuI25vbmNlID0gMDtcbiAgICAgICAgdGhpcy4jZ2FzTGltaXQgPSBCTl8wO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCTl8wO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gQk5fMDtcbiAgICAgICAgdGhpcy4jc2lnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICB0aGlzLiNhdXRocyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLiNnZXRTZXJpYWxpemVkKHRydWUsIGZhbHNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJlLWltYWdlIGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgc2lnbmVkLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcbiAgICAgKiAgdHJhbnNhY3Rpb24gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmUgIT0gbnVsbDtcbiAgICB9XG4gICAgI2dldFNlcmlhbGl6ZWQoc2lnbmVkLCBzaWRlY2FyKSB7XG4gICAgICAgIGFzc2VydCghc2lnbmVkIHx8IHRoaXMuc2lnbmF0dXJlICE9IG51bGwsIFwiY2Fubm90IHNlcmlhbGl6ZSB1bnNpZ25lZCB0cmFuc2FjdGlvbjsgbWF5YmUgeW91IG1lYW50IC51bnNpZ25lZFNlcmlhbGl6ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmVkID8gdGhpcy5zaWduYXR1cmUgOiBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNDg0NCh0aGlzLCBzaWcsIHNpZGVjYXIgPyB0aGlzLmJsb2JzIDogbnVsbCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXA3NzAyKHRoaXMsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXG4gICAgICpcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZChmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBtb3N0IFwibGlrZWx5XCIgdHlwZTsgY3VycmVudGx5IHRoZSBoaWdoZXN0XG4gICAgICogIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGluZmVyVHlwZSgpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLmluZmVyVHlwZXMoKTtcbiAgICAgICAgLy8gUHJlZmVyIExvbmRvbiAoRUlQLTE1NTkpIG92ZXIgQ2FuY3VuIChCTE9iKVxuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZigyKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGhpZ2hlc3QgaW5mZXJyZWQgdHlwZVxuICAgICAgICByZXR1cm4gKHR5cGVzLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlcyB0aGUgZXhwbGljaXQgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGF0aWJsZVxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpbmZlclR5cGVzKCkge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0ZlZSA9ICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNCbG9iID0gKHRoaXMuI21heEZlZVBlckJsb2JHYXMgIT0gbnVsbCB8fCB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzKTtcbiAgICAgICAgLy9pZiAoaGFzR2FzUHJpY2UgJiYgaGFzRmVlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlIGFuZCBtYXhGZWVQZXJHYXNcIik7XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLm1heEZlZVBlckdhcyA+PSB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzLCBcInByaW9yaXR5RmVlIGNhbm5vdCBiZSBtb3JlIHRoYW4gbWF4RmVlXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL2lmICh0aGlzLnR5cGUgPT09IDIgJiYgaGFzR2FzUHJpY2UpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2VcIik7XG4gICAgICAgIC8vfVxuICAgICAgICBhc3NlcnQoIWhhc0ZlZSB8fCAodGhpcy50eXBlICE9PSAwICYmIHRoaXMudHlwZSAhPT0gMSksIFwidHJhbnNhY3Rpb24gdHlwZSBjYW5ub3QgaGF2ZSBtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBhc3NlcnQodGhpcy50eXBlICE9PSAwIHx8ICFoYXNBY2Nlc3NMaXN0LCBcImxlZ2FjeSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBhY2Nlc3NMaXN0XCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgLy8gRXhwbGljaXQgdHlwZVxuICAgICAgICBpZiAodGhpcy50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR5cGVzLnB1c2godGhpcy50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dGhvcml6YXRpb25MaXN0ICYmIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCg0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZlZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0Jsb2IgJiYgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR5cGVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGJlcmxpbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhbiBbW2xpbmstZWlwLTQ4NDRdXSBCTE9CXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNDYW5jdW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyB0cmFuc2FjaXRvbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBKU09OLWZyaWVuZGx5IG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHMgPSAodikgPT4ge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBzKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHModGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcyh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogcyh0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICB2YWx1ZTogcyh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHModGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIHNpZzogdGhpcy5zaWduYXR1cmUgPyB0aGlzLnNpZ25hdHVyZS50b0pTT04oKSA6IG51bGwsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhICoqVHJhbnNhY3Rpb24qKiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvciBhXG4gICAgICogIFRyYW5zYWN0aW9uLWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR4KSB7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZ2V0Qnl0ZXModHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA0ODQ0KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDc3MDIocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZnJvbVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodHgudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50byA9IHR4LnRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heEZlZVBlckJsb2JHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckJsb2JHYXMgPSB0eC5tYXhGZWVQZXJCbG9iR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHR4LnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSB0eC5hdXRob3JpemF0aW9uTGlzdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IGJsb2JzLCBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXNzaWduIHRoZSBremcgYmVmb3JlIGFzc2lnbmluZyBibG9icywgd2hpY2hcbiAgICAgICAgLy8gcmVxdWlyZSB0aGUgbGlicmFyeSBpbiB0aGUgZXZlbnQgcmF3IGJsb2IgZGF0YSBpcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKHR4Lmt6ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQua3pnID0gdHgua3pnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9icyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYnMgPSB0eC5ibG9icztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lICcuaGFzaCdcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5mcm9tJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiWmVyb0FkZHJlc3MiLCJrZWNjYWsyNTYiLCJzaGEyNTYiLCJTaWduYXR1cmUiLCJTaWduaW5nS2V5IiwiY29uY2F0IiwiZGVjb2RlUmxwIiwiZW5jb2RlUmxwIiwiZ2V0Qnl0ZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0J5dGVzTGlrZSIsImlzSGV4U3RyaW5nIiwidG9CZUFycmF5IiwiemVyb1BhZFZhbHVlIiwiYWNjZXNzTGlzdGlmeSIsImF1dGhvcml6YXRpb25pZnkiLCJyZWNvdmVyQWRkcmVzcyIsIkJOXzAiLCJCaWdJbnQiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwiQk5fTUFYX1VJTlQiLCJCTE9CX1NJWkUiLCJnZXRLemdMaWJyYXJ5Iiwia3pnIiwiYmxvYlRvS3pnQ29tbWl0bWVudCIsImJsb2IiLCJibG9iVG9LWkdDb21taXRtZW50IiwiY29tcHV0ZUJsb2JLemdQcm9vZiIsImNvbW1pdG1lbnQiLCJjb21wdXRlQmxvYlByb29mIiwiY29tcHV0ZUJsb2JLWkdQcm9vZiIsImdldFZlcnNpb25lZEhhc2giLCJ2ZXJzaW9uIiwiaGFzaCIsInZlcnNpb25lZCIsInRvU3RyaW5nIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwiaGFuZGxlQWRkcmVzcyIsInZhbHVlIiwiaGFuZGxlQWNjZXNzTGlzdCIsInBhcmFtIiwiZXJyb3IiLCJtZXNzYWdlIiwiaGFuZGxlQXV0aG9yaXphdGlvbkxpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsInJlc3VsdCIsImkiLCJhdXRoIiwicHVzaCIsImFkZHJlc3MiLCJub25jZSIsImhhbmRsZVVpbnQiLCJjaGFpbklkIiwic2lnbmF0dXJlIiwiZnJvbSIsInlQYXJpdHkiLCJoYW5kbGVOdW1iZXIiLCJyIiwicyIsIl92YWx1ZSIsImZvcm1hdE51bWJlciIsIm5hbWUiLCJmb3JtYXRBY2Nlc3NMaXN0IiwibWFwIiwic2V0Iiwic3RvcmFnZUtleXMiLCJmb3JtYXRBdXRob3JpemF0aW9uTGlzdCIsImEiLCJmb3JtYXRIYXNoZXMiLCJfcGFyc2VMZWdhY3kiLCJkYXRhIiwiZmllbGRzIiwidHgiLCJ0eXBlIiwiZ2FzUHJpY2UiLCJnYXNMaW1pdCIsInRvIiwidiIsIl9zZXJpYWxpemVMZWdhY3kiLCJzaWciLCJuZXR3b3JrViIsImxlZ2FjeUNoYWluSWQiLCJsZWdhY3kiLCJnZXRDaGFpbklkViIsIl9wYXJzZUVpcFNpZ25hdHVyZSIsIl9wYXJzZUVpcDE1NTkiLCJzbGljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwiYWNjZXNzTGlzdCIsIl9zZXJpYWxpemVFaXAxNTU5IiwiX3BhcnNlRWlwMjkzMCIsIl9zZXJpYWxpemVFaXAyOTMwIiwiX3BhcnNlRWlwNDg0NCIsInR5cGVOYW1lIiwiYmxvYnMiLCJmQmxvYnMiLCJmQ29tbWl0cyIsImZQcm9vZnMiLCJwcm9vZiIsIm1heEZlZVBlckJsb2JHYXMiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiX3NlcmlhbGl6ZUVpcDQ4NDQiLCJiIiwiX3BhcnNlRWlwNzcwMiIsImF1dGhvcml6YXRpb25MaXN0IiwiX3NlcmlhbGl6ZUVpcDc3MDIiLCJUcmFuc2FjdGlvbiIsImF1dGhzIiwiT2JqZWN0IiwiYXNzaWduIiwiX2Jsb2JzIiwidmVyc2lvbmVkSGFzaGVzIiwib3BlcmF0aW9uIiwicGFkZGVkIiwiVWludDhBcnJheSIsImNvbW1pdCIsImNvbnN0cnVjdG9yIiwiZ2V0U2VyaWFsaXplZCIsInVuc2lnbmVkSGFzaCIsInVuc2lnbmVkU2VyaWFsaXplZCIsImZyb21QdWJsaWNLZXkiLCJyZWNvdmVyUHVibGljS2V5IiwiaXNTaWduZWQiLCJzaWduZWQiLCJzaWRlY2FyIiwiaW5mZXJUeXBlIiwic2VyaWFsaXplZCIsInR5cGVzIiwiaW5mZXJUeXBlcyIsImluZGV4T2YiLCJwb3AiLCJoYXNHYXNQcmljZSIsImhhc0ZlZSIsImhhc0FjY2Vzc0xpc3QiLCJoYXNCbG9iIiwic29ydCIsImlzTGVnYWN5IiwiaXNCZXJsaW4iLCJpc0xvbmRvbiIsImlzQ2FuY3VuIiwiY2xvbmUiLCJ0b0pTT04iLCJwYXlsb2FkIiwidG9Mb3dlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/base58.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base58.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: () => (/* binding */ decodeBase58),\n/* harmony export */   encodeBase58: () => (/* binding */ encodeBase58)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */ \n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for(let i = 0; i < Alphabet.length; i++){\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */ function encodeBase58(_value) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_value);\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt)(bytes);\n    let result = \"\";\n    while(value){\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    // Account for leading padding zeros\n    for(let i = 0; i < bytes.length; i++){\n        if (bytes[i]) {\n            break;\n        }\n        result = Alphabet[0] + result;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */ function decodeBase58(value) {\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n} //# sourceMappingURL=base58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ29DO0FBQ1E7QUFDUDtBQUN0QyxNQUFNRyxXQUFXO0FBQ2pCLElBQUlDLFNBQVM7QUFDYixTQUFTQyxTQUFTQyxNQUFNO0lBQ3BCLElBQUlGLFVBQVUsTUFBTTtRQUNoQkEsU0FBUyxDQUFDO1FBQ1YsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlKLFNBQVNLLE1BQU0sRUFBRUQsSUFBSztZQUN0Q0gsTUFBTSxDQUFDRCxRQUFRLENBQUNJLEVBQUUsQ0FBQyxHQUFHRSxPQUFPRjtRQUNqQztJQUNKO0lBQ0EsTUFBTUcsU0FBU04sTUFBTSxDQUFDRSxPQUFPO0lBQzdCTCwwREFBY0EsQ0FBQ1MsVUFBVSxNQUFNLENBQUMsb0JBQW9CLENBQUMsRUFBRSxVQUFVSjtJQUNqRSxPQUFPSTtBQUNYO0FBQ0EsTUFBTUMsT0FBT0YsT0FBTztBQUNwQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCOztDQUVDLEdBQ00sU0FBU0ksYUFBYUMsTUFBTTtJQUMvQixNQUFNQyxRQUFRZixrREFBUUEsQ0FBQ2M7SUFDdkIsSUFBSUUsUUFBUWQsbURBQVFBLENBQUNhO0lBQ3JCLElBQUlMLFNBQVM7SUFDYixNQUFPTSxNQUFPO1FBQ1ZOLFNBQVNQLFFBQVEsQ0FBQ2MsT0FBT0QsUUFBUUosT0FBTyxHQUFHRjtRQUMzQ00sU0FBU0o7SUFDYjtJQUNBLG9DQUFvQztJQUNwQyxJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSVEsTUFBTVAsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLElBQUlRLEtBQUssQ0FBQ1IsRUFBRSxFQUFFO1lBQ1Y7UUFDSjtRQUNBRyxTQUFTUCxRQUFRLENBQUMsRUFBRSxHQUFHTztJQUMzQjtJQUNBLE9BQU9BO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNRLGFBQWFGLEtBQUs7SUFDOUIsSUFBSU4sU0FBU0M7SUFDYixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSVMsTUFBTVIsTUFBTSxFQUFFRCxJQUFLO1FBQ25DRyxVQUFVRTtRQUNWRixVQUFVTCxTQUFTVyxLQUFLLENBQUNULEVBQUU7SUFDL0I7SUFDQSxPQUFPRztBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U1OC5qcz9jNGQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbmxldCBMb29rdXAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XG4gICAgICAgIExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF92YWx1ZSk7XG4gICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoYnl0ZXMpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgLy8gQWNjb3VudCBmb3IgbGVhZGluZyBwYWRkaW5nIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0WzBdICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgRGVjb2RlIHRoZSBCYXNlNTgtZW5jb2RlZCAlJXZhbHVlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNTgodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCAqPSBCTl81ODtcbiAgICAgICAgcmVzdWx0ICs9IGdldEFscGhhKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCIsInRvQmlnSW50IiwiQWxwaGFiZXQiLCJMb29rdXAiLCJnZXRBbHBoYSIsImxldHRlciIsImkiLCJsZW5ndGgiLCJCaWdJbnQiLCJyZXN1bHQiLCJCTl8wIiwiQk5fNTgiLCJlbmNvZGVCYXNlNTgiLCJfdmFsdWUiLCJieXRlcyIsInZhbHVlIiwiTnVtYmVyIiwiZGVjb2RlQmFzZTU4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/base64.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base64.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode\n *  arbitrary bytes into a string using 65 printable symbols, the\n *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,\n *  ``\"+\"`` and ``\"/\"`` with the ``\"=\"`` used for padding.\n *\n *  @_subsection: api/utils:Base64 Encoding  [about-base64]\n */ \n/**\n *  Decodes the base-64 encoded %%value%%.\n *\n *  @example:\n *    // The decoded value is always binary data...\n *    result = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n *    //_result:\n *\n *    // ...use toUtf8String to convert it to a string.\n *    toUtf8String(result)\n *    //_result:\n *\n *    // Decoding binary data\n *    decodeBase64(\"EjQ=\")\n *    //_result:\n */ function decodeBase64(value) {\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(Buffer.from(value, \"base64\"));\n}\n;\n/**\n *  Encodes %%data%% as a base-64 encoded string.\n *\n *  @example:\n *    // Encoding binary data as a hexstring\n *    encodeBase64(\"0x1234\")\n *    //_result:\n *\n *    // Encoding binary data as a Uint8Array\n *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n *    //_result:\n *\n *    // The input MUST be data...\n *    encodeBase64(\"Hello World!!\")\n *    //_error:\n *\n *    // ...use toUtf8Bytes for this.\n *    encodeBase64(toUtf8Bytes(\"Hello World!!\"))\n *    //_result:\n */ function encodeBase64(data) {\n    return Buffer.from((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data)).toString(\"base64\");\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FDa0Q7QUFDbkQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sU0FBU0UsYUFBYUMsS0FBSztJQUM5QixPQUFPRixzREFBWUEsQ0FBQ0csT0FBT0MsSUFBSSxDQUFDRixPQUFPO0FBQzNDOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU0csYUFBYUMsSUFBSTtJQUM3QixPQUFPSCxPQUFPQyxJQUFJLENBQUNMLGtEQUFRQSxDQUFDTyxPQUFPQyxRQUFRLENBQUM7QUFDaEQsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LmpzPzAwMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW0Jhc2U2NCBlbmNvZGluZ10obGluay13aWtpLWJhc2U2NCkgdXNpbmcgNi1iaXQgd29yZHMgdG8gZW5jb2RlXG4gKiAgYXJiaXRyYXJ5IGJ5dGVzIGludG8gYSBzdHJpbmcgdXNpbmcgNjUgcHJpbnRhYmxlIHN5bWJvbHMsIHRoZVxuICogIHVwcGVyLWNhc2UgYW5kIGxvd2VyLWNhc2UgYWxwaGFiZXQsIHRoZSBkaWdpdHMgYGAwYGAgdGhyb3VnaCBgYDlgYCxcbiAqICBgYFwiK1wiYGAgYW5kIGBgXCIvXCJgYCB3aXRoIHRoZSBgYFwiPVwiYGAgdXNlZCBmb3IgcGFkZGluZy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6QmFzZTY0IEVuY29kaW5nICBbYWJvdXQtYmFzZTY0XVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuLyoqXG4gKiAgRGVjb2RlcyB0aGUgYmFzZS02NCBlbmNvZGVkICUldmFsdWUlJS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYmluYXJ5IGRhdGEuLi5cbiAqICAgIHJlc3VsdCA9IGRlY29kZUJhc2U2NChcIlNHVnNiRzhnVjI5eWJHUWhJUT09XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gLi4udXNlIHRvVXRmOFN0cmluZyB0byBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLlxuICogICAgdG9VdGY4U3RyaW5nKHJlc3VsdClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBEZWNvZGluZyBiaW5hcnkgZGF0YVxuICogICAgZGVjb2RlQmFzZTY0KFwiRWpRPVwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldEJ5dGVzQ29weShCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIikpO1xufVxuO1xuLyoqXG4gKiAgRW5jb2RlcyAlJWRhdGElJSBhcyBhIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gRW5jb2RpbmcgYmluYXJ5IGRhdGEgYXMgYSBoZXhzdHJpbmdcbiAqICAgIGVuY29kZUJhc2U2NChcIjB4MTIzNFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVuY29kaW5nIGJpbmFyeSBkYXRhIGFzIGEgVWludDhBcnJheVxuICogICAgZW5jb2RlQmFzZTY0KG5ldyBVaW50OEFycmF5KFsgMHgxMiwgMHgzNCBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaGUgaW5wdXQgTVVTVCBiZSBkYXRhLi4uXG4gKiAgICBlbmNvZGVCYXNlNjQoXCJIZWxsbyBXb3JsZCEhXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4Qnl0ZXMgZm9yIHRoaXMuXG4gKiAgICBlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXMoXCJIZWxsbyBXb3JsZCEhXCIpKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZ2V0Qnl0ZXMoZGF0YSkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImRlY29kZUJhc2U2NCIsInZhbHVlIiwiQnVmZmVyIiwiZnJvbSIsImVuY29kZUJhc2U2NCIsImRhdGEiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNvRDtBQUNyRCxTQUFTRSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxJQUFJRixpQkFBaUJHLFlBQVk7UUFDN0IsSUFBSUQsTUFBTTtZQUNOLE9BQU8sSUFBSUMsV0FBV0g7UUFDMUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFRQSxVQUFXLFlBQVlBLE1BQU1JLEtBQUssQ0FBQywrQkFBK0I7UUFDMUUsTUFBTUMsU0FBUyxJQUFJRixXQUFXLENBQUNILE1BQU1NLE1BQU0sR0FBRyxLQUFLO1FBQ25ELElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBT0MsTUFBTSxFQUFFRSxJQUFLO1lBQ3BDSCxNQUFNLENBQUNHLEVBQUUsR0FBR0MsU0FBU1QsTUFBTVUsU0FBUyxDQUFDSCxRQUFRQSxTQUFTLElBQUk7WUFDMURBLFVBQVU7UUFDZDtRQUNBLE9BQU9GO0lBQ1g7SUFDQVAsMERBQWNBLENBQUMsT0FBTywyQkFBMkJHLFFBQVEsU0FBU0Q7QUFDdEU7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxTQUFTWCxLQUFLLEVBQUVDLElBQUk7SUFDaEMsT0FBT0YsVUFBVUMsT0FBT0MsTUFBTTtBQUNsQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNXLGFBQWFaLEtBQUssRUFBRUMsSUFBSTtJQUNwQyxPQUFPRixVQUFVQyxPQUFPQyxNQUFNO0FBQ2xDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1ksWUFBWWIsS0FBSyxFQUFFTSxNQUFNO0lBQ3JDLElBQUksT0FBUU4sVUFBVyxZQUFZLENBQUNBLE1BQU1JLEtBQUssQ0FBQyxxQkFBcUI7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFRRSxXQUFZLFlBQVlOLE1BQU1NLE1BQU0s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YWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanM/YzY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KD86WzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJfZ2V0Qnl0ZXMiLCJ2YWx1ZSIsIm5hbWUiLCJjb3B5IiwiVWludDhBcnJheSIsIm1hdGNoIiwicmVzdWx0IiwibGVuZ3RoIiwib2Zmc2V0IiwiaSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJpc0hleFN0cmluZyIsImlzQnl0ZXNMaWtlIiwiSGV4Q2hhcmFjdGVycyIsImhleGxpZnkiLCJkYXRhIiwiYnl0ZXMiLCJ2IiwiY29uY2F0IiwiZGF0YXMiLCJtYXAiLCJkIiwiam9pbiIsImRhdGFMZW5ndGgiLCJkYXRhU2xpY2UiLCJzdGFydCIsImVuZCIsImJ1ZmZlciIsInNsaWNlIiwic3RyaXBaZXJvc0xlZnQiLCJzdGFydHNXaXRoIiwiemVyb1BhZCIsImxlZnQiLCJmaWxsIiwic2V0IiwiemVyb1BhZFZhbHVlIiwiemVyb1BhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof value === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map((v)=>stringify(v, seen)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUN3QztBQUNVO0FBQ25ELFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsSUFBSTtJQUMxQixJQUFJRCxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJQyxRQUFRLE1BQU07UUFDZEEsT0FBTyxJQUFJQztJQUNmO0lBQ0EsSUFBSSxPQUFRRixVQUFXLFVBQVU7UUFDN0IsSUFBSUMsS0FBS0UsR0FBRyxDQUFDSCxRQUFRO1lBQ2pCLE9BQU87UUFDWDtRQUNBQyxLQUFLRyxHQUFHLENBQUNKO0lBQ2I7SUFDQSxJQUFJSyxNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDdEIsT0FBTyxPQUFPLE1BQU9PLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxVQUFVUyxHQUFHUCxPQUFRUSxJQUFJLENBQUMsUUFBUTtJQUN0RTtJQUNBLElBQUlULGlCQUFpQlUsWUFBWTtRQUM3QixNQUFNQyxNQUFNO1FBQ1osSUFBSUMsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJYixNQUFNYyxNQUFNLEVBQUVELElBQUs7WUFDbkNELFVBQVVELEdBQUcsQ0FBQ1gsS0FBSyxDQUFDYSxFQUFFLElBQUksRUFBRTtZQUM1QkQsVUFBVUQsR0FBRyxDQUFDWCxLQUFLLENBQUNhLEVBQUUsR0FBRyxJQUFJO1FBQ2pDO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLElBQUksT0FBUVosVUFBVyxZQUFZLE9BQVFBLE1BQU1lLE1BQU0sS0FBTSxZQUFZO1FBQ3JFLE9BQU9oQixVQUFVQyxNQUFNZSxNQUFNLElBQUlkO0lBQ3JDO0lBQ0EsT0FBUSxPQUFRRDtRQUNaLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU9BLE1BQU1nQixRQUFRO1FBQ3pCLEtBQUs7WUFDRCxPQUFPQyxPQUFPakIsT0FBT2dCLFFBQVE7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LGVBQWVDLE9BQU87UUFDdEIsSUFBSUUsU0FBU0QsV0FBV0osWUFBWTtRQUNwQyxJQUFJSSxXQUFXO1lBQ1hDLFVBQVU7WUFDVkwsYUFBYSxNQUFNSTtRQUN2QjtRQUNBdEIsT0FBTyxPQUFPLENBQUMseUJBQXlCLEVBQUV1QixPQUFPLGFBQWEsQ0FBQyxFQUFFLHlCQUF5QjtZQUN0Rkw7UUFDSjtJQUNKO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzPzg2NmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBzZWVuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoc2VlbiA9PSBudWxsKSB7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoKHYpID0+IHN0cmluZ2lmeSh2LCBzZWVuKSkpLmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gJiAweGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpLCBzZWVuKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGssIHNlZW4pfTogJHtzdHJpbmdpZnkodmFsdWVba10sIHNlZW4pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lc3NhZ2UlJSxcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBwb3B1bGF0ZWQgdmFsdWVzOiAke3N0cmluZ2lmeShpbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNob3J0TWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmZvW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGRldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVycm9yO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XG4gICAgICAgIGNhc2UgXCJCVUZGRVJfT1ZFUlJVTlwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgY29kZSB9KTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cbiAqXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBzaW1wbGUgaGVscGVyIHRvIHNpbXBseSBlbnN1cmluZyBwcm92aWRlZCBhcmd1bWVudHMgbWF0Y2ggZXhwZWN0ZWRcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhlICUlY2hlY2slJSBoYXMgYmVlbiBhc3NlcnRlZCB0cnVlLCBzb1xuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xufVxuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdGVzdCBmb3Igbm9ybWFsaXplXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gYWNjdW07XG59LCBbXSk7XG4vKipcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vcm1hbGl6ZShmb3JtKSB7XG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxuICAgIH0pO1xufVxuLyoqXG4gKiAgTWFueSBjbGFzc2VzIHVzZSBmaWxlLXNjb3BlZCB2YWx1ZXMgdG8gZ3VhcmQgdGhlIGNvbnN0cnVjdG9yLFxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXG4gKiAgdGhyb3dpbmcgaWYgbm90LCBpbmRpY2F0aW5nIHRoZSAlJWNsYXNzTmFtZSUlIGlmIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChnaXZlbkd1YXJkICE9PSBndWFyZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gXCIuXCI7XG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgcHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlICR7bWV0aG9kfWZyb20qIG1ldGhvZHNgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiZGVmaW5lUHJvcGVydGllcyIsInN0cmluZ2lmeSIsInZhbHVlIiwic2VlbiIsIlNldCIsImhhcyIsImFkZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInYiLCJqb2luIiwiVWludDhBcnJheSIsIkhFWCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJ0b0pTT04iLCJ0b1N0cmluZyIsIkJpZ0ludCIsIkpTT04iLCJrZXlzIiwiT2JqZWN0Iiwic29ydCIsImsiLCJpc0Vycm9yIiwiZXJyb3IiLCJjb2RlIiwiaXNDYWxsRXhjZXB0aW9uIiwibWFrZUVycm9yIiwibWVzc2FnZSIsImluZm8iLCJzaG9ydE1lc3NhZ2UiLCJkZXRhaWxzIiwiRXJyb3IiLCJrZXkiLCJwdXNoIiwiVHlwZUVycm9yIiwiUmFuZ2VFcnJvciIsImFzc2lnbiIsImFzc2VydCIsImNoZWNrIiwiYXNzZXJ0QXJndW1lbnQiLCJuYW1lIiwiYXJndW1lbnQiLCJhc3NlcnRBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiX25vcm1hbGl6ZUZvcm1zIiwicmVkdWNlIiwiYWNjdW0iLCJmb3JtIiwibm9ybWFsaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhwZWN0ZWQiLCJhc3NlcnROb3JtYWxpemUiLCJpbmRleE9mIiwib3BlcmF0aW9uIiwiYXNzZXJ0UHJpdmF0ZSIsImdpdmVuR3VhcmQiLCJndWFyZCIsImNsYXNzTmFtZSIsIm1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ \n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ2tEO0FBQ25EOzs7O0NBSUMsR0FDTSxNQUFNQztJQVNULENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7S0FHQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVGLFFBQVEsRUFBRUcsTUFBTSxDQUFFO1FBQ25DLElBQUksQ0FBQyxDQUFDSCxRQUFRLEdBQUdBO1FBQ2pCRixnRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVJO1lBQVNDO1FBQU87SUFDN0M7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGlCQUFpQjtRQUNuQixJQUFJLElBQUksQ0FBQyxDQUFDSixRQUFRLElBQUksTUFBTTtZQUN4QjtRQUNKO1FBQ0EsTUFBTSxJQUFJLENBQUNFLE9BQU8sQ0FBQ0csR0FBRyxDQUFDLElBQUksQ0FBQ0YsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQ3REO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzPzczM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXZlbnRzIGFsbG93IGZvciBhcHBsaWNhdGlvbnMgdG8gdXNlIHRoZSBvYnNlcnZlciBwYXR0ZXJuLCB3aGljaFxuICogIGFsbG93cyBzdWJzY3JpYmluZyBhbmQgcHVibGlzaGluZyBldmVudHMsIG91dHNpZGUgdGhlIG5vcm1hbFxuICogIGV4ZWN1dGlvbiBwYXRocy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9ldmVudHM6RXZlbnRzICBbYWJvdXQtZXZlbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuLyoqXG4gKiAgV2hlbiBhbiBbW0V2ZW50RW1pdHRlcmFibGVdXSB0cmlnZ2VycyBhIFtbTGlzdGVuZXJdXSwgdGhlXG4gKiAgY2FsbGJhY2sgYWx3YXlzIGFoYXMgb25lIGFkZGl0aW9uYWwgYXJndW1lbnQgcGFzc2VkLCB3aGljaCBpc1xuICogIGFuICoqRXZlbnRQYXlsb2FkKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxuICAgICAqL1xuICAgIGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlICoqRXZlbnRFbWl0dGVyYWJsZSoqLlxuICAgICAqL1xuICAgIGVtaXR0ZXI7XG4gICAgI2xpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxuICAgICAqICB0aGUgJSVsaXN0ZW5lciUlIGFuZCBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIkV2ZW50UGF5bG9hZCIsImxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJlbWl0dGVyIiwiZmlsdGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJvZmYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fetch.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: () => (/* binding */ FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* binding */ FetchRequest),\n/* harmony export */   FetchResponse: () => (/* binding */ FetchResponse)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/base64.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */ \n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n        }, match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3]));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */ function getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */ class FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request){\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, ()=>{\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners){\n                setTimeout(()=>{\n                    listener();\n                }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() {\n        return this.#cancelled;\n    }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */ class FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */ get url() {\n        return this.#url;\n    }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */ get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof body === \"string\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof body === \"object\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */ get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */ get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */ setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */ clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */ get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */ setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */ get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */ get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */ get timeout() {\n        return this.#timeout;\n    }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */ get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */ get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */ get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */ get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */ constructor(url){\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */ setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\",\n            reason: \"timeout\",\n            request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof error.stall !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                    // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) {}\n            // Things won't get any better on another attempt; abort\n            return response;\n        } else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof error.stall !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */ send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.send\"\n        });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */ cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.cancel\"\n        });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */ redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */ clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#throttle = Object.assign({}, this.#throttle);\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */ static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */ static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */ static createGetUrlFunc(options) {\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */ static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */ static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchRequest.\n */ class FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */ get statusCode() {\n        return this.#statusCode;\n    }\n    /**\n     *  The response status message.\n     */ get statusMessage() {\n        return this.#statusMessage;\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */ get headers() {\n        return Object.assign({}, this.#headers);\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */ get body() {\n        return this.#body == null ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */ get bodyText() {\n        try {\n            return this.#body == null ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */ get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request){\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k)=>{\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = body == null ? null : new Uint8Array(body);\n        this.#request = request || null;\n        this.#error = {\n            message: \"\"\n        };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */ makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = {\n            message,\n            error\n        };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */ throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, {\n            stall,\n            throttle: true\n        });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The request made for this response.\n     */ get request() {\n        return this.#request;\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */ ok() {\n        return this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */ assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        let requestUrl = null;\n        if (this.request) {\n            requestUrl = this.request.url;\n        }\n        let responseBody = null;\n        try {\n            if (this.#body) {\n                responseBody = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n            }\n        } catch (e) {}\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: this.request || \"unknown request\",\n            response: this,\n            error,\n            info: {\n                requestUrl,\n                responseBody,\n                responseStatus: `${this.statusCode} ${this.statusMessage}`\n            }\n        });\n    }\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUN3RDtBQUNyQjtBQUNpQjtBQUNGO0FBQ0c7QUFDWDtBQUMzQyxNQUFNUyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0Qiw2Q0FBNkM7QUFDN0MsSUFBSUMsb0JBQW9CSCx3REFBWUE7QUFDcEMsTUFBTUksU0FBUyxJQUFJQyxPQUFPLG1DQUFtQztBQUM3RCxNQUFNQyxTQUFTLElBQUlELE9BQU8seUJBQTBCO0FBQ3BELDBDQUEwQztBQUMxQyxJQUFJRSxTQUFTO0FBQ2IsNkVBQTZFO0FBQzdFLGVBQWVDLGdCQUFnQkMsR0FBRyxFQUFFQyxNQUFNO0lBQ3RDLElBQUk7UUFDQSxNQUFNQyxRQUFRRixJQUFJRSxLQUFLLENBQUNQO1FBQ3hCLElBQUksQ0FBQ08sT0FBTztZQUNSLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSUMsY0FBYyxLQUFLLE1BQU07WUFDaEMsZ0JBQWlCRixLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ2pDLEdBQUlBLEtBQUssQ0FBQyxFQUFFLEdBQUduQix3REFBWUEsQ0FBQ21CLEtBQUssQ0FBQyxFQUFFLElBQUlHLFVBQVVILEtBQUssQ0FBQyxFQUFFO0lBQzlELEVBQ0EsT0FBT0ksT0FBTztRQUNWLE9BQU8sSUFBSUYsY0FBYyxLQUFLLG1DQUFtQyxDQUFDLEdBQUcsTUFBTSxJQUFJRyxhQUFhUDtJQUNoRztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU1EsbUJBQW1CQyxPQUFPO0lBQy9CLGVBQWVDLFlBQVlWLEdBQUcsRUFBRUMsTUFBTTtRQUNsQyxJQUFJO1lBQ0EsTUFBTUMsUUFBUUYsSUFBSUUsS0FBSyxDQUFDTDtZQUN4QixJQUFJLENBQUNLLE9BQU87Z0JBQ1IsTUFBTSxJQUFJQyxNQUFNO1lBQ3BCO1lBQ0EsT0FBTyxJ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WSxPQUFPLElBQUtvRCxPQUFRcEQsT0FBTztBQUFJO0FBQ3BELFNBQVM3RSxVQUFVaUQsS0FBSztJQUNwQixPQUFPakUscURBQVdBLENBQUNpRSxNQUFNaUYsT0FBTyxDQUFDLHlCQUF5QixDQUFDQyxLQUFLQztRQUM1RCxPQUFPbEcsT0FBT21HLFlBQVksQ0FBQ25DLFNBQVNrQyxNQUFNO0lBQzlDO0FBQ0o7QUFDQSxTQUFTckQsS0FBS04sS0FBSztJQUNmLE9BQU8sSUFBSTZELFFBQVEsQ0FBQ0MsVUFBWXZILFdBQVd1SCxTQUFTOUQ7QUFDeEQsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanM/ZTFlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBGZXRjaGluZyBjb250ZW50IGZyb20gdGhlIHdlYiBpcyBlbnZpcm9ubWVudC1zcGVjaWZpYywgc28gRXRoZXJzXG4gKiAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gdGhhdCBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxuICogIHRoaXMgc2VydmljZS5cbiAqXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cbiAqICBjcmVhdGUgYSByZXF1ZXN0IG9iamVjdCwgcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGFuZCBwcm9jZXNzIGRhdGFcbiAqICBhbmQgcG9wdWxhdGUgdGhlIFtbRmV0Y2hSZXNwb25zZV1dLlxuICpcbiAqICBJbiBhIGJyb3dzZXIsIHRoZSBbRE9NIGZldGNoXShsaW5rLWpzLWZldGNoKSBpcyB1c2VkLCBhbmQgdGhlIHJlc3VsdGluZ1xuICogIGBgUHJvbWlzZWBgIGlzIHdhaXRlZCBvbiB0byByZXRyaWV2ZSB0aGUgcGF5bG9hZC5cbiAqXG4gKiAgVGhlIFtbRmV0Y2hSZXF1ZXN0XV0gaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIG1hbnkgY29tbW9uIHNpdHVhdGlvbnMsXG4gKiAgc3VjaCBhcyByZWRpcmVjdHMsIHNlcnZlciB0aHJvdHRsaW5nLCBhdXRoZW50aWNhdGlvbiwgZXRjLlxuICpcbiAqICBJdCBhbHNvIGhhbmRsZXMgY29tbW9uIGdhdGV3YXlzLCBzdWNoIGFzIElQRlMgYW5kIGRhdGEgVVJJcy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9mZXRjaGluZzpGZXRjaGluZyBXZWIgQ29udGVudCAgW2Fib3V0LWZldGNoXVxuICovXG5pbXBvcnQgeyBkZWNvZGVCYXNlNjQsIGVuY29kZUJhc2U2NCB9IGZyb20gXCIuL2Jhc2U2NC5qc1wiO1xuaW1wb3J0IHsgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4vdXRmOC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlR2V0VXJsIH0gZnJvbSBcIi4vZ2V0dXJsLmpzXCI7XG5jb25zdCBNQVhfQVRURU1QVFMgPSAxMjtcbmNvbnN0IFNMT1RfSU5URVJWQUwgPSAyNTA7XG4vLyBUaGUgZ2xvYmFsIEZldGNoR2V0VXJsRnVuYyBpbXBsZW1lbnRhdGlvbi5cbmxldCBkZWZhdWx0R2V0VXJsRnVuYyA9IGNyZWF0ZUdldFVybCgpO1xuY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgcmVJcGZzID0gbmV3IFJlZ0V4cChcIl5pcGZzOi9cXC8oaXBmcy8pPyguKikkXCIsIFwiaVwiKTtcbi8vIElmIGxvY2tlZCwgbmV3IEdhdGV3YXlzIGNhbm5vdCBiZSBhZGRlZFxubGV0IGxvY2tlZCA9IGZhbHNlO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSTHNcbmFzeW5jIGZ1bmN0aW9uIGRhdGFHYXRld2F5RnVuYyh1cmwsIHNpZ25hbCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlRGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoMjAwLCBcIk9LXCIsIHtcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IChtYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIiksXG4gICAgICAgIH0sIChtYXRjaFsyXSA/IGRlY29kZUJhc2U2NChtYXRjaFszXSkgOiB1bnBlcmNlbnQobWF0Y2hbM10pKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIGRhdGE6IFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRmV0Y2hHYXRld2F5RnVuY11dIGZvciBmZXRjaGluZyBjb250ZW50IGZyb20gYSBzdGFuZGFyZFxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlSXBmcyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsaW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xufVxuY29uc3QgR2F0ZXdheXMgPSB7XG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcbiAgICBcImlwZnNcIjogZ2V0SXBmc0dhdGV3YXlGdW5jKFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiKVxufTtcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hDYW5jZWxTaWduYWwge1xuICAgICNsaXN0ZW5lcnM7XG4gICAgI2NhbmNlbGxlZDtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgZmV0Y2hTaWduYWxzLnNldChyZXF1ZXN0LCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy4jY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGxpc3RlbmVyKCk7IH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBhc3NlcnQoIXRoaXMuI2NhbmNlbGxlZCwgXCJzaW5nYWwgYWxyZWFkeSBjYW5jZWxsZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZldGNoQ2FuY2VsU2lnbmFsLmFkZENhbmNlbExpc3RlbmVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHsgcmV0dXJuIHRoaXMuI2NhbmNlbGxlZDsgfVxuICAgIGNoZWNrU2lnbmFsKCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuY2FuY2VsbGVkLCBcImNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiLCB7fSk7XG4gICAgfVxufVxuLy8gQ2hlY2sgdGhlIHNpZ25hbCwgdGhyb3dpbmcgaWYgaXQgaXMgY2FuY2VsbGVkXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLyoqXG4gKiAgUmVwcmVzZW50cyBhIHJlcXVlc3QgZm9yIGEgcmVzb3VyY2UgdXNpbmcgYSBVUkkuXG4gKlxuICogIEJ5IGRlZmF1bHQsIHRoZSBzdXBwb3J0ZWQgc2NoZW1lcyBhcmUgYGBIVFRQYGAsIGBgSFRUUFNgYCwgYGBkYXRhOmBgLFxuICogIGFuZCBgYElQRlM6YGAuXG4gKlxuICogIEFkZGl0aW9uYWwgc2NoZW1lcyBjYW4gYmUgYWRkZWQgZ2xvYmFsbHkgdXNpbmcgW1tyZWdpc3RlckdhdGV3YXldXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KFwiaHR0cHM6Ly93d3cucmljbW9vLmNvbVwiKVxuICogICAgcmVzcCA9IGF3YWl0IHJlcS5zZW5kKClcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVxdWVzdCB7XG4gICAgI2FsbG93SW5zZWN1cmU7XG4gICAgI2d6aXA7XG4gICAgI2hlYWRlcnM7XG4gICAgI21ldGhvZDtcbiAgICAjdGltZW91dDtcbiAgICAjdXJsO1xuICAgICNib2R5O1xuICAgICNib2R5VHlwZTtcbiAgICAjY3JlZHM7XG4gICAgLy8gSG9va3NcbiAgICAjcHJlZmxpZ2h0O1xuICAgICNwcm9jZXNzO1xuICAgICNyZXRyeTtcbiAgICAjc2lnbmFsO1xuICAgICN0aHJvdHRsZTtcbiAgICAjZ2V0VXJsRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIFVSTCB0byByZXF1ZXN0LlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICBzZXQgdXJsKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBib2R5LCBpZiBhbnksIHRvIHNlbmQgYXMgdGhlIHJlcXVlc3QgYm9keS4gLy8oZGVmYXVsdDogbnVsbCkvL1xuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogIHNldCBhbmQgd2lsbCBiZSB1c2VkIGlmICoqbm90IG92ZXJyaWRkZW4qKiBieSBzZXR0aW5nIGEgY3VzdG9tXG4gICAgICogIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBudWxsLCB0aGUgYm9keSBpcyBjbGVhcmVkIChhbG9uZyB3aXRoIHRoZVxuICAgICAqICBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCkuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBzdHJpbmcsIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGB0ZXh0L3BsYWluYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBVaW50OEFycmF5LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXMgc2V0IHRvXG4gICAgICogIGBgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYW55IG90aGVyIG9iamVjdCwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzXG4gICAgICogIHNldCB0byBgYGFwcGxpY2F0aW9uL2pzb25gYC5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICBzZXQgYm9keShib2R5KSB7XG4gICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoYm9keSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwidGV4dC9wbGFpblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9keVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gSWYgbm8gbWV0aG9kXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xuICAgICAqICBudWxsIGFuZCBgYFBPU1RgYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI21ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCb2R5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICB9XG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFN0cmluZyhtZXRob2QpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gQWxsXG4gICAgICogIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvYmplY3QgaXMgYSBjb3B5LCBzbyBhbnkgY2hhbmdlcyB3aWxsICoqTk9UKiogYmUgcmVmbGVjdGVkXG4gICAgICogIGluIHRoZSBgYEZldGNoUmVxdWVzdGBgLlxuICAgICAqXG4gICAgICogIFRvIHNldCBhIGhlYWRlciBlbnRyeSwgdXNlIHRoZSBgYHNldEhlYWRlcmBgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jY3JlZHMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSBTdHJpbmcodGhpcy5ib2R5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXG4gICAgICogIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnNbU3RyaW5nKGtleSkudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYWxsIGhlYWRlcnMsIHJlc2V0dGluZyBhbGwgaW50cmluc2ljIGhlYWRlcnMuXG4gICAgICovXG4gICAgY2xlYXJIZWFkZXJzKCkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgZm9yIHRoZSBgYEF1dGhvcml6YXRpb25gYCBoZWFkZXIuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IHRoZSBjcmVkZW50aWFscywgdXNlIHRoZSBgYHNldENyZWRlbnRpYWxzYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWRzIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXRzIGFuIGBgQXV0aG9yaXphdGlvbmBgIGZvciAlJXVzZXJuYW1lJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGV0ZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBwcmlvciB0byBlYWNoIHJlcXVlc3QsIGZvciBleGFtcGxlXG4gICAgICogIGR1cmluZyBhIHJlZGlyZWN0aW9uIG9yIHJldHJ5IGluIGNhc2Ugb2Ygc2VydmVyIHRocm90dGxpbmcuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvZmZlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcG9wdWxhdGUgaGVhZGVycyBvciB1cGRhdGVcbiAgICAgKiAgY29udGVudCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHByZWZsaWdodEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcmVmbGlnaHQgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByZWZsaWdodEZ1bmMocHJlZmxpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3ByZWZsaWdodCA9IHByZWZsaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGVhY2ggcmVzcG9uc2UsIG9mZmVyaW5nIGFuXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcbiAgICAgKiAgcmVzcG9uc2UgZGF0YS5cbiAgICAgKlxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxuICAgICAqXG4gICAgICogIFRvIHNjaGVkdWxlIGEgcmV0cnkgYXR0ZW1wdCAoYXNzdW1pbmcgdGhlIG1heGltdW0gcmV0cnkgbGltaXRcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBwcm9jZXNzRnVuYyhwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxuICAgICAqL1xuICAgIGdldCByZXRyeUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcmV0cnlGdW5jKHJldHJ5KSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmZXRjaCBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcyBhbmQgaXMgcGxhdGZvcm0gc3BlY2lmaWMgKGUuZy4gbm9kZWpzIHZzXG4gICAgICogIGJyb3dzZXJzKS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGJ5IGRlZmF1bHQgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmxcbiAgICAgKiAgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSBjaGFuZ2VkIHVzaW5nIFtbcmVnaXN0ZXJHZXRVcmxdXS5cbiAgICAgKiAgSWYgdGhpcyBoYXMgYmVlbiBzZXQsIHNldHRpbmcgaXMgdG8gYGBudWxsYGAgd2lsbCBjYXVzZVxuICAgICAqICB0aGlzIEZldGNoUmVxdWVzdCAoYW5kIGFueSBmdXR1cmUgY2xvbmVzKSB0byByZXZlcnQgYmFjayB0b1xuICAgICAqICB1c2luZyB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgaXMgZ2VuZXJhbGx5IG5vdCBuZWNlc3NhcnksIGJ1dCBtYXkgYmUgdXNlZnVsXG4gICAgICogIGZvciBkZXZlbG9wZXJzIHRoYXQgd2lzaCB0byBpbnRlcmNlcHQgcmVxdWVzdHMgb3IgdG9cbiAgICAgKiAgY29uZmlndXJlZ2UgYSBwcm94eSBvciBvdGhlciBhZ2VudC5cbiAgICAgKi9cbiAgICBnZXQgZ2V0VXJsRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFVybEZ1bmMgfHwgZGVmYXVsdEdldFVybEZ1bmM7XG4gICAgfVxuICAgIHNldCBnZXRVcmxGdW5jKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBGZXRjaFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBPbmNlIGNyZWF0ZWQsIGVhY2ggcHJvcGVydHkgbWF5IGJlIHNldCBiZWZvcmUgaXNzdWluZyBhXG4gICAgICogIGBgLnNlbmQoKWBgIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICB0aGlzLiNhbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2d6aXAgPSB0cnVlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuI3RpbWVvdXQgPSAzMDAwMDA7XG4gICAgICAgIHRoaXMuI3Rocm90dGxlID0ge1xuICAgICAgICAgICAgc2xvdEludGVydmFsOiBTTE9UX0lOVEVSVkFMLFxuICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IE1BWF9BVFRFTVBUU1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNnZXRVcmxGdW5jID0gbnVsbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVxdWVzdCBtZXRob2Q9JHtKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGhvZCl9IHVybD0ke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gaGVhZGVycz0ke0pTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycyl9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXBkYXRlIHRoZSB0aHJvdHRsZSBwYXJhbWV0ZXJzIHVzZWQgdG8gZGV0ZXJtaW5lIG1heGltdW1cbiAgICAgKiAgYXR0ZW1wdHMgYW5kIGV4cG9uZW50aWFsLWJhY2tvZmYgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXRUaHJvdHRsZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zbG90SW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1heEF0dGVtcHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XG4gICAgICAgIGlmIChhdHRlbXB0ID49IHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImV4Y2VlZGVkIG1heGltdW0gcmV0cnkgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGdldFRpbWUoKSA8PSBleHBpcmVzLCBcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0LnNlbmRcIiwgcmVhc29uOiBcInRpbWVvdXRcIiwgcmVxdWVzdDogX3JlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IChyZXEudXJsLnNwbGl0KFwiOlwiKVswXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xuICAgICAgICBpZiAoc2NoZW1lIGluIEdhdGV3YXlzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBHYXRld2F5c1tzY2hlbWVdKHJlcS51cmwsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGEgcHJlZmxpZ2h0IGZ1bmN0aW9uOyB1cGRhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0RnVuYykge1xuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZ2V0VXJsRnVuYyhyZXEsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UocmVzcC5zdGF0dXNDb2RlLCByZXNwLnN0YXR1c01lc3NhZ2UsIHJlc3AuaGVhZGVycywgcmVzcC5ib2R5LCBfcmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAvLyBSZWRpcmVjdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnJlZGlyZWN0KGxvY2F0aW9uKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgMCwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyBUaGluZ3Mgd29uJ3QgZ2V0IGFueSBiZXR0ZXIgb24gYW5vdGhlciBhdHRlbXB0OyBhYm9ydFxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJ5RnVuYyA9PSBudWxsIHx8IChhd2FpdCB0aGlzLnJldHJ5RnVuYyhyZXEsIHJlc3BvbnNlLCBhdHRlbXB0KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUFmdGVyKSA9PT0gXCJzdHJpbmdcIiAmJiByZXRyeUFmdGVyLm1hdGNoKC9eWzEtOV1bMC05XSokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJzZUludChyZXRyeUFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhbGwgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGVycm9yLnN0YWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBieSBzZW5kaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgIT0gbnVsbCwgXCJyZXF1ZXN0IGhhcyBub3QgYmVlbiBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5jYW5jZWxcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gZmV0Y2hTaWduYWxzLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKCFzaWduYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGZXRjaFJlcXVlc3RdXSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlZGlyZWN0aW9uXG4gICAgICogIHRvICUlbG9jYXRpb24lJS5cbiAgICAgKi9cbiAgICByZWRpcmVjdChsb2NhdGlvbikge1xuICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRpb25zXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYXRpb24uc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIERvbid0IGFsbG93IHJlZGlyZWN0aW5nOlxuICAgICAgICAvLyAtIG5vbi1HRVQgcmVxdWVzdHNcbiAgICAgICAgLy8gLSBkb3duZ3JhZGluZyB0aGUgc2VjdXJpdHkgKGUuZy4gaHR0cHMgPT4gaHR0cClcbiAgICAgICAgLy8gLSB0byBub24tSFRUUCAob3Igbm9uLUhUVFBTKSBwcm90b2NvbHMgW3RoaXMgY291bGQgYmUgcmVsYXhlZD9dXG4gICAgICAgIGFzc2VydCh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiAoY3VycmVudCAhPT0gXCJodHRwc1wiIHx8IHRhcmdldCAhPT0gXCJodHRwXCIpICYmIGxvY2F0aW9uLm1hdGNoKC9eaHR0cHM/Oi8pLCBgdW5zdXBwb3J0ZWQgcmVkaXJlY3RgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGByZWRpcmVjdCgke3RoaXMubWV0aG9kfSAke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gPT4gJHtKU09OLnN0cmluZ2lmeShsb2NhdGlvbil9KWBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyByZXF1ZXN0LCB3aXRoIGEgbmV3IFVSTFxuICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KGxvY2F0aW9uKTtcbiAgICAgICAgcmVxLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIHJlcS5hbGxvd0d6aXAgPSB0aGlzLmFsbG93R3ppcDtcbiAgICAgICAgcmVxLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIHJlcS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgcmVxLiNib2R5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICAvLyBEbyBub3QgZm9yd2FyZCBjcmVkZW50aWFscyB1bmxlc3Mgb24gdGhlIHNhbWUgZG9tYWluOyBvbmx5IGFic29sdXRlXG4gICAgICAgIC8vcmVxLmFsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgLy8gcGF0aHMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ7IG1heSB3YW50IGEgd2F5IHRvIHNwZWNpZnkgdG8gZm9yd2FyZD9cbiAgICAgICAgLy9zZXRTdG9yZShyZXEuI3Byb3BzLCBcImNyZWRzXCIsIGdldFN0b3JlKHRoaXMuI3Byb3MsIFwiY3JlZHNcIikpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IGNvcHkgb2YgdGhpcyByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBGZXRjaFJlcXVlc3QodGhpcy51cmwpO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgbWV0aG9kXCIgKGkuZS4gbnVsbClcbiAgICAgICAgY2xvbmUuI21ldGhvZCA9IHRoaXMuI21ldGhvZDtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGJvZHlcIiB3aXRoIHR5cGUsIGNvcHlpbmcgdGhlIFVpbnQ4QXJyYXkgaXMgcHJlc2VudFxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgY2xvbmUuI2JvZHkgPSB0aGlzLiNib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgaGVhZGVyc1wiXG4gICAgICAgIGNsb25lLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIC8vIENyZWRlbnRpYWxzIGlzIHJlYWRvbmx5LCBzbyB3ZSBjb3B5IGludGVybmFsbHlcbiAgICAgICAgY2xvbmUuI2NyZWRzID0gdGhpcy4jY3JlZHM7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICBpZiAodGhpcy5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI3ByZWZsaWdodCA9IHRoaXMuI3ByZWZsaWdodDtcbiAgICAgICAgY2xvbmUuI3Byb2Nlc3MgPSB0aGlzLiNwcm9jZXNzO1xuICAgICAgICBjbG9uZS4jcmV0cnkgPSB0aGlzLiNyZXRyeTtcbiAgICAgICAgY2xvbmUuI3Rocm90dGxlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jdGhyb3R0bGUpO1xuICAgICAgICBjbG9uZS4jZ2V0VXJsRnVuYyA9IHRoaXMuI2dldFVybEZ1bmM7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIExvY2tzIGFsbCBzdGF0aWMgY29uZmlndXJhdGlvbiBmb3IgZ2F0ZXdheXMgYW5kIEZldGNoR2V0VXJsRnVuY1xuICAgICAqICByZWdpc3RyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGxvY2tDb25maWcoKSB7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0R2F0ZXdheShzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHYXRld2F5KHNjaGVtZSwgZnVuYykge1xuICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGludGVyY2VwdCAke3NjaGVtZX07IHVzZSByZWdpc3RlckdldFVybGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdldFVybChnZXRVcmwpIHtcbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRHZXRVcmxGdW5jID0gZ2V0VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGdldFVybCBmdW5jdGlvbiB0aGF0IGZldGNoZXMgY29udGVudCBmcm9tIEhUVFAgYW5kXG4gICAgICogIEhUVFBTIFVSTHMuXG4gICAgICpcbiAgICAgKiAgVGhlIGF2YWlsYWJsZSAlJW9wdGlvbnMlJSBhcmUgZGVwZW5kZW50IG9uIHRoZSBwbGF0Zm9ybVxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IGlzIHVzZWZ1bFxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcbiAgICAgKiAgY29udGVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVHZXRVcmwob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gXCJmZXRjaFwiIGRhdGEgVVJJcy5cbiAgICAgKlxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XG4gICAgICogIGRhdGEgVVJJcywgc28gaXQgaXMgbm90IG5lY2Vzc2FyeSB0byByZWdpc3RlciBpdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XG4gICAgICogIGJlIHVzZWZ1bCBpbiBhIHdyYXBwZXIgdG8gcGVyZm9tIGN1c3RvbSBkYXRhIFVSSSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFHYXRld2F5RnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZmV0Y2ggSVBGUyAodW52YWxpZGF0ZWQpIGZyb21cbiAgICAgKiAgYSBjdXN0b20gZ2F0ZXdheSBiYXNlVXJsLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IElQRlMgZ2F0ZXdheSB1c2VkIGludGVybmFsbHkgaXNcbiAgICAgKiAgYGBcImh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy9cImBgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xuICAgICAgICByZXR1cm4gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpO1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFRoZSByZXNwb25zZSBmb3IgYSBGZXRjaFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlc3BvbnNlIHtcbiAgICAjc3RhdHVzQ29kZTtcbiAgICAjc3RhdHVzTWVzc2FnZTtcbiAgICAjaGVhZGVycztcbiAgICAjYm9keTtcbiAgICAjcmVxdWVzdDtcbiAgICAjZXJyb3I7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVzcG9uc2Ugc3RhdHVzPSR7dGhpcy5zdGF0dXNDb2RlfSBib2R5PSR7dGhpcy4jYm9keSA/IGhleGxpZnkodGhpcy4jYm9keSkgOiBcIm51bGxcIn0+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzQ29kZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c0NvZGU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNNZXNzYWdlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzTWVzc2FnZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgaGVhZGVycy4gQWxsIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgb3IgYGBudWxsYGAgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5IGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcsIG9yIHRoZSBlbXB0eVxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIFVURi04IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGJvZHlUZXh0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keVRleHRcIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBKU09OLWVuY29kZWQgZGF0YVxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keUpzb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHlUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keUpzb25cIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5LCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgoYWNjdW0sIGspID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2sudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcoaGVhZGVyc1trXSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy4jYm9keSA9ICgoYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShib2R5KSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcbiAgICAgICAgdGhpcy4jZXJyb3IgPSB7IG1lc3NhZ2U6IFwiXCIgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFJlc3BvbnNlIHdpdGggbWF0Y2hpbmcgaGVhZGVycyBhbmQgYm9keSwgYnV0IHdpdGhcbiAgICAgKiAgYW4gZXJyb3Igc3RhdHVzIGNvZGUgKGkuZS4gNTk5KSBhbmQgJSVtZXNzYWdlJSUgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXG4gICAgICovXG4gICAgbWFrZVNlcnZlckVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIHN0YXR1c01lc3NhZ2UsIHRoaXMuaGVhZGVycywgdGhpcy5ib2R5LCB0aGlzLiNyZXF1ZXN0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgY2FsbGVkIHdpdGhpbiBhIFtyZXF1ZXN0LnByb2Nlc3NGdW5jXShGZXRjaFJlcXVlc3QtcHJvY2Vzc0Z1bmMpXG4gICAgICogIGNhbGwsIGNhdXNlcyB0aGUgcmVxdWVzdCB0byByZXRyeSBhcyBpZiB0aHJvdHRsZWQgZm9yICUlc3RhbGwlJVxuICAgICAqICBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGhyb3dUaHJvdHRsZUVycm9yKG1lc3NhZ2UsIHN0YWxsKSB7XG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFsbCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFsbCkgJiYgc3RhbGwgPj0gMCwgXCJpbnZhbGlkIHN0YWxsIHRpbWVvdXRcIiwgXCJzdGFsbFwiLCBzdGFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc3RhbGwsIHRocm90dGxlOiB0cnVlIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIHZhbHVlIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlcXVlc3QgbWFkZSBmb3IgdGhpcyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHsgcmV0dXJuIHRoaXMuI3JlcXVlc3Q7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxuICAgICAqL1xuICAgIG9rKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cbiAgICAgKi9cbiAgICBhc3NlcnRPaygpIHtcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgc2VydmVyIHJlc3BvbnNlICR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0VXJsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgcmVxdWVzdFVybCA9IHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlQm9keSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keSA9IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogKHRoaXMucmVxdWVzdCB8fCBcInVua25vd24gcmVxdWVzdFwiKSwgcmVzcG9uc2U6IHRoaXMsIGVycm9yLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsIHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVN0YXR1czogYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiB1bnBlcmNlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUucmVwbGFjZSgvJShbMC05YS1mXVswLTlhLWZdKS9naSwgKGFsbCwgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWNvZGVCYXNlNjQiLCJlbmNvZGVCYXNlNjQiLCJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidG9VdGY4Qnl0ZXMiLCJ0b1V0ZjhTdHJpbmciLCJjcmVhdGVHZXRVcmwiLCJNQVhfQVRURU1QVFMiLCJTTE9UX0lOVEVSVkFMIiwiZGVmYXVsdEdldFVybEZ1bmMiLCJyZURhdGEiLCJSZWdFeHAiLCJyZUlwZnMiLCJsb2NrZWQiLCJkYXRhR2F0ZXdheUZ1bmMiLCJ1cmwiLCJzaWduYWwiLCJtYXRjaCIsIkVycm9yIiwiRmV0Y2hSZXNwb25zZSIsInVucGVyY2VudCIsImVycm9yIiwiRmV0Y2hSZXF1ZXN0IiwiZ2V0SXBmc0dhdGV3YXlGdW5jIiwiYmFzZVVybCIsImdhdGV3YXlJcGZzIiwiR2F0ZXdheXMiLCJmZXRjaFNpZ25hbHMiLCJXZWFrTWFwIiwiRmV0Y2hDYW5jZWxTaWduYWwiLCJsaXN0ZW5lcnMiLCJjYW5jZWxsZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVlc3QiLCJzZXQiLCJsaXN0ZW5lciIsInNldFRpbWVvdXQiLCJhZGRMaXN0ZW5lciIsIm9wZXJhdGlvbiIsInB1c2giLCJjaGVja1NpZ25hbCIsImFsbG93SW5zZWN1cmUiLCJnemlwIiwiaGVhZGVycyIsIm1ldGhvZCIsInRpbWVvdXQiLCJib2R5IiwiYm9keVR5cGUiLCJjcmVkcyIsInByZWZsaWdodCIsInByb2Nlc3MiLCJyZXRyeSIsInRocm90dGxlIiwiZ2V0VXJsRnVuYyIsIlN0cmluZyIsIlVpbnQ4QXJyYXkiLCJ1bmRlZmluZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzQm9keSIsInRvVXBwZXJDYXNlIiwiT2JqZWN0IiwiYXNzaWduIiwiYWxsb3dHemlwIiwibGVuZ3RoIiwiZ2V0SGVhZGVyIiwia2V5IiwidG9Mb3dlckNhc2UiLCJzZXRIZWFkZXIiLCJ2YWx1ZSIsImNsZWFySGVhZGVycyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwia2V5cyIsImluZGV4IiwibmV4dCIsImRvbmUiLCJjcmVkZW50aWFscyIsInNldENyZWRlbnRpYWxzIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiIsInByZWZsaWdodEZ1bmMiLCJwcm9jZXNzRnVuYyIsInJldHJ5RnVuYyIsInNsb3RJbnRlcnZhbCIsIm1heEF0dGVtcHRzIiwidG9TdHJpbmciLCJzZXRUaHJvdHRsZVBhcmFtcyIsInBhcmFtcyIsInNlbmQiLCJhdHRlbXB0IiwiZXhwaXJlcyIsImRlbGF5IiwiX3JlcXVlc3QiLCJfcmVzcG9uc2UiLCJtYWtlU2VydmVyRXJyb3IiLCJnZXRUaW1lIiwicmVhc29uIiwid2FpdCIsInJlcSIsImNsb25lIiwic2NoZW1lIiwic3BsaXQiLCJyZXN1bHQiLCJyZXNwb25zZSIsInN0YWxsIiwiYXNzZXJ0T2siLCJyZXNwIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJsb2NhdGlvbiIsInJlZGlyZWN0IiwicmV0cnlBZnRlciIsIk1hdGgiLCJ0cnVuYyIsInJhbmRvbSIsInBvdyIsInBhcnNlSW50IiwiY2FuY2VsIiwiZ2V0IiwiY3VycmVudCIsInRhcmdldCIsImxvY2tDb25maWciLCJnZXRHYXRld2F5IiwicmVnaXN0ZXJHYXRld2F5IiwiZnVuYyIsInJlZ2lzdGVyR2V0VXJsIiwiZ2V0VXJsIiwiY3JlYXRlR2V0VXJsRnVuYyIsIm9wdGlvbnMiLCJjcmVhdGVEYXRhR2F0ZXdheSIsImNyZWF0ZUlwZnNHYXRld2F5RnVuYyIsImJvZHlUZXh0IiwiaW5mbyIsImJvZHlKc29uIiwicGFyc2UiLCJyZWR1Y2UiLCJhY2N1bSIsImsiLCJtZXNzYWdlIiwidGhyb3dUaHJvdHRsZUVycm9yIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwib2siLCJyZXF1ZXN0VXJsIiwicmVzcG9uc2VCb2R5IiwiZSIsInJlc3BvbnNlU3RhdHVzIiwiRGF0ZSIsInJlcGxhY2UiLCJhbGwiLCJjb2RlIiwiZnJvbUNoYXJDb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */ \n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile(Zeros.length < 80){\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while(result.length < decimals){\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = BN_1 << width - BN_1;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        } else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    } else {\n        const limit = BN_1 << width;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= 0 && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        val = (val % limit + limit) % limit & limit - BN_1;\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof value === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof value === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n        // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = match[1] !== \"u\";\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue)=>{\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return {\n        signed,\n        width,\n        decimals,\n        name\n    };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return negative + str;\n    }\n    // Pad out to the whole component (including a whole digit)\n    while(str.length <= decimals){\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while(str[0] === \"0\" && str[1] !== \".\"){\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while(str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\"){\n        str = str.substring(0, str.length - 1);\n    }\n    return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */ class FixedNumber {\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */ constructor(guard, value, format){\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            format: format.name,\n            _value\n        });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */ get signed() {\n        return this.#format.signed;\n    }\n    /**\n     *  The number of bits available to store the value.\n     */ get width() {\n        return this.#format.width;\n    }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */ get decimals() {\n        return this.#format.decimals;\n    }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */ get value() {\n        return this.#val;\n    }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */ val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */ addUnsafe(other) {\n        return this.#add(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ add(other) {\n        return this.#add(other, \"add\");\n    }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */ subUnsafe(other) {\n        return this.#sub(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ sub(other) {\n        return this.#sub(other, \"sub\");\n    }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */ mulUnsafe(other) {\n        return this.#mul(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ mul(other) {\n        return this.#mul(other, \"mul\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */ mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % this.#tens === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ divUnsafe(other) {\n        return this.#div(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ div(other) {\n        return this.#div(other, \"div\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */ divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(other);\n        const value = this.#val * this.#tens;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % other.#val === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */ cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        } else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */ eq(other) {\n        return this.cmp(other) === 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */ lt(other) {\n        return this.cmp(other) < 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */ lte(other) {\n        return this.cmp(other) <= 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */ gt(other) {\n        return this.cmp(other) > 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */ gte(other) {\n        return this.cmp(other) >= 0;\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */ round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = value / tens * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */ isZero() {\n        return this.#val === BN_0;\n    }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */ isNegative() {\n        return this.#val < BN_0;\n    }\n    /**\n     *  Returns the string representation of %%this%%.\n     */ toString() {\n        return this._value;\n    }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */ toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */ toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */ static fromValue(_value, _decimals, _format) {\n        const decimals = _decimals == null ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\",\n                fault: \"underflow\",\n                value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */ static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = match[2] || \"0\", decimal = match[3] || \"\";\n        // Pad out the decimals\n        while(decimal.length < format.decimals){\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\",\n            fault: \"underflow\",\n            value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */ static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n} //const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n //const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n //console.log(f1.divSignal(f2));\n //const BUMP = FixedNumber.from(\"0.5\");\n //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDb0M7QUFDK0I7QUFDUTtBQUN6QjtBQUNuRCxNQUFNVSxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLE9BQU9ILE9BQU87QUFDcEIsTUFBTUksU0FBUyxDQUFDO0FBQ2hCLDhDQUE4QztBQUM5QyxJQUFJQyxRQUFRO0FBQ1osTUFBT0EsTUFBTUMsTUFBTSxHQUFHLEdBQUk7SUFDdEJELFNBQVNBO0FBQ2I7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0UsUUFBUUMsUUFBUTtJQUNyQixJQUFJQyxTQUFTSjtJQUNiLE1BQU9JLE9BQU9ILE1BQU0sR0FBR0UsU0FBVTtRQUM3QkMsVUFBVUE7SUFDZDtJQUNBLE9BQU9ULE9BQU8sTUFBTVMsT0FBT0MsU0FBUyxDQUFDLEdBQUdGO0FBQzVDO0FBQ0EsU0FBU0csV0FBV0MsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDbkMsTUFBTUMsUUFBUWYsT0FBT2EsT0FBT0UsS0FBSztJQUNqQyxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZixNQUFNQyxRQUFTZixRQUFTYSxRQUFRYjtRQUNoQ1osa0RBQU1BLENBQUN3QixVQUFVLFFBQVNGLE9BQU8sQ0FBQ0ssU0FBU0wsTUFBTUssT0FBUSxZQUFZLGlCQUFpQjtZQUNsRkMsV0FBV0o7WUFBUUssT0FBTztZQUFZQyxPQUFPUjtRQUNqRDtRQUNBLElBQUlBLE1BQU1YLE1BQU07WUFDWlcsTUFBTWpCLG1EQUFRQSxDQUFDQywrQ0FBSUEsQ0FBQ2dCLEtBQUtHLFFBQVFBO1FBQ3JDLE9BQ0s7WUFDREgsTUFBTSxDQUFDakIsbURBQVFBLENBQUNDLCtDQUFJQSxDQUFDLENBQUNnQixLQUFLRyxRQUFRQTtRQUN2QztJQUNK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b2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2ZpeGVkbnVtYmVyLmpzPzQ1NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlICoqRml4ZWROdW1iZXIqKiBjbGFzcyBwZXJtaXRzIHVzaW5nIHZhbHVlcyB3aXRoIGRlY2ltYWwgcGxhY2VzLFxuICogIHVzaW5nIGZpeGVkLXBvbnQgbWF0aC5cbiAqXG4gKiAgRml4ZWQtcG9pbnQgbWF0aCBpcyBzdGlsbCBiYXNlZCBvbiBpbnRlZ2VycyB1bmRlci10aGUtaG9vZCwgYnV0IHVzZXMgYW5cbiAqICBpbnRlcm5hbCBvZmZzZXQgdG8gc3RvcmUgZnJhY3Rpb25hbCBjb21wb25lbnRzIGJlbG93LCBhbmQgZWFjaCBvcGVyYXRpb25cbiAqICBjb3JyZWN0cyBmb3IgdGhpcyBhZnRlciBlYWNoIG9wZXJhdGlvbi5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZml4ZWQtcG9pbnQtbWF0aDpGaXhlZC1Qb2ludCBNYXRocyAgW2Fib3V0LWZpeGVkLXBvaW50LW1hdGhdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0UHJpdmF0ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGZyb21Ud29zLCBtYXNrLCB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuY29uc3QgQk5fTjEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl81ID0gQmlnSW50KDUpO1xuY29uc3QgX2d1YXJkID0ge307XG4vLyBDb25zdGFudCB0byBwdWxsIHplcm9zIGZyb20gZm9yIG11bHRpcGxpZXJzXG5sZXQgWmVyb3MgPSBcIjAwMDBcIjtcbndoaWxlIChaZXJvcy5sZW5ndGggPCA4MCkge1xuICAgIFplcm9zICs9IFplcm9zO1xufVxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuZnVuY3Rpb24gZ2V0VGVucyhkZWNpbWFscykge1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIHJlc3VsdCArPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoXCIxXCIgKyByZXN1bHQuc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlKHZhbCwgZm9ybWF0LCBzYWZlT3ApIHtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChmb3JtYXQud2lkdGgpO1xuICAgIGlmIChmb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8IHdpZHRoKTtcbiAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICB2YWwgPSAoKCh2YWwgJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCkgJiAobGltaXQgLSBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldEZvcm1hdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgfVxuICAgIGxldCBzaWduZWQgPSB0cnVlO1xuICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYmplY3RcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlO1xuICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodltrZXldKSA9PT0gdHlwZSwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2W2tleV0pO1xuICAgICAgICAgICAgcmV0dXJuIHZba2V5XTtcbiAgICAgICAgfTtcbiAgICAgICAgc2lnbmVkID0gY2hlY2soXCJzaWduZWRcIiwgXCJib29sZWFuXCIsIHNpZ25lZCk7XG4gICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG4gICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KCh3aWR0aCAlIDgpID09PSAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNpbWFscyA8PSA4MCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIGRlY2ltYWxzICh0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICBjb25zdCBuYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgIHJldHVybiB7IHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzLCBuYW1lIH07XG59XG5mdW5jdGlvbiB0b1N0cmluZyh2YWwsIGRlY2ltYWxzKSB7XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAodmFsIDwgQk5fMCkge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB2YWwgKj0gQk5fTjE7XG4gICAgfVxuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAvLyBObyBkZWNpbWFsIHBvaW50IGZvciB3aG9sZSB2YWx1ZXNcbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG4gICAgfVxuICAgIC8vIFBhZCBvdXQgdG8gdGhlIHdob2xlIGNvbXBvbmVudCAoaW5jbHVkaW5nIGEgd2hvbGUgZGlnaXQpXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgc3RyID0gWmVyb3MgKyBzdHI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgZGVjaW1hbCBwb2ludFxuICAgIGNvbnN0IGluZGV4ID0gc3RyLmxlbmd0aCAtIGRlY2ltYWxzO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgXCIuXCIgKyBzdHIuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAvLyBUcmltIHRoZSB3aG9sZSBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXG4gICAgd2hpbGUgKHN0clswXSA9PT0gXCIwXCIgJiYgc3RyWzFdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyBUcmltIHRoZSBkZWNpbWFsIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gXCIwXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAyXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAobmVnYXRpdmUgKyBzdHIpO1xufVxuLyoqXG4gKiAgQSBGaXhlZE51bWJlciByZXByZXNlbnRzIGEgdmFsdWUgb3ZlciBpdHMgW1tGaXhlZEZvcm1hdF1dXG4gKiAgYXJpdGhtZXRpYyBmaWVsZC5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIG1hdGgsIGxvc3NsZXNzbHksIG9uXG4gKiAgdmFsdWVzIHdoaWNoIGhhdmUgZGVjbWlhbCBwbGFjZXMuXG4gKlxuICogIEEgRml4ZWROdW1iZXIgaGFzIGEgZml4ZWQgYml0LXdpZHRoIHRvIHN0b3JlIHZhbHVlcyBpbiwgYW5kIHN0b3JlcyBhbGxcbiAqICB2YWx1ZXMgaW50ZXJuYWxseSBieSBtdWx0aXBseWluZyB0aGUgdmFsdWUgYnkgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZlxuICogICUlZGVjaW1hbHMlJS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBncm93IHRvbyBoaWdoIChjbG9zZSB0b1xuICogIHBvc2l0aXZlIGluZmluaXR5KSBvciB0b28gbG93IChjbG9zZSB0byBuZWdhdGl2ZSBpbmZpbml0eSksIHRoZSB2YWx1ZVxuICogIGlzIHNhaWQgdG8gLy9vdmVyZmxvdy8vLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYW4gOC1iaXQgc2lnbmVkIHZhbHVlLCB3aXRoIDAgZGVjaW1hbHMgbWF5IG9ubHkgYmUgd2l0aGluXG4gKiAgdGhlIHJhbmdlIGBgLTEyOGBgIHRvIGBgMTI3YGA7IHNvIGBgLTEyOCAtIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWVcbiAqICBgYDEyN2BgLiBMaWtld2lzZSwgYGAxMjcgKyAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lIGBgLTEyN2BgLlxuICpcbiAqICBNYW55IG9wZXJhdGlvbiBoYXZlIGEgbm9ybWFsIGFuZCAvL3Vuc2FmZS8vIHZhcmlhbnQuIFRoZSBub3JtYWwgdmFyaWFudFxuICogIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gYW55IG92ZXJmbG93LCB3aGlsZSB0aGUgLy91bnNhZmUvL1xuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBhbGxvdyBvdmVyZmxvdywgY29ycnVwdGluZyBpdHMgdmFsdWUgdmFsdWUuXG4gKlxuICogIElmIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0aGF0IGNhdXNlIGEgdmFsdWUgdG8gYmVjb21lIHRvbyBzbWFsbFxuICogIChjbG9zZSB0byB6ZXJvKSwgdGhlIHZhbHVlIGxvc2VzIHByZWNpc29uIGFuZCBpcyBzYWlkIHRvIC8vdW5kZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmb3JtYXQ7XG4gICAgI2Zvcm1hdDtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcbiAgICAjdmFsO1xuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxuICAgICN0ZW5zO1xuICAgIC8qKlxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbHVlO1xuICAgIC8vIFVzZSB0aGlzIHdoZW4gY2hhbmdpbmcgdGhpcyBmaWxlIHRvIGdldCBzb21lIHR5cGluZyBpbmZvLFxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRml4ZWROdW1iZXJcIik7XG4gICAgICAgIHRoaXMuI3ZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLiNmb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZm9ybWF0OiBmb3JtYXQubmFtZSwgX3ZhbHVlIH0pO1xuICAgICAgICB0aGlzLiN0ZW5zID0gZ2V0VGVucyhmb3JtYXQuZGVjaW1hbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdHJ1ZSwgbmVnYXRpdmUgdmFsdWVzIGFyZSBwZXJtaXR0ZWQsIG90aGVyd2lzZSBvbmx5XG4gICAgICogIHBvc2l0aXZlIHZhbHVlcyBhbmQgemVybyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmVkKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LnNpZ25lZDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJpdHMgYXZhaWxhYmxlIHRvIHN0b3JlIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQud2lkdGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpbiB0aGUgZml4ZWQtcG9pbnQgYXJpdGhtZW50IGZpZWxkLlxuICAgICAqL1xuICAgIGdldCBkZWNpbWFscygpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5kZWNpbWFsczsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgYXMgYW4gaW50ZWdlciwgYmFzZWQgb24gdGhlIHNtYWxsZXN0IHVuaXQgdGhlXG4gICAgICogIFtbZGVjaW1hbHNdXSBhbGxvdy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWw7IH1cbiAgICAjY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRoaXMuI3RlbnMpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIG11bFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gdGhpcy4jdGVucywgXCJtdWxTaWduYWxcIik7XG4gICAgfVxuICAgICNkaXYobywgc2FmZU9wKSB7XG4gICAgICAgIGFzc2VydChvLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKSAvIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2VW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2KG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIsIFwiZGl2XCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIHVuZGVyZmxvd1xuICAgICAqICAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZTaWduYWwob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xuICAgICAqICBib3RoIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnZhbHVlLCBiID0gb3RoZXIudmFsdWU7XG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbW5wYXJlXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBsYXJnZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXG4gICAgICovXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXG4gICAgICAgIGlmIChkZWNpbWFscyA+PSB0aGlzLmRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBkZWNpbWFscztcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xuICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBlcXVhbCB0byBgYDBgYC5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxuICAgICAqL1xuICAgIGlzTmVnYXRpdmUoKSB7IHJldHVybiAodGhpcy4jdmFsIDwgQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZsb2F0IGFwcHJveGltYXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAgY2FuIG9ubHkgcmV0dXJuIGFuIGFwcHJveGltYXRpb24gYW5kIG1vc3QgdmFsdWVzIHdpbGwgY29udGFpblxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcbiAgICAgKiAgaXRzIGZpZWxkIHNldCB0byAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxuICAgICAqICAlJWRlY2ltYWwlJSBwbGFjZXMgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcbiAgICAgKiAgZm9yICUlZGVjaW1hbHMlJSkgY2Fubm90IGZpdCBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93XG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUoX3ZhbHVlLCBfZGVjaW1hbHMsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6IGdldE51bWJlcihfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGVjaW1hbHMgLSBmb3JtYXQuZGVjaW1hbHM7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgICAgIGFzc2VydCgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcbiAgICAgICAgd2hpbGUgKGRlY2ltYWwubGVuZ3RoIDwgZm9ybWF0LmRlY2ltYWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHByZWNpc2lvbiBpcyBzYWZlXG4gICAgICAgIGFzc2VydChkZWNpbWFsLnN1YnN0cmluZyhmb3JtYXQuZGVjaW1hbHMpLm1hdGNoKC9eMCokLyksIFwidG9vIG1hbnkgZGVjaW1hbHMgZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21TdHJpbmdcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBwYWRkaW5nXG4gICAgICAgIGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cmluZygwLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChtYXRjaFsxXSArIHdob2xlICsgZGVjaW1hbCk7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tU3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uXG4gICAgICogICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUgZHVlIHRvIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnRQcml2YXRlIiwiZ2V0QmlnSW50IiwiZ2V0TnVtYmVyIiwiZnJvbVR3b3MiLCJtYXNrIiwidG9CaWdJbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiQk5fTjEiLCJCaWdJbnQiLCJCTl8wIiwiQk5fMSIsIkJOXzUiLCJfZ3VhcmQiLCJaZXJvcyIsImxlbmd0aCIsImdldFRlbnMiLCJkZWNpbWFscyIsInJlc3VsdCIsInN1YnN0cmluZyIsImNoZWNrVmFsdWUiLCJ2YWwiLCJmb3JtYXQiLCJzYWZlT3AiLCJ3aWR0aCIsInNpZ25lZCIsImxpbWl0Iiwib3BlcmF0aW9uIiwiZmF1bHQiLCJ2YWx1ZSIsImdldEZvcm1hdCIsIm1hdGNoIiwicGFyc2VJbnQiLCJ2IiwiY2hlY2siLCJrZXkiLCJ0eXBlIiwiZGVmYXVsdFZhbHVlIiwibmFtZSIsIlN0cmluZyIsInRvU3RyaW5nIiwibmVnYXRpdmUiLCJzdHIiLCJpbmRleCIsIkZpeGVkTnVtYmVyIiwidGVucyIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJfdmFsdWUiLCJjaGVja0Zvcm1hdCIsIm90aGVyIiwiYWRkIiwibyIsImFkZFVuc2FmZSIsInN1YiIsInN1YlVuc2FmZSIsIm11bCIsIm11bFVuc2FmZSIsIm11bFNpZ25hbCIsImRpdiIsImRpdlVuc2FmZSIsImRpdlNpZ25hbCIsImNtcCIsImEiLCJiIiwiZGVsdGEiLCJlcSIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJmbG9vciIsImNlaWxpbmciLCJyb3VuZCIsImJ1bXAiLCJpc1plcm8iLCJpc05lZ2F0aXZlIiwidG9VbnNhZmVGbG9hdCIsInBhcnNlRmxvYXQiLCJ0b0Zvcm1hdCIsImZyb21TdHJpbmciLCJmcm9tVmFsdWUiLCJfZGVjaW1hbHMiLCJfZm9ybWF0Iiwid2hvbGUiLCJkZWNpbWFsIiwiZnJvbUJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/geturl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: () => (/* binding */ createGetUrl),\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\n\n\n\n/**\n *  @_ignore:\n */ function createGetUrl(options) {\n    async function getUrl(req, signal) {\n        // Make sure we weren't cancelled before sending\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(signal == null || !signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: {\n                protocol\n            },\n            operation: \"request\"\n        });\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        const method = req.method;\n        const headers = Object.assign({}, req.headers);\n        const reqOptions = {\n            method,\n            headers\n        };\n        if (options) {\n            if (options.agent) {\n                reqOptions.agent = options.agent;\n            }\n        }\n        // Create a Node-specific AbortController, if available\n        let abort = null;\n        try {\n            abort = new AbortController();\n            reqOptions.abort = abort.signal;\n        } catch (e) {\n            console.log(e);\n        }\n        const request = (protocol === \"http\" ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__).request(req.url, reqOptions);\n        request.setTimeout(req.timeout);\n        const body = req.body;\n        if (body) {\n            request.write(Buffer.from(body));\n        }\n        request.end();\n        return new Promise((resolve, reject)=>{\n            if (signal) {\n                signal.addListener(()=>{\n                    if (abort) {\n                        abort.abort();\n                    }\n                    reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"request cancelled\", \"CANCELLED\"));\n                });\n            }\n            request.on(\"timeout\", ()=>{\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"request timeout\", \"TIMEOUT\"));\n            });\n            request.once(\"response\", (resp)=>{\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name)=>{\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {});\n                let body = null;\n                //resp.setEncoding(\"utf8\");\n                resp.on(\"data\", (chunk)=>{\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                    if (body == null) {\n                        body = chunk;\n                    } else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n                resp.on(\"end\", ()=>{\n                    try {\n                        if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                            body = (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.getBytes)((0,zlib__WEBPACK_IMPORTED_MODULE_2__.gunzipSync)(body));\n                        }\n                        resolve({\n                            statusCode,\n                            statusMessage,\n                            headers,\n                            body\n                        });\n                    } catch (error) {\n                        reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"bad response data\", \"SERVER_ERROR\", {\n                            request: req,\n                            info: {\n                                response: resp,\n                                error\n                            }\n                        }));\n                    }\n                });\n                resp.on(\"error\", (error)=>{\n                    //@TODO: Should this just return nornal response with a server error?\n                    error.response = {\n                        statusCode,\n                        statusMessage,\n                        headers,\n                        body\n                    };\n                    reject(error);\n                });\n            });\n            request.on(\"error\", (error)=>{\n                reject(error);\n            });\n        });\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */ async function getUrl(req, signal) {\n    return defaultGetUrl(req, signal);\n} //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0I7QUFDRTtBQUNRO0FBQ2M7QUFDWDtBQUNyQzs7Q0FFQyxHQUNNLFNBQVNNLGFBQWFDLE9BQU87SUFDaEMsZUFBZUMsT0FBT0MsR0FBRyxFQUFFQyxNQUFNO1FBQzdCLGdEQUFnRDtRQUNoRFAsa0RBQU1BLENBQUNPLFVBQVUsUUFBUSxDQUFDQSxPQUFPQyxTQUFTLEVBQUUsb0NBQW9DO1FBQ2hGLE1BQU1DLFdBQVdILElBQUlJLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLFdBQVc7UUFDbERaLGtEQUFNQSxDQUFDUyxhQUFhLFVBQVVBLGFBQWEsU0FBUyxDQUFDLHFCQUFxQixFQUFFQSxTQUFTLENBQUMsRUFBRSx5QkFBeUI7WUFDN0dJLE1BQU07Z0JBQUVKO1lBQVM7WUFDakJLLFdBQVc7UUFDZjtRQUNBZCxrREFBTUEsQ0FBQ1MsYUFBYSxXQUFXLENBQUNILElBQUlTLFdBQVcsSUFBSVQsSUFBSVUsMkJBQTJCLEVBQUUsK0NBQStDLHlCQUF5QjtZQUN4SkYsV0FBVztRQUNmO1FBQ0EsTUFBTUcsU0FBU1gsSUFBSVcsTUFBTTtRQUN6QixNQUFNQyxVQUFVQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZCxJQUFJWSxPQUFPO1FBQzdDLE1BQU1HLGFBQWE7WUFBRUo7WUFBUUM7UUFBUTtRQUNyQyxJQUFJZCxTQUFTO1lBQ1QsSUFBSUEsUUFBUWtCLEtBQUssRUFBRTtnQkFDZkQsV0FBV0MsS0FBSyxHQUFHbEIsUUFBUWtCLEtBQUs7WUFDcEM7UUFDSjtRQUNBLHVEQUF1RDtRQUN2RCxJQUFJQyxRQUFRO1FBQ1osSUFBSTtZQUNBQSxRQUFRLElBQUlDO1lBQ1pILFdBQVdFLEtBQUssR0FBR0EsTUFBTWhCLE1BQU07UUFDbkMsRUFDQSxPQUFPa0IsR0FBRztZQUNOQyxRQUFRQyxHQUFHLENB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QUFhLENBQUM7QUFDcEM7O0NBRUMsR0FDTSxlQUFlRSxPQUFPQyxHQUFHLEVBQUVDLE1BQU07SUFDcEMsT0FBT3NELGNBQWN2RCxLQUFLQztBQUM5QixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwuanM/NGM3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tIFwiaHR0cFwiO1xuaW1wb3J0IGh0dHBzIGZyb20gXCJodHRwc1wiO1xuaW1wb3J0IHsgZ3VuemlwU3luYyB9IGZyb20gXCJ6bGliXCI7XG5pbXBvcnQgeyBhc3NlcnQsIG1ha2VFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdldFVybChvcHRpb25zKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgc2lnbmFsKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB3ZXJlbid0IGNhbmNlbGxlZCBiZWZvcmUgc2VuZGluZ1xuICAgICAgICBhc3NlcnQoc2lnbmFsID09IG51bGwgfHwgIXNpZ25hbC5jYW5jZWxsZWQsIFwicmVxdWVzdCBjYW5jZWxsZWQgYmVmb3JlIHNlbmRpbmdcIiwgXCJDQU5DRUxMRURcIik7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwc1wiLCBgdW5zdXBwb3J0ZWQgcHJvdG9jb2wgJHtwcm90b2NvbH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBpbmZvOiB7IHByb3RvY29sIH0sXG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCAhcmVxLmNyZWRlbnRpYWxzIHx8IHJlcS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24sIFwiaW5zZWN1cmUgYXV0aG9yaXplZCBjb25uZWN0aW9ucyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLmhlYWRlcnMpO1xuICAgICAgICBjb25zdCByZXFPcHRpb25zID0geyBtZXRob2QsIGhlYWRlcnMgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFnZW50KSB7XG4gICAgICAgICAgICAgICAgcmVxT3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgTm9kZS1zcGVjaWZpYyBBYm9ydENvbnRyb2xsZXIsIGlmIGF2YWlsYWJsZVxuICAgICAgICBsZXQgYWJvcnQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWJvcnQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICByZXFPcHRpb25zLmFib3J0ID0gYWJvcnQuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gKChwcm90b2NvbCA9PT0gXCJodHRwXCIpID8gaHR0cCA6IGh0dHBzKS5yZXF1ZXN0KHJlcS51cmwsIHJlcU9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQocmVxLnRpbWVvdXQpO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVxLmJvZHk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKEJ1ZmZlci5mcm9tKGJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwicmVxdWVzdCBjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC5vbihcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJyZXF1ZXN0IHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKFwicmVzcG9uc2VcIiwgKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcC5zdGF0dXNDb2RlIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IHJlc3Auc3RhdHVzTWVzc2FnZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3Qua2V5cyhyZXNwLmhlYWRlcnMgfHwge30pLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcmVzcC5oZWFkZXJzW25hbWVdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy9yZXNwLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgICAgICByZXNwLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JvZHkgPSBuZXcgVWludDhBcnJheShib2R5Lmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCb2R5LnNldChib2R5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvZHkuc2V0KGNodW5rLCBib2R5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gbmV3Qm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3Aub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LWVuY29kaW5nXCJdID09PSBcImd6aXBcIiAmJiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGdldEJ5dGVzKGd1bnppcFN5bmMoYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwiYmFkIHJlc3BvbnNlIGRhdGFcIiwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcSwgaW5mbzogeyByZXNwb25zZTogcmVzcCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL0BUT0RPOiBTaG91bGQgdGhpcyBqdXN0IHJldHVybiBub3JuYWwgcmVzcG9uc2Ugd2l0aCBhIHNlcnZlciBlcnJvcj9cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbihcImVycm9yXCIsIChlcnJvcikgPT4geyByZWplY3QoZXJyb3IpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRVcmw7XG59XG4vLyBAVE9ETzogcmVtb3ZlIGluIHY3OyBwcm92aWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuY29uc3QgZGVmYXVsdEdldFVybCA9IGNyZWF0ZUdldFVybCh7fSk7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIHNpZ25hbCkge1xuICAgIHJldHVybiBkZWZhdWx0R2V0VXJsKHJlcSwgc2lnbmFsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiXSwibmFtZXMiOlsiaHR0cCIsImh0dHBzIiwiZ3VuemlwU3luYyIsImFzc2VydCIsIm1ha2VFcnJvciIsImdldEJ5dGVzIiwiY3JlYXRlR2V0VXJsIiwib3B0aW9ucyIsImdldFVybCIsInJlcSIsInNpZ25hbCIsImNhbmNlbGxlZCIsInByb3RvY29sIiwidXJsIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImluZm8iLCJvcGVyYXRpb24iLCJjcmVkZW50aWFscyIsImFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiIsIm1ldGhvZCIsImhlYWRlcnMiLCJPYmplY3QiLCJhc3NpZ24iLCJyZXFPcHRpb25zIiwiYWdlbnQiLCJhYm9ydCIsIkFib3J0Q29udHJvbGxlciIsImUiLCJjb25zb2xlIiwibG9nIiwicmVxdWVzdCIsInNldFRpbWVvdXQiLCJ0aW1lb3V0IiwiYm9keSIsIndyaXRlIiwiQnVmZmVyIiwiZnJvbSIsImVuZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWRkTGlzdGVuZXIiLCJvbiIsIm9uY2UiLCJyZXNwIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJuYW1lIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwiY2h1bmsiLCJjaGVja1NpZ25hbCIsImVycm9yIiwibmV3Qm9keSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJzZXQiLCJyZXNwb25zZSIsImRlZmF1bHRHZXRVcmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDZ0Q7QUFDSTtBQUNyRCxNQUFNSSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QyxNQUFNRSxXQUFXO0FBQ2pCOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQ25DLE1BQU1DLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsTUFBTUksUUFBUVIsT0FBT1MsVUFBVUosUUFBUTtJQUN2Q1Isa0RBQU1BLENBQUMsU0FBVVcsVUFBV1QsTUFBTSxZQUFZLGlCQUFpQjtRQUMzRFcsV0FBVztRQUFZQyxPQUFPO1FBQVlMLE9BQU9GO0lBQ3JEO0lBQ0EseUNBQXlDO0lBQ3pDLElBQUlFLFNBQVVFLFFBQVFQLE1BQU87UUFDekIsTUFBTVcsT0FBTyxDQUFDWCxRQUFRTyxLQUFJLElBQUtQO1FBQy9CLE9BQU8sQ0FBRSxFQUFDLENBQUVLLFFBQVNNLElBQUcsSUFBS1gsSUFBRztJQUNwQztJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNPLE9BQU9ULE1BQU0sRUFBRUMsTUFBTTtJQUNqQyxJQUFJQyxRQUFRUSxVQUFVVixRQUFRO0lBQzlCLE1BQU1JLFFBQVFSLE9BQU9TLFVBQVVKLFFBQVE7SUFDdkMsTUFBTVUsUUFBU2QsUUFBU08sUUFBUVA7SUFDaEMsSUFBSUssUUFBUVAsTUFBTTtRQUNkTyxRQUFRLENBQUNBO1FBQ1RULGtEQUFNQSxDQUFDUyxTQUFTUyxPQUFPLFdBQVcsaUJBQWlCO1lBQy9DTCxXQUFXO1lBQVVDLE9BQU87WUFBWUwsT0FBT0Y7UUFDbkQ7UUFDQSxNQUFNUSxPQUFPLENBQUNYLFFBQVFPLEtBQUksSUFBS1A7UUFDL0IsT0FBTyxDQUFDLENBQUVLLFFBQVNNLElB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SUFBSSxHQUFHQSxJQUFJWCxPQUFPUSxNQUFNLEVBQUVHLElBQUs7UUFDcEMsTUFBTUMsU0FBU0QsSUFBSTtRQUNuQlgsTUFBTSxDQUFDVyxFQUFFLEdBQUdFLFNBQVNILElBQUliLFNBQVMsQ0FBQ2UsUUFBUUEsU0FBUyxJQUFJO0lBQzVEO0lBQ0EsT0FBT1o7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLFdBQVdqQyxLQUFLO0lBQzVCLElBQUltQixTQUFTOUIsaURBQU9BLENBQUNDLHFEQUFXQSxDQUFDVSxTQUFTQSxRQUFRNEIsVUFBVTVCLFFBQVFnQixTQUFTLENBQUM7SUFDOUUsTUFBT0csT0FBT2UsVUFBVSxDQUFDLEtBQU07UUFDM0JmLFNBQVNBLE9BQU9ILFNBQVMsQ0FBQztJQUM5QjtJQUNBLElBQUlHLFdBQVcsSUFBSTtRQUNmQSxTQUFTO0lBQ2I7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL21hdGhzLmpzP2JjZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuLy9jb25zdCBCTl9NYXgyNTYgPSAoQk5fMSA8PCBCaWdJbnQoMjU2KSkgLSBCTl8xO1xuLy8gSUVFRSA3NTQgc3VwcG9ydCA1My1iaXRzIG9mIG1hbnRpc3NhXG5jb25zdCBtYXhWYWx1ZSA9IDB4MWZmZmZmZmZmZmZmZmY7XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSBmcm9tIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mICUld2lkdGglJVxuICogIGJpdHMgdG8gaXRzIHZhbHVlLlxuICpcbiAqICBJZiB0aGUgaGlnaGVzdCBiaXQgaXMgYGAxYGAsIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBhc3NlcnQoKHZhbHVlID4+IHdpZHRoKSA9PT0gQk5fMCwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZnJvbVR3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgIH0pO1xuICAgIC8vIFRvcCBiaXQgc2V0OyB0cmVhdCBhcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlID4+ICh3aWR0aCAtIEJOXzEpKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gLSgoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSB0byBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZlxuICogICUld2lkdGglJSBiaXRzLlxuICpcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICBpZiAodmFsdWUgPCBCTl8wKSB7XG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgICAgICBhc3NlcnQodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8IGxpbWl0LCBcInRvbyBoaWdoXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIE1hc2sgJSV2YWx1ZSUlIHdpdGggYSBiaXRtYXNrIG9mICUlYml0cyUlIG9uZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuLyoqXG4gKiAgR2V0cyBhIEJpZ0ludCBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIEJpZ0ludCwgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiICYmIHZhbHVlWzFdICE9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLUJpZ0ludCh2YWx1ZS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQmlnTnVtYmVyaXNoIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zICUldmFsdWUlJSBhcyBhIGJpZ2ludCwgdmFsaWRhdGluZyBpdCBpcyB2YWxpZCBhcyBhIGJpZ2ludFxuICogIHZhbHVlIGFuZCB0aGF0IGl0IGlzIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgYXNzZXJ0KHJlc3VsdCA+PSBCTl8wLCBcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLCBvcGVyYXRpb246IFwiZ2V0VWludFwiLCB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHgwXCI7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBOaWJibGVzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0cyBhIC8vbnVtYmVyLy8gZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSAvL251bWJlci8vLCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJ1bmRlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIoQmlnSW50KHZhbHVlKSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBudW1lcmljIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBudW1iZXIuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiAgaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuIFRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHNhZmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVIZXgoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKF93aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgb2YgZXZlbiBsZW5ndGhcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpO1xuICAgICAgICBhc3NlcnQod2lkdGggKiAyID49IHJlc3VsdC5sZW5ndGgsIGB2YWx1ZSBleGNlZWRzIHdpZHRoICgke3dpZHRofSBieXRlcylgLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvQmVIZXhcIixcbiAgICAgICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQYWQgdGhlIHZhbHVlIHRvIHRoZSByZXF1aXJlZCB3aWR0aFxuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8ICh3aWR0aCAqIDIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUFycmF5KF92YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXSk7XG4gICAgfVxuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDI7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cbiAqXG4gKiAgQSAvL1F1YW50aXR5Ly8gZG9lcyBub3QgaGF2ZSBhbmQgbGVhZGluZyAwIHZhbHVlcyB1bmxlc3MgdGhlIHZhbHVlIGlzXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcbiAqICBudW1lcmljIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUXVhbnRpdHkodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gaGV4bGlmeShpc0J5dGVzTGlrZSh2YWx1ZSkgPyB2YWx1ZSA6IHRvQmVBcnJheSh2YWx1ZSkpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAocmVzdWx0LnN0YXJ0c1dpdGgoXCIwXCIpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCI7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRocy5qcy5tYXAiXSwibmFtZXMiOlsiaGV4bGlmeSIsImlzQnl0ZXNMaWtlIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIm1heFZhbHVlIiwiZnJvbVR3b3MiLCJfdmFsdWUiLCJfd2lkdGgiLCJ2YWx1ZSIsImdldFVpbnQiLCJ3aWR0aCIsImdldE51bWJlciIsIm9wZXJhdGlvbiIsImZhdWx0IiwibWFzayIsInRvVHdvcyIsImdldEJpZ0ludCIsImxpbWl0IiwiX2JpdHMiLCJiaXRzIiwibmFtZSIsIk51bWJlciIsImlzSW50ZWdlciIsIkVycm9yIiwic3Vic3RyaW5nIiwiZSIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJOaWJibGVzIiwidG9CaWdJbnQiLCJVaW50OEFycmF5IiwidiIsInRvTnVtYmVyIiwidG9CZUhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwidG9CZUFycmF5IiwiaGV4IiwiaSIsIm9mZnNldCIsInBhcnNlSW50IiwidG9RdWFudGl0eSIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0NBSUMsR0FDRCxTQUFTQSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxNQUFNQyxRQUFRRixLQUFLRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJO0lBQzdDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsT0FBUVA7WUFDSixLQUFLO2dCQUNEO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLE9BQVFELFVBQVdDLE1BQU07b0JBQ3pCO2dCQUNKO1FBQ1I7SUFDSjtJQUNBLE1BQU1TLFFBQVEsSUFBSUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFVixLQUFLLENBQUM7SUFDeERTLE1BQU1FLElBQUksR0FBRztJQUNiRixNQUFNRyxRQUFRLEdBQUcsQ0FBQyxNQUFNLEVBQUVYLEtBQUssQ0FBQztJQUNoQ1EsTUFBTVYsS0FBSyxHQUFHQTtJQUNkLE1BQU1VO0FBQ1Y7QUFDQTs7O0NBR0MsR0FDTSxlQUFlSSxrQkFBa0JkLEtBQUs7SUFDekMsTUFBTWUsT0FBT0MsT0FBT0QsSUFBSSxDQUFDZjtJQUN6QixNQUFNaUIsVUFBVSxNQUFNQyxRQUFRQyxHQUFHLENBQUNKLEtBQUtWLEdBQUcsQ0FBQyxDQUFDZSxJQUFNRixRQUFRRyxPQUFPLENBQUNyQixLQUFLLENBQUNvQixFQUFFO0lBQzFFLE9BQU9ILFFBQVFLLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQyxHQUFHQztRQUM3QkYsS0FBSyxDQUFDUixJQUFJLENBQUNVLE1BQU0sQ0FBQyxHQUFHRDtRQUNyQixPQUFPRDtJQUNYLEdBQUcsQ0FBQztBQUNSO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNHLGlCQUFpQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUV6QixLQUFLO0lBQ2xELElBQUssSUFBSTBCLE9BQU9ELE9BQVE7UUFDcEIsSUFBSTVCLFFBQVE0QixNQUFNLENBQUNDLElBQUk7UUFDdkIsTUFBTTVCLE9BQVFFLFFBQVFBLEtBQUssQ0FBQzBCLElBQUksR0FBRztRQUNuQyxJQUFJNUIsTUFBTTtZQUNORixVQUFVQyxPQUFPQyxNQUFNNEI7UUFDM0I7UUFDQWIsT0FBT2MsY0FBYyxDQUFDSCxRQUFRRSxLQUFLO1lBQUVFLFlBQVk7WUFBTS9CO1lBQU9nQyxVQUFVO1FBQU07SUFDbEY7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzPzUyMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgUHJvcGVydHkgaGVscGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpQcm9wZXJ0aWVzICBbYWJvdXQtcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKS5tYXAodCA9PiB0LnRyaW0oKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgICBlcnJvci5jb2RlID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgZXJyb3IuYXJndW1lbnQgPSBgdmFsdWUuJHtuYW1lfWA7XG4gICAgZXJyb3IudmFsdWUgPSB2YWx1ZTtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgY29weSBvZiAlJXZhbHVlJSUsIGJ1dCB3aXRoIGFsbFxuICogIHZhbHVlcyByZXNvbHZlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoa2V5cy5tYXAoKGspID0+IFByb21pc2UucmVzb2x2ZSh2YWx1ZVtrXSkpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCB2LCBpbmRleCkgPT4ge1xuICAgICAgICBhY2N1bVtrZXlzW2luZGV4XV0gPSB2O1xuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQXNzaWducyB0aGUgJSV2YWx1ZXMlJSB0byAlJXRhcmdldCUlIGFzIHJlYWQtb25seSB2YWx1ZXMuXG4gKlxuICogIEl0ICUldHlwZXMlJSBpcyBzcGVjaWZpZWQsIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiXSwibmFtZXMiOlsiY2hlY2tUeXBlIiwidmFsdWUiLCJ0eXBlIiwibmFtZSIsInR5cGVzIiwic3BsaXQiLCJtYXAiLCJ0IiwidHJpbSIsImkiLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwiY29kZSIsImFyZ3VtZW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJrZXlzIiwiT2JqZWN0IiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJrIiwicmVzb2x2ZSIsInJlZHVjZSIsImFjY3VtIiwidiIsImluZGV4IiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInZhbHVlcyIsImtleSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: () => (/* binding */ decodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while(result.length < 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length,\n            offset\n        });\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data,\n        length: 0,\n        offset: 1\n    });\n    const checkOffset = (offset)=>{\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length: data.length,\n            offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: hexlifyByte(data[offset])\n    };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */ function decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n} //# sourceMappingURL=rlp-decode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnREFBZ0Q7QUFDWjtBQUNpQjtBQUNoQjtBQUNyQyxTQUFTSSxZQUFZQyxLQUFLO0lBQ3RCLElBQUlDLFNBQVNELE1BQU1FLFFBQVEsQ0FBQztJQUM1QixNQUFPRCxPQUFPRSxNQUFNLEdBQUcsRUFBRztRQUN0QkYsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT0E7QUFDbEI7QUFDQSxTQUFTRyxrQkFBa0JDLElBQUksRUFBRUMsTUFBTSxFQUFFSCxNQUFNO0lBQzNDLElBQUlGLFNBQVM7SUFDYixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUosUUFBUUksSUFBSztRQUM3Qk4sU0FBUyxTQUFVLE1BQU9JLElBQUksQ0FBQ0MsU0FBU0MsRUFBRTtJQUM5QztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTTyxnQkFBZ0JILElBQUksRUFBRUMsTUFBTSxFQUFFRyxXQUFXLEVBQUVOLE1BQU07SUFDdEQsTUFBTUYsU0FBUyxFQUFFO0lBQ2pCLE1BQU9RLGNBQWNILFNBQVMsSUFBSUgsT0FBUTtRQUN0QyxNQUFNTyxVQUFVQyxRQUFRTixNQUFNSTtRQUM5QlIsT0FBT1csSUFBSSxDQUFDRixRQUFRVCxNQUFNO1FBQzFCUSxlQUFlQyxRQUFRRyxRQUFRO1FBQy9CakIsa0RBQU1BLENBQUNhLGVBQWVILFNBQVMsSUFBSUgsUUFBUSx3QkFBd0Isa0JBQWtCO1lBQ2pGVyxRQUFRVDtZQUFNRjtZQUFRRztRQUMxQjtJQUNKO0lBQ0EsT0FBTztRQUFFTyxVQUFXLElBQUlWO1FBQVNGLFFBQVFBO0lBQU87QUFDcEQ7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBU1UsUUFBUU4sSUFBSSxFQUFFQyxNQUFNO0lBQ3pCVixrREFBTUEsQ0FBQ1MsS0FBS0YsTUFBTSxLQUFLLEdBQUcsa0JBQWtCLGtCQUFrQjtRQUMxRFcsUUFBUVQ7UUFBTUYsUUFBUTtRQUFHRyxRQUFRO0lBQ3JDO0lBQ0EsTUFBTVMsY0FBYyxDQUFDVDtRQUNqQlYsa0RBQU1BLENBQUNVLFVBQVVELEtBQUtGLE1BQU0sRUFBRSxnQ0FBZ0Msa0JBQWtCO1lBQzVFVyxRQUFRVDtZQUFNRixRQUFRRSxLQUFLRixNQUFNO1lBQUVHO1FBQ3ZDO0lBQ0o7SUFDQSxpQ0FBaUM7SUFDakMsSUFBSUQsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUN0QixNQUFNVSxlQUFlWCxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNwQ1MsWUFBWVQsU0FBUyxJQUFJVTtRQUN6QixNQUFNYixTQUFTQyxrQkFBa0JDLE1BQU1DLFNBQVMsR0FBR1U7UUFDbkRELFlBQVlULFNBQVMsSUFBSVUsZUFBZWI7UUFDeEMsT0FBT0ssZ0JBQWdCSCxNQUFNQyxRQUFRQSxTQUFTLElBQUlVLGNBQWNBLGVBQWViO0lBQ25GLE9BQ0ssSUFBSUUsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUMzQixNQUFNSCxTQUFTRSxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUM5QlMsWUFBWVQsU0FBUyxJQUFJSDtRQUN6QixPQUFPSyxnQkFBZ0JILE1BQU1DLFFBQVFBLFNBQVMsR0FBR0g7SUFDckQsT0FDSyxJQUFJRSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1VLGVBQWVYLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ3BDUyxZQUFZVCxTQUFTLElBQUlVO1FBQ3pCLE1BQU1iLFNBQVNDLGtCQUFrQkMsTUFBTUMsU0FBUyxHQUFHVTtRQUNuREQsWUFBWVQsU0FBUyxJQUFJVSxlQUFlYjtRQUN4QyxNQUFNRixTQUFTTixpREFBT0EsQ0FBQ1UsS0FBS1ksS0FBSyxDQUFDWCxTQUFTLElBQUlVLGNBQWNWLFNBQVMsSUFBSVUsZUFBZWI7UUFDekYsT0FBTztZQUFFVSxVQUFXLElBQUlHLGVBQWViO1lBQVNGLFFBQVFBO1FBQU87SUFDbkUsT0FDSyxJQUFJSSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1ILFNBQVNFLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQzlCUyxZQUFZVCxTQUFTLElBQUlIO1FBQ3pCLE1BQU1GLFNBQVNOLGlEQUFPQSxDQUFDVSxLQUFLWSxLQUFLLENBQUNYLFNBQVMsR0FBR0EsU0FBUyxJQUFJSDtRQUMzRCxPQUFPO1lBQUVVLFVBQVcsSUFBSVY7WUFBU0YsUUFBUUE7UUFBTztJQUNwRDtJQUNBLE9BQU87UUFBRVksVUFBVTtRQUFHWixRQUFRRixZQUFZTSxJQUFJLENBQUNDLE9BQU87SUFBRTtBQUM1RDtBQUNBOztDQUVDLEdBQ00sU0FBU1ksVUFBVUMsS0FBSztJQUMzQixNQUFNZCxPQUFPUCxrREFBUUEsQ0FBQ3FCLE9BQU87SUFDN0IsTUFBTVQsVUFBVUMsUUFBUU4sTUFBTTtJQUM5QlIsMERBQWNBLENBQUNhLFFBQVFHLFFBQVEsS0FBS1IsS0FBS0YsTUFBTSxFQUFFLHFDQUFxQyxRQUFRZ0I7SUFDOUYsT0FBT1QsUUFBUVQsTUFBTTtBQUN6QixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZGVjb2RlLmpzPzZlMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBhc3NlcnQoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiXSwibmFtZXMiOlsiaGV4bGlmeSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5Qnl0ZSIsInZhbHVlIiwicmVzdWx0IiwidG9TdHJpbmciLCJsZW5ndGgiLCJ1bmFycmF5aWZ5SW50ZWdlciIsImRhdGEiLCJvZmZzZXQiLCJpIiwiX2RlY29kZUNoaWxkcmVuIiwiY2hpbGRPZmZzZXQiLCJkZWNvZGVkIiwiX2RlY29kZSIsInB1c2giLCJjb25zdW1lZCIsImJ1ZmZlciIsImNoZWNrT2Zmc2V0IiwibGVuZ3RoTGVuZ3RoIiwic2xpY2UiLCJkZWNvZGVSbHAiLCJfZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: () => (/* binding */ encodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */ function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)){\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n} //# sourceMappingURL=rlp-encode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUFnRDtBQUNYO0FBQ3JDLFNBQVNDLGdCQUFnQkMsS0FBSztJQUMxQixNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBT0QsTUFBTztRQUNWQyxPQUFPQyxPQUFPLENBQUNGLFFBQVE7UUFDdkJBLFVBQVU7SUFDZDtJQUNBLE9BQU9DO0FBQ1g7QUFDQSxTQUFTRSxRQUFRQyxNQUFNO0lBQ25CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN2QixJQUFJRyxVQUFVLEVBQUU7UUFDaEJILE9BQU9JLE9BQU8sQ0FBQyxTQUFVQyxLQUFLO1lBQzFCRixVQUFVQSxRQUFRRyxNQUFNLENBQUNQLFFBQVFNO1FBQ3JDO1FBQ0EsSUFBSUYsUUFBUUksTUFBTSxJQUFJLElBQUk7WUFDdEJKLFFBQVFMLE9BQU8sQ0FBQyxPQUFPSyxRQUFRSSxNQUFNO1lBQ3JDLE9BQU9KO1FBQ1g7UUFDQSxNQUFNSSxTQUFTWixnQkFBZ0JRLFFBQVFJLE1BQU07UUFDN0NBLE9BQU9ULE9BQU8sQ0FBQyxPQUFPUyxPQUFPQSxNQUFNO1FBQ25DLE9BQU9BLE9BQU9ELE1BQU0sQ0FBQ0g7SUFDekI7SUFDQSxNQUFNSyxPQUFPUCxNQUFNUSxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDakIsa0RBQVFBLENBQUNNLFFBQVE7SUFDekQsSUFBSVEsS0FBS0QsTUFBTSxLQUFLLEtBQUtDLElBQUksQ0FBQyxFQUFFLElBQUksTUFBTTtRQUN0QyxPQUFPQTtJQUNYLE9BQ0ssSUFBSUEsS0FBS0QsTUFBTSxJQUFJLElBQUk7UUFDeEJDLEtBQUtWLE9BQU8sQ0FBQyxPQUFPVSxLQUFLRCxNQUFNO1FBQy9CLE9BQU9DO0lBQ1g7SUFDQSxNQUFNRCxTQUFTWixnQkFBZ0JhLEtBQUtELE1BQU07SUFDMUNBLE9BQU9ULE9BQU8sQ0FBQyxPQUFPUyxPQUFPQSxNQUFNO0lBQ25DLE9BQU9BLE9BQU9ELE1BQU0sQ0FBQ0U7QUFDekI7QUFDQSxNQUFNSSxVQUFVO0FBQ2hCOztDQUVDLEdBQ00sU0FBU0MsVUFBVWIsTUFBTTtJQUM1QixJQUFJSCxTQUFTO0lBQ2IsS0FBSyxNQUFNaUIsS0FBS2YsUUFBUUMsUUFBUztRQUM3QkgsVUFBVWUsT0FBTyxDQUFDRSxLQUFLLEVBQUU7UUFDekJqQixVQUFVZSxPQUFPLENBQUNFLElBQUksSUFBSTtJQUM5QjtJQUNBLE9BQU9qQjtBQUNYLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVndWNoYWluLXdhdGNoLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1lbmNvZGUuanM/MDc4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0Qnl0ZXMob2JqZWN0LCBcIm9iamVjdFwiKSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcbn1cbmNvbnN0IG5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIEVuY29kZXMgJSVvYmplY3QlJSBhcyBhbiBSTFAtZW5jb2RlZCBbW0RhdGFIZXhTdHJpbmddXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlcyIsImFycmF5aWZ5SW50ZWdlciIsInZhbHVlIiwicmVzdWx0IiwidW5zaGlmdCIsIl9lbmNvZGUiLCJvYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJwYXlsb2FkIiwiZm9yRWFjaCIsImNoaWxkIiwiY29uY2F0IiwibGVuZ3RoIiwiZGF0YSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsIm5pYmJsZXMiLCJlbmNvZGVSbHAiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */ \n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */ function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, {\n        decimals,\n        width: 512\n    }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */ function parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof value === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, {\n        decimals,\n        width: 512\n    }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */ function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */ function parseEther(ether) {\n    return parseUnits(ether, 18);\n} //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUM0QztBQUNFO0FBQ1I7QUFDdkMsTUFBTUcsUUFBUTtJQUNWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRDs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFlBQVlDLEtBQUssRUFBRUMsSUFBSTtJQUNuQyxJQUFJQyxXQUFXO0lBQ2YsSUFBSSxPQUFRRCxTQUFVLFVBQVU7UUFDNUIsTUFBTUUsUUFBUUwsTUFBTU0sT0FBTyxDQUFDSDtRQUM1Qk4sMERBQWNBLENBQUNRLFNBQVMsR0FBRyxnQkFBZ0IsUUFBUUY7UUFDbkRDLFdBQVcsSUFBSUM7SUFDbkIsT0FDSyxJQUFJRixRQUFRLE1BQU07UUFDbkJDLFdBQVdMLG9EQUFTQSxDQUFDSSxNQUFNO0lBQy9CO0lBQ0EsT0FBT0wsd0RBQVdBLENBQUNTLFNBQVMsQ0FBQ0wsT0FBT0UsVUFBVTtRQUFFQTtRQUFVSSxPQUFPO0lBQUksR0FBR0MsUUFBUTtBQUNwRjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxXQUFXUixLQUFLLEVBQUVDLElBQUk7SUFDbENOLDBEQUFjQSxDQUFDLE9BQVFLLFVBQVcsVUFBVSwwQkFBMEIsU0FBU0E7SUFDL0UsSUFBSUUsV0FBVztJQUNmLElBQUksT0FBUUQsU0FBVSxVQUFVO1FBQzVCLE1BQU1FLFFBQVFMLE1BQU1NLE9BQU8sQ0FBQ0g7UUFDNUJOLDBEQUFjQSxDQUFDUSxTQUFTLEdBQUcsZ0JBQWdCLFFBQVFGO1FBQ25EQyxXQUFXLElBQUlDO0lBQ25CLE9BQ0ssSUFBSUYsUUFBUSxNQUFNO1FBQ25CQyxXQUFXTCxvREFBU0EsQ0FBQ0ksTUFBTTtJQUMvQjtJQUNBLE9BQU9MLHdEQUFXQSxDQUFDYSxVQUFVLENBQUNULE9BQU87UUFBRUU7UUFBVUksT0FBTztJQUFJLEdBQUdOLEtBQUs7QUFDeEU7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLEdBQUc7SUFDM0IsT0FBT1osWUFBWVksS0FBSztBQUM1QjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLFdBQVdDLEtBQUs7SUFDNUIsT0FBT0wsV0FBV0ssT0FBTztBQUM3QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ3VjaGFpbi13YXRjaC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91bml0cy5qcz82OGFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIE1vc3QgaW50ZXJhY3Rpb25zIHdpdGggRXRoZXJldW0gcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXMsIHdoaWNoIHVzZVxuICogIHRoZSBzbWFsbGVzdCBtYWduaXR1ZGUgdW5pdC5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgZGVhbGluZyB3aXRoIGRvbGxhcnMgYW5kIGNlbnRzLiBTaW5jZSBkb2xsYXJzXG4gKiAgYXJlIGRpdmlzaWJsZSwgbm9uLWludGVnZXIgdmFsdWVzIGFyZSBwb3NzaWJsZSwgc3VjaCBhcyBgYCQxMC43N2BgLlxuICogIEJ5IHVzaW5nIHRoZSBzbWFsbGVzdCBpbmRpdmlzaWJsZSB1bml0IChpLmUuIGNlbnRzKSwgdGhlIHZhbHVlIGNhblxuICogIGJlIGtlcHQgYXMgdGhlIGludGVnZXIgYGAxMDc3YGAuXG4gKlxuICogIFdoZW4gcmVjZWl2aW5nIGRlY2ltYWwgaW5wdXQgZnJvbSB0aGUgdXNlciAoYXMgYSBkZWNpbWFsIHN0cmluZyksXG4gKiAgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBhbmQgd2hlbiBzaG93aW5nIGEgdXNlclxuICogIGEgdmFsdWUsIHRoZSBpbnRlZ2VyIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiAgVGhpcyBjcmVhdGVzIGEgY2xlYXIgZGlzdGluY3Rpb24sIGJldHdlZW4gdmFsdWVzIHRvIGJlIHVzZWQgYnkgY29kZVxuICogIChpbnRlZ2VycykgYW5kIHZhbHVlcyB1c2VkIGZvciBkaXNwbGF5IGxvZ2ljIHRvIHVzZXJzIChkZWNpbWFscykuXG4gKlxuICogIFRoZSBuYXRpdmUgdW5pdCBpbiBFdGhlcmV1bSwgLy9ldGhlci8vIGlzIGRpdmlzaWJsZSB0byAxOCBkZWNpbWFsIHBsYWNlcyxcbiAqICB3aGVyZSBlYWNoIGluZGl2aWR1YWwgdW5pdCBpcyBjYWxsZWQgYSAvL3dlaS8vLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlVuaXQgQ29udmVyc2lvbiAgW2Fib3V0LXVuaXRzXVxuICovXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgRml4ZWROdW1iZXIgfSBmcm9tIFwiLi9maXhlZG51bWJlci5qc1wiO1xuaW1wb3J0IHsgZ2V0TnVtYmVyIH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmNvbnN0IG5hbWVzID0gW1xuICAgIFwid2VpXCIsXG4gICAgXCJrd2VpXCIsXG4gICAgXCJtd2VpXCIsXG4gICAgXCJnd2VpXCIsXG4gICAgXCJzemFib1wiLFxuICAgIFwiZmlubmV5XCIsXG4gICAgXCJldGhlclwiLFxuXTtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vLCBhc3N1bWluZyAlJXVuaXQlJSBkZWNpbWFsXG4gKiAgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IGJlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3IgdGhlIG5hbWUgb2ZcbiAqICBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gZ2V0TnVtYmVyKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSV2YWx1ZSUlIHRvIGEgQmlnSW50LCBhc3N1bWluZ1xuICogICUldW5pdCUlIGRlY2ltYWwgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqICBvciB0aGUgbmFtZSBvZiBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVW5pdHModmFsdWUsIHVuaXQpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gZ2V0TnVtYmVyKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLyB1c2luZyAxOCBkZWNpbWFsIHBsYWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcbn1cbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSVldGhlciUlIHRvIGEgQmlnSW50LCB1c2luZyAxOFxuICogIGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0QXJndW1lbnQiLCJGaXhlZE51bWJlciIsImdldE51bWJlciIsIm5hbWVzIiwiZm9ybWF0VW5pdHMiLCJ2YWx1ZSIsInVuaXQiLCJkZWNpbWFscyIsImluZGV4IiwiaW5kZXhPZiIsImZyb21WYWx1ZSIsIndpZHRoIiwidG9TdHJpbmciLCJwYXJzZVVuaXRzIiwiZnJvbVN0cmluZyIsImZvcm1hdEV0aGVyIiwid2VpIiwicGFyc2VFdGhlciIsImV0aGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/units.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ \n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof str === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ29DO0FBQ3lCO0FBQzlELFNBQVNHLFVBQVVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUMxRFAsMERBQWNBLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFSSxPQUFPLEVBQUUsRUFBRUQsT0FBTyxDQUFDLEVBQUUsU0FBU0U7QUFDdkY7QUFDQSxTQUFTRyxXQUFXTCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0QsdUdBQXVHO0lBQ3ZHLElBQUlKLFdBQVcsZ0JBQWdCQSxXQUFXLHVCQUF1QjtRQUM3RCxJQUFJTSxJQUFJO1FBQ1IsSUFBSyxJQUFJQyxJQUFJTixTQUFTLEdBQUdNLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztZQUM1QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsSUFBSSxNQUFNLE1BQU07Z0JBQ3hCO1lBQ0o7WUFDQUQ7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLElBQUlOLFdBQVcsV0FBVztRQUN0QixPQUFPRSxNQUFNTSxNQUFNLEdBQUdQLFNBQVM7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEIsT0FBTztBQUNYO0FBQ0EsU0FBU1EsWUFBWVQsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzVELHNGQUFzRjtJQUN0RixJQUFJSixXQUFXLFlBQVk7UUFDdkJILDBEQUFjQSxDQUFDLE9BQVFPLGlCQUFrQixVQUFVLDBDQUEwQyxnQkFBZ0JBO1FBQzdHRCxPQUFPTyxJQUFJLENBQUNOO1FBQ1osT0FBTztJQUNYO0lBQ0EsZ0RBQWdEO0lBQ2hERCxPQUFPTyxJQUFJLENBQUM7SUFDWiwyQ0FBMkM7SUFDM0MsT0FBT0wsV0FBV0wsUUFBUUMsUUFBUUMsT0FBT0MsUUFBUUM7QUFDckQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLE1BQU1PLGlCQUFpQkMsT0FBT0MsTUFBTSxDQUFDO0lBQ3hDQyxPQUFPZjtJQUNQZ0IsUUFBUVY7SUFDUlcsU0FBU1A7QUFDYixHQUFHO0FBQ0gsb0ZBQW9GO0FBQ3BGLFNBQVNRLGtCQUFrQkMsTUFBTSxFQUFFQyxPQUFPO0lBQ3RDLElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVVIsZUFBZUcsS0FBSztJQUNsQztJQUNBLE1BQU1aLFFBQVFOLGtEQUFRQSxDQUFDc0IsUUFBUTtJQUMvQixNQUFNRSxTQUFTLEVBQUU7SUFDakIsSUFBSWQsSUFBSTtJQUNSLDRCQUE0QjtJQUM1QixNQUFPQSxJQUFJSixNQUFNTSxNQUFNLENBQUU7UUFDckIsTUFBTWEsSUFBSW5CLEtBQUssQ0FBQ0ksSUFBSTtRQUNwQixZQUFZO1FBQ1osSUFBSWUsS0FBSyxNQUFNLEdBQUc7WUFDZEQsT0FBT1YsSUFBSSxDQUFDVztZQUNaO1FBQ0o7UUFDQSxxREFBcUQ7UUFDckQsSUFBSUMsY0FBYztRQUNsQixJQUFJQyxlQUFlO1FBQ25CLHNCQUFzQjtRQUN0QixJQUFJLENBQUNGLElBQUksSUFBRyxNQUFPLE1BQU07WUFDckJDLGNBQWM7WUFDZEMsZUFBZTtRQUNmLGdDQUFnQztRQUNwQyxPQUNLLElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtZQUMxQkMsY0FBYztZQUNkQyxlQUFlO1FBQ2YsMENBQTBDO1FBQzlDLE9BQ0ssSUFBSSxDQUFDRixJQUFJLElBQUcsTUFBTyxNQUFNO1lBQzFCQyxjQUFjO1lBQ2RDLGVBQWU7UUFDbkIsT0FDSztZQUNELElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtnQkFDckJmLEtBQUthLFFBQVEsdUJBQXVCYixJQUFJLEdBQUdKLE9BQU9rQjtZQUN0RCxPQUNLO2dCQUNEZCxLQUFLYSxRQUFRLGNBQWNiLElBQUksR0FBR0osT0FBT2tCO1lBQzdDO1lBQ0E7UUFDSjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJZCxJQUFJLElBQUlnQixlQUFlcEIsTUFBTU0sTUFBTSxFQUFFO1lBQ3JDRixLQUFLYSxRQUFRLFdBQVdiLElBQUksR0FBR0osT0FBT2tCO1lBQ3RDO1FBQ0o7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSUksTUFBTUgsSUFBSyxDQUFDLEtBQU0sSUFBSUMsY0FBYyxDQUFDLElBQUs7UUFDOUMsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlILGFBQWFHLElBQUs7WUFDbEMsSUFBSUMsV0FBV3hCLEtBQUssQ0FBQ0ksRUFBRTtZQUN2Qiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDb0IsV0FBVyxJQUFHLEtBQU0sTUFBTTtnQkFDM0JwQixLQUFLYSxRQUFRLG9CQUFvQmIsR0FBR0osT0FBT2tCO2dCQUMzQ0ksTUFBTTtnQkFDTjtZQUNKOztZQUVBQSxNQUFNLE9BQVEsSUFBTUUsV0FBVztZQUMvQnBCO1FBQ0o7UUFDQSwrQ0FBK0M7UUFDL0MsSUFBSWtCLFFBQVEsTUFBTTtZQUNkO1FBQ0o7UUFDQSxxQkFBcUI7UUFDckIsSUFBSUEsTUFBTSxVQUFVO1lBQ2hCbEIsS0FBS2EsUUFBUSxnQkFBZ0JiLElBQUksSUFBSWdCLGFBQWFwQixPQUFPa0IsUUFBUUk7WUFDakU7UUFDSjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJQSxPQUFPLFVBQVVBLE9BQU8sUUFBUTtZQUNoQ2xCLEtBQUthLFFBQVEsbUJBQW1CYixJQUFJLElBQUlnQixhQUFhcEIsT0FBT2tCLFFBQVFJO1lBQ3BFO1FBQ0o7UUFDQSx3REFBd0Q7UUFDeEQsSUFBSUEsT0FBT0QsY0FBYztZQUNyQmpCLEtBQUthLFFBQVEsWUFBWWIsSUFBSSxJQUFJZ0IsYUFBYXBCLE9BQU9rQixRQUFRSTtZQUM3RDtRQUNKO1FBQ0FKLE9BQU9WLElBQUksQ0FBQ2M7SUFDaEI7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsdUZBQXVGO0FBQ3ZGOzs7O0NBSUMsR0FDTSxTQUFTTyxZQUFZQyxHQUFHLEVBQUVDLElBQUk7SUFDakNoQywwREFBY0EsQ0FBQyxPQUFRK0IsUUFBUyxVQUFVLHdCQUF3QixPQUFPQTtJQUN6RSxJQUFJQyxRQUFRLE1BQU07UUFDZC9CLDJEQUFlQSxDQUFDK0I7UUFDaEJELE1BQU1BLElBQUlFLFNBQVMsQ0FBQ0Q7SUFDeEI7SUFDQSxJQUFJVCxTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlkLElBQUksR0FBR0EsSUFBSXNCLElBQUlwQixNQUFNLEVBQUVGLElBQUs7UUFDakMsTUFBTWUsSUFBSU8sSUFBSUcsVUFBVSxDQUFDekI7UUFDekIsSUFBSWUsSUFBSSxNQUFNO1lBQ1ZELE9BQU9WLElBQUksQ0FBQ1c7UUFDaEIsT0FDSyxJQUFJQSxJQUFJLE9BQU87WUFDaEJELE9BQU9WLElBQUksQ0FBQyxLQUFNLElBQUs7WUFDdkJVLE9BQU9WLElBQUksQ0FBQyxJQUFLLE9BQVE7UUFDN0IsT0FDSyxJQUFJLENBQUNXLElBQUksTUFBSyxLQUFNLFFBQVE7WUFDN0JmO1lBQ0EsTUFBTTBCLEtBQUtKLElBQUlHLFVBQVUsQ0FBQ3pCO1lBQzFCVCwwREFBY0EsQ0FBQ1MsSUFBSXNCLElBQUlwQixNQUFNLElBQUssQ0FBQ3dCLEtBQUssTUFBSyxNQUFPLFFBQVMsMEJBQTBCLE9BQU9KO1lBQzlGLGlCQUFpQjtZQUNqQixNQUFNSyxPQUFPLFVBQVcsRUFBQ1osSUFBSSxNQUFLLEtBQU0sRUFBQyxJQUFNVyxDQUFBQSxLQUFLLE1BQUs7WUFDekRaLE9BQU9WLElBQUksQ0FBQyxRQUFTLEtBQU07WUFDM0JVLE9BQU9WLElBQUksQ0FBQyxRQUFVLEtBQU0sT0FBUTtZQUNwQ1UsT0FBT1YsSUFBSSxDQUFDLFFBQVUsSUFBSyxPQUFRO1lBQ25DVSxPQUFPVixJQUFJLENBQUMsT0FBUSxPQUFRO1FBQ2hDLE9BQ0s7WUFDRFUsT0FBT1YsSUFBSSxDQUFDLEtBQU0sS0FBTTtZQUN4QlUsT0FBT1YsSUFBSSxDQUFDLEtBQU8sSUFBSyxPQUFRO1lBQ2hDVSxPQUFPVixJQUFJLENBQUMsSUFBSyxPQUFRO1FBQzdCO0lBQ0o7SUFDQSxPQUFPLElBQUl3QixXQUFXZDtBQUMxQjs7QUFFQSxTQUFTO0FBQ1QsU0FBU2UsY0FBY0MsVUFBVTtJQUM3QixPQUFPQSxXQUFXQyxHQUFHLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsYUFBYSxRQUFRO1lBQ3JCLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ0Y7UUFDL0I7UUFDQUEsYUFBYTtRQUNiLE9BQU9DLE9BQU9DLFlBQVksQ0FBRSxDQUFDLGFBQWMsS0FBTSxLQUFJLElBQUssUUFBVSxDQUFDRixZQUFZLEtBQUksSUFBSztJQUM5RixHQUFHRyxJQUFJLENBQUM7QUFDWjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGFBQWF4QyxLQUFLLEVBQUVpQixPQUFPO0lBQ3ZDLE9BQU9nQixjQUFjbEIsa0JBQWtCZixPQUFPaUI7QUFDbEQ7QUFDQTs7OztDQUlDLEdBQ00sU0FBU3dCLGlCQUFpQmYsR0FBRyxFQUFFQyxJQUFJO0lBQ3RDLE9BQU9aLGtCQUFrQlUsWUFBWUMsS0FBS0M7QUFDOUMsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWd1Y2hhaW4td2F0Y2gtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcz8zMmJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBhc3NlcnROb3JtYWxpemUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoc3RyKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZyB2YWx1ZVwiLCBcInN0clwiLCBzdHIpO1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0Tm9ybWFsaXplKGZvcm0pO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBjb2RlLXBvaW50cyBmb3IgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnROb3JtYWxpemUiLCJlcnJvckZ1bmMiLCJyZWFzb24iLCJvZmZzZXQiLCJieXRlcyIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJpIiwibyIsImxlbmd0aCIsInJlcGxhY2VGdW5jIiwicHVzaCIsIlV0ZjhFcnJvckZ1bmNzIiwiT2JqZWN0IiwiZnJlZXplIiwiZXJyb3IiLCJpZ25vcmUiLCJyZXBsYWNlIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJfYnl0ZXMiLCJvbkVycm9yIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwidG9VdGY4Qnl0ZXMiLCJzdHIiLCJmb3JtIiwibm9ybWFsaXplIiwiY2hhckNvZGVBdCIsImMyIiwicGFpciIsIlVpbnQ4QXJyYXkiLCJfdG9VdGY4U3RyaW5nIiwiY29kZVBvaW50cyIsIm1hcCIsImNvZGVQb2ludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhDb2RlUG9pbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\n");

/***/ })

};
;